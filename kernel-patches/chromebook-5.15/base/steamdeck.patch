diff -ruN a/sound/soc/amd/vangogh/acp5x.h b/sound/soc/amd/vangogh/acp5x.h
--- a/sound/soc/amd/vangogh/acp5x.h	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/vangogh/acp5x.h	2022-07-08 01:12:12.000000000 +0200
@@ -23,7 +23,7 @@
 #define ACP_ERR_INTR_MASK	0x20000000
 #define ACP_EXT_INTR_STAT_CLEAR_MASK 0xFFFFFFFF
 
-#define ACP5x_DEVS 3
+#define ACP5x_DEVS 4
 #define	ACP5x_REG_START	0x1240000
 #define	ACP5x_REG_END	0x1250200
 #define ACP5x_I2STDM_REG_START	0x1242400
@@ -85,7 +85,7 @@
 struct i2s_dev_data {
 	bool tdm_mode;
 	bool master_mode;
-	int i2s_irq;
+	unsigned int i2s_irq;
 	u16 i2s_instance;
 	u32 tdm_fmt;
 	void __iomem *acp5x_base;
@@ -105,6 +105,8 @@
 	dma_addr_t dma_addr;
 	u64 bytescount;
 	void __iomem *acp5x_base;
+	u32 lrclk_div;
+	u32 bclk_div;
 };
 
 union acp_dma_count {
@@ -191,3 +193,30 @@
 	}
 	return byte_count.bytescount;
 }
+
+static inline void acp5x_i2s_set_mclk(struct i2s_dev_data *adata,
+				      struct i2s_stream_instance *rtd)
+{
+	union acp_i2stdm_mstrclkgen mclkgen;
+	u32 master_reg;
+
+	switch (rtd->i2s_instance) {
+	case I2S_HS_INSTANCE:
+		master_reg = ACP_I2STDM2_MSTRCLKGEN;
+		break;
+	case I2S_SP_INSTANCE:
+	default:
+		master_reg = ACP_I2STDM0_MSTRCLKGEN;
+		break;
+	}
+
+	mclkgen.bits.i2stdm_master_mode = 0x1;
+	if (adata->tdm_mode)
+		mclkgen.bits.i2stdm_format_mode = 0x01;
+	else
+		mclkgen.bits.i2stdm_format_mode = 0x00;
+
+	mclkgen.bits.i2stdm_bclk_div_val = rtd->bclk_div;
+	mclkgen.bits.i2stdm_lrclk_div_val = rtd->lrclk_div;
+	acp_writel(mclkgen.u32_all, rtd->acp5x_base + master_reg);
+}
diff -ruN a/sound/soc/amd/vangogh/acp5x-i2s.c b/sound/soc/amd/vangogh/acp5x-i2s.c
--- a/sound/soc/amd/vangogh/acp5x-i2s.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/vangogh/acp5x-i2s.c	2022-07-08 01:12:12.000000000 +0200
@@ -88,10 +88,9 @@
 	struct snd_soc_card *card;
 	struct acp5x_platform_info *pinfo;
 	struct i2s_dev_data *adata;
-	union acp_i2stdm_mstrclkgen mclkgen;
 
 	u32 val;
-	u32 reg_val, frmt_reg, master_reg;
+	u32 reg_val, frmt_reg;
 	u32 lrclk_div_val, bclk_div_val;
 
 	lrclk_div_val = 0;
@@ -160,20 +159,6 @@
 	acp_writel(val, rtd->acp5x_base + reg_val);
 
 	if (adata->master_mode) {
-		switch (rtd->i2s_instance) {
-		case I2S_HS_INSTANCE:
-			master_reg = ACP_I2STDM2_MSTRCLKGEN;
-			break;
-		case I2S_SP_INSTANCE:
-		default:
-			master_reg = ACP_I2STDM0_MSTRCLKGEN;
-			break;
-		}
-		mclkgen.bits.i2stdm_master_mode = 0x1;
-		if (adata->tdm_mode)
-			mclkgen.bits.i2stdm_format_mode = 0x01;
-		else
-			mclkgen.bits.i2stdm_format_mode = 0x0;
 		switch (params_format(params)) {
 		case SNDRV_PCM_FORMAT_S16_LE:
 			switch (params_rate(params)) {
@@ -238,9 +223,8 @@
 		default:
 			return -EINVAL;
 		}
-		mclkgen.bits.i2stdm_bclk_div_val = bclk_div_val;
-		mclkgen.bits.i2stdm_lrclk_div_val = lrclk_div_val;
-		acp_writel(mclkgen.u32_all, rtd->acp5x_base + master_reg);
+		rtd->lrclk_div = lrclk_div_val;
+		rtd->bclk_div = bclk_div_val;
 	}
 	return 0;
 }
@@ -249,9 +233,11 @@
 			     int cmd, struct snd_soc_dai *dai)
 {
 	struct i2s_stream_instance *rtd;
+	struct i2s_dev_data *adata;
 	u32 ret, val, period_bytes, reg_val, ier_val, water_val;
-	u32 buf_size, buf_reg;
+	u32 buf_size, buf_reg, master_reg;
 
+	adata = snd_soc_dai_get_drvdata(dai);
 	rtd = substream->runtime->private_data;
 	period_bytes = frames_to_bytes(substream->runtime,
 				       substream->runtime->period_size);
@@ -300,6 +286,8 @@
 		}
 		acp_writel(period_bytes, rtd->acp5x_base + water_val);
 		acp_writel(buf_size, rtd->acp5x_base + buf_reg);
+		if (adata->master_mode)
+			acp5x_i2s_set_mclk(adata, rtd);
 		val = acp_readl(rtd->acp5x_base + reg_val);
 		val = val | BIT(0);
 		acp_writel(val, rtd->acp5x_base + reg_val);
@@ -400,8 +387,8 @@
 	}
 	adata->acp5x_base = devm_ioremap(&pdev->dev, res->start,
 					 resource_size(res));
-	if (!adata->acp5x_base)
-		return -ENOMEM;
+	if (IS_ERR(adata->acp5x_base))
+		return PTR_ERR(adata->acp5x_base);
 
 	adata->master_mode = I2S_MASTER_MODE_ENABLE;
 	dev_set_drvdata(&pdev->dev, adata);
diff -ruN a/sound/soc/amd/vangogh/acp5x-mach.c b/sound/soc/amd/vangogh/acp5x-mach.c
--- a/sound/soc/amd/vangogh/acp5x-mach.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/vangogh/acp5x-mach.c	2022-07-08 01:12:12.000000000 +0200
@@ -243,7 +242,7 @@
 
 static struct snd_soc_dai_link acp5x_dai[] = {
 	{
-		.name = "acp5x-8821-play",
+		.name = "acp5x-8825-play",
 		.stream_name = "Playback/Capture",
 		.dai_fmt = SND_SOC_DAIFMT_I2S  | SND_SOC_DAIFMT_NB_NF |
 			   SND_SOC_DAIFMT_CBC_CFC,
diff -ruN a/sound/soc/amd/vangogh/Makefile b/sound/soc/amd/vangogh/Makefile
--- a/sound/soc/amd/vangogh/Makefile	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/vangogh/Makefile	2022-07-08 01:12:12.000000000 +0200
@@ -3,7 +3,9 @@
 snd-pci-acp5x-objs	:= pci-acp5x.o
 snd-acp5x-i2s-objs	:= acp5x-i2s.o
 snd-acp5x-pcm-dma-objs	:= acp5x-pcm-dma.o
+snd-soc-acp5x-mach-objs := acp5x-mach.o
 
 obj-$(CONFIG_SND_SOC_AMD_ACP5x) += snd-pci-acp5x.o
 obj-$(CONFIG_SND_SOC_AMD_ACP5x)	+= snd-acp5x-i2s.o
 obj-$(CONFIG_SND_SOC_AMD_ACP5x) += snd-acp5x-pcm-dma.o
+obj-$(CONFIG_SND_SOC_AMD_VANGOGH_MACH)   += snd-soc-acp5x-mach.o
diff -ruN a/sound/soc/amd/vangogh/pci-acp5x.c b/sound/soc/amd/vangogh/pci-acp5x.c
--- a/sound/soc/amd/vangogh/pci-acp5x.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/vangogh/pci-acp5x.c	2022-07-08 01:12:12.000000000 +0200
@@ -92,12 +92,14 @@
 		pr_err("ACP5x power on failed\n");
 		return ret;
 	}
+	acp_writel(0x01, acp5x_base + ACP_CONTROL);
 	/* Reset */
 	ret = acp5x_reset(acp5x_base);
 	if (ret) {
 		pr_err("ACP5x reset failed\n");
 		return ret;
 	}
+	acp_writel(0x03, acp5x_base + ACP_CLKMUX_SEL);
 	acp5x_enable_interrupts(acp5x_base);
 	return 0;
 }
@@ -113,6 +115,8 @@
 		pr_err("ACP5x reset failed\n");
 		return ret;
 	}
+	acp_writel(0x00, acp5x_base + ACP_CLKMUX_SEL);
+	acp_writel(0x00, acp5x_base + ACP_CONTROL);
 	return 0;
 }
 
@@ -213,6 +217,9 @@
 		pdevinfo[2].num_res = 1;
 		pdevinfo[2].res = &adata->res[2];
 
+		pdevinfo[3].name = "acp5x_mach";
+		pdevinfo[3].id = 0;
+		pdevinfo[3].parent = &pci->dev;
 		for (i = 0; i < ACP5x_DEVS; i++) {
 			adata->pdev[i] =
 				platform_device_register_full(&pdevinfo[i]);
--- a/sound/soc/codecs/nau8821.h	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/codecs/nau8821.h	2022-07-08 01:12:12.000000000 +0200
@@ -525,7 +525,6 @@
 	int jack_eject_debounce;
 	int fs;
 	int dmic_clk_threshold;
-	int key_enable;
 };
 
 int nau8821_enable_jack_detect(struct snd_soc_component *component,
--- a/sound/soc/codecs/nau8821.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/codecs/nau8821.c	2022-07-08 01:12:12.000000000 +0200
@@ -29,14 +29,11 @@
 #define NAU_FVCO_MAX 100000000
 #define NAU_FVCO_MIN 90000000
 
-#define NAU8821_BUTTON SND_JACK_BTN_0
-
 /* the maximum frequency of CLK_ADC and CLK_DAC */
 #define CLK_DA_AD_MAX 6144000
 
 static int nau8821_configure_sysclk(struct nau8821 *nau8821,
 	int clk_id, unsigned int freq);
-static bool nau8821_is_jack_inserted(struct regmap *regmap);
 
 struct nau8821_fll {
 	int mclk_src;
@@ -384,7 +381,7 @@
 			speed_selection = dmic_speed_sel[i].val;
 			break;
 		}
-	if (i == 4)
+	if (speed_selection < 0)
 		return -EINVAL;
 
 	dev_dbg(nau8821->dev,
@@ -496,33 +493,7 @@
 	return 0;
 }
 
-static int system_clock_control(struct snd_soc_dapm_widget *w,
-				struct snd_kcontrol *k, int  event)
-{
-	struct snd_soc_component *component =
-		snd_soc_dapm_to_component(w->dapm);
-	struct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);
-
-	if (SND_SOC_DAPM_EVENT_OFF(event)) {
-		dev_dbg(nau8821->dev, "system clock control : POWER OFF\n");
-		/* Set clock source to disable or internal clock before the
-		 * playback or capture end. Codec needs clock for Jack
-		 * detection and button press if jack inserted; otherwise,
-		 * the clock should be closed.
-		 */
-		if (nau8821_is_jack_inserted(nau8821->regmap)) {
-			nau8821_configure_sysclk(nau8821,
-				NAU8821_CLK_INTERNAL, 0);
-		} else {
-			nau8821_configure_sysclk(nau8821, NAU8821_CLK_DIS, 0);
-		}
-	}
-	return 0;
-}
-
 static const struct snd_soc_dapm_widget nau8821_dapm_widgets[] = {
-	SND_SOC_DAPM_SUPPLY("System Clock", SND_SOC_NOPM, 0, 0,
-		system_clock_control, SND_SOC_DAPM_POST_PMD),
 	SND_SOC_DAPM_SUPPLY("MICBIAS", NAU8821_R74_MIC_BIAS,
 		NAU8821_MICBIAS_POWERUP_SFT, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("DMIC Clock", SND_SOC_NOPM, 0, 0,
@@ -634,9 +605,6 @@
 	{"AIFTX", NULL, "ADCL Digital path"},
 	{"AIFTX", NULL, "ADCR Digital path"},
 
-	{"AIFTX", NULL, "System Clock"},
-	{"AIFRX", NULL, "System Clock"},
-
 	{"DDACL", NULL, "AIFRX"},
 	{"DDACR", NULL, "AIFRX"},
 
@@ -670,40 +638,28 @@
 	{"HPOR", NULL, "Class G"},
 };
 
-static const struct nau8821_osr_attr *
-nau8821_get_osr(struct nau8821 *nau8821, int stream)
+static int nau8821_clock_check(struct nau8821 *nau8821,
+	int stream, int rate, int osr)
 {
-	unsigned int osr;
+	int osrate = 0;
 
 	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		regmap_read(nau8821->regmap, NAU8821_R2C_DAC_CTRL1, &osr);
-		osr &= NAU8821_DAC_OVERSAMPLE_MASK;
 		if (osr >= ARRAY_SIZE(osr_dac_sel))
-			return NULL;
-		return &osr_dac_sel[osr];
+			return -EINVAL;
+		osrate = osr_dac_sel[osr].osr;
 	} else {
-		regmap_read(nau8821->regmap, NAU8821_R2B_ADC_RATE, &osr);
-		osr &= NAU8821_ADC_SYNC_DOWN_MASK;
 		if (osr >= ARRAY_SIZE(osr_adc_sel))
-			return NULL;
-		return &osr_adc_sel[osr];
+			return -EINVAL;
+		osrate = osr_adc_sel[osr].osr;
 	}
-}
-
-static int nau8821_dai_startup(struct snd_pcm_substream *substream,
-			       struct snd_soc_dai *dai)
-{
-	struct snd_soc_component *component = dai->component;
-	struct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);
-	const struct nau8821_osr_attr *osr;
 
-	osr = nau8821_get_osr(nau8821, substream->stream);
-	if (!osr || !osr->osr)
+	if (!osrate || rate * osrate > CLK_DA_AD_MAX) {
+		dev_err(nau8821->dev,
+			"exceed the maximum frequency of CLK_ADC or CLK_DAC");
 		return -EINVAL;
+	}
 
-	return snd_pcm_hw_constraint_minmax(substream->runtime,
-					    SNDRV_PCM_HW_PARAM_RATE,
-					    0, CLK_DA_AD_MAX / osr->osr);
+	return 0;
 }
 
 static int nau8821_hw_params(struct snd_pcm_substream *substream,
@@ -711,8 +667,7 @@
 {
 	struct snd_soc_component *component = dai->component;
 	struct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);
-	unsigned int val_len = 0, ctrl_val, bclk_fs, clk_div;
-	const struct nau8821_osr_attr *osr;
+	unsigned int val_len = 0, osr, ctrl_val, bclk_fs, clk_div;
 
 	nau8821->fs = params_rate(params);
 	/* CLK_DAC or CLK_ADC = OSR * FS
@@ -721,19 +676,27 @@
 	 * values must be selected such that the maximum frequency is less
 	 * than 6.144 MHz.
 	 */
-	osr = nau8821_get_osr(nau8821, substream->stream);
-	if (!osr || !osr->osr)
-		return -EINVAL;
-	if (nau8821->fs * osr->osr > CLK_DA_AD_MAX)
-		return -EINVAL;
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_read(nau8821->regmap, NAU8821_R2C_DAC_CTRL1, &osr);
+		osr &= NAU8821_DAC_OVERSAMPLE_MASK;
+		if (nau8821_clock_check(nau8821, substream->stream,
+			nau8821->fs, osr)) {
+			return -EINVAL;
+		}
 		regmap_update_bits(nau8821->regmap, NAU8821_R03_CLK_DIVIDER,
 			NAU8821_CLK_DAC_SRC_MASK,
-			osr->clk_src << NAU8821_CLK_DAC_SRC_SFT);
-	else
+			osr_dac_sel[osr].clk_src << NAU8821_CLK_DAC_SRC_SFT);
+	} else {
+		regmap_read(nau8821->regmap, NAU8821_R2B_ADC_RATE, &osr);
+		osr &= NAU8821_ADC_SYNC_DOWN_MASK;
+		if (nau8821_clock_check(nau8821, substream->stream,
+			nau8821->fs, osr)) {
+			return -EINVAL;
+		}
 		regmap_update_bits(nau8821->regmap, NAU8821_R03_CLK_DIVIDER,
 			NAU8821_CLK_ADC_SRC_MASK,
-			osr->clk_src << NAU8821_CLK_ADC_SRC_SFT);
+			osr_adc_sel[osr].clk_src << NAU8821_CLK_ADC_SRC_SFT);
+	}
 
 	/* make BCLK and LRC divde configuration if the codec as master. */
 	regmap_read(nau8821->regmap, NAU8821_R1D_I2S_PCM_CTRL2, &ctrl_val);
@@ -848,7 +811,6 @@
 }
 
 static const struct snd_soc_dai_ops nau8821_dai_ops = {
-	.startup = nau8821_dai_startup,
 	.hw_params = nau8821_hw_params,
 	.set_fmt = nau8821_set_dai_fmt,
 	.mute_stream = nau8821_digital_mute,
@@ -949,20 +911,6 @@
 	/* Recover to normal channel input */
 	regmap_update_bits(regmap, NAU8821_R2B_ADC_RATE,
 			NAU8821_ADC_R_SRC_EN, 0);
-	if (nau8821->key_enable) {
-		regmap_update_bits(regmap, NAU8821_R0F_INTERRUPT_MASK,
-			NAU8821_IRQ_KEY_RELEASE_EN |
-			NAU8821_IRQ_KEY_PRESS_EN,
-			NAU8821_IRQ_KEY_RELEASE_EN |
-			NAU8821_IRQ_KEY_PRESS_EN);
-		regmap_update_bits(regmap,
-			NAU8821_R12_INTERRUPT_DIS_CTRL,
-			NAU8821_IRQ_KEY_RELEASE_DIS |
-			NAU8821_IRQ_KEY_PRESS_DIS,
-			NAU8821_IRQ_KEY_RELEASE_DIS |
-			NAU8821_IRQ_KEY_PRESS_DIS);
-	}
-
 }
 
 static void nau8821_jdet_work(struct work_struct *work)
@@ -992,15 +940,6 @@
 		 */
 		regmap_update_bits(regmap, NAU8821_R2B_ADC_RATE,
 			NAU8821_ADC_R_SRC_EN, NAU8821_ADC_R_SRC_EN);
-		if (nau8821->key_enable) {
-			regmap_update_bits(regmap, NAU8821_R0F_INTERRUPT_MASK,
-				NAU8821_IRQ_KEY_RELEASE_EN |
-				NAU8821_IRQ_KEY_PRESS_EN, 0);
-			regmap_update_bits(regmap,
-				NAU8821_R12_INTERRUPT_DIS_CTRL,
-				NAU8821_IRQ_KEY_RELEASE_DIS |
-				NAU8821_IRQ_KEY_PRESS_DIS, 0);
-		}
 	} else {
 		dev_dbg(nau8821->dev, "Headphone connected\n");
 		event |= SND_JACK_HEADPHONE;
@@ -1060,13 +999,6 @@
 		nau8821_eject_jack(nau8821);
 		event_mask |= SND_JACK_HEADSET;
 		clear_irq = NAU8821_JACK_EJECT_IRQ_MASK;
-	} else if (active_irq & NAU8821_KEY_SHORT_PRESS_IRQ) {
-		event |= NAU8821_BUTTON;
-		event_mask |= NAU8821_BUTTON;
-		clear_irq = NAU8821_KEY_SHORT_PRESS_IRQ;
-	} else if (active_irq & NAU8821_KEY_RELEASE_IRQ) {
-		event_mask = NAU8821_BUTTON;
-		clear_irq = NAU8821_KEY_RELEASE_IRQ;
 	} else if ((active_irq & NAU8821_JACK_INSERT_IRQ_MASK) ==
 		NAU8821_JACK_INSERT_DETECTED) {
 		regmap_update_bits(regmap, NAU8821_R71_ANALOG_ADC_1,
@@ -1247,9 +1179,7 @@
 
 /**
  * nau8821_set_fll - FLL configuration of nau8821
- * @component:  codec component
- * @pll_id:  PLL requested
- * @source:  clock source
+ * @codec:  codec component
  * @freq_in:  frequency of input clock source
  * @freq_out:  must be 256*Fs in order to achieve the best performance
  *
@@ -1557,7 +1488,6 @@
 		nau8821->jack_eject_debounce);
 	dev_dbg(dev, "dmic-clk-threshold:       %d\n",
 		nau8821->dmic_clk_threshold);
-	dev_dbg(dev, "key_enable:       %d\n", nau8821->key_enable);
 }
 
 static int nau8821_read_device_properties(struct device *dev,
@@ -1571,8 +1501,6 @@
 		"nuvoton,jkdet-pull-enable");
 	nau8821->jkdet_pull_up = device_property_read_bool(dev,
 		"nuvoton,jkdet-pull-up");
-	nau8821->key_enable = device_property_read_bool(dev,
-		"nuvoton,key-enable");
 	ret = device_property_read_u32(dev, "nuvoton,jkdet-polarity",
 		&nau8821->jkdet_polarity);
 	if (ret)
@@ -1696,7 +1624,8 @@
 	return 0;
 }
 
-static int nau8821_i2c_probe(struct i2c_client *i2c)
+static int nau8821_i2c_probe(struct i2c_client *i2c,
+	const struct i2c_device_id *id)
 {
 	struct device *dev = &i2c->dev;
 	struct nau8821 *nau8821 = dev_get_platdata(&i2c->dev);
@@ -1735,6 +1664,15 @@
 	return ret;
 }
 
+static int nau8821_i2c_remove(struct i2c_client *i2c_client)
+{
+	struct nau8821 *nau8821 = i2c_get_clientdata(i2c_client);
+
+	devm_free_irq(nau8821->dev, nau8821->irq, nau8821);
+
+	return 0;
+}
+
 static const struct i2c_device_id nau8821_i2c_ids[] = {
 	{ "nau8821", 0 },
 	{ }
@@ -1763,7 +1701,8 @@
 		.of_match_table = of_match_ptr(nau8821_of_ids),
 		.acpi_match_table = ACPI_PTR(nau8821_acpi_match),
 	},
-	.probe_new = nau8821_i2c_probe,
+	.probe = nau8821_i2c_probe,
+	.remove = nau8821_i2c_remove,
 	.id_table = nau8821_i2c_ids,
 };
 module_i2c_driver(nau8821_driver);
