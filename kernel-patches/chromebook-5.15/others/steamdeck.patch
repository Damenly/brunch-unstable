diff -ruN a/sound/pci/hda/cs35l41_hda.c b/sound/pci/hda/cs35l41_hda.c
--- a/sound/pci/hda/cs35l41_hda.c	2023-02-15 21:19:59.000000000 +0100
+++ b/sound/pci/hda/cs35l41_hda.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1470 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-//
-// CS35l41 ALSA HDA audio driver
-//
-// Copyright 2021 Cirrus Logic, Inc.
-//
-// Author: Lucas Tanure <tanureal@opensource.cirrus.com>
-
-#include <linux/acpi.h>
-#include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <sound/hda_codec.h>
-#include <sound/soc.h>
-#include <linux/pm_runtime.h>
-#include "hda_local.h"
-#include "hda_auto_parser.h"
-#include "hda_jack.h"
-#include "hda_generic.h"
-#include "hda_component.h"
-#include "cs35l41_hda.h"
-#include "hda_cs_dsp_ctl.h"
-
-#define CS35L41_FIRMWARE_ROOT "cirrus/"
-#define CS35L41_PART "cs35l41"
-
-#define HALO_STATE_DSP_CTL_NAME		"HALO_STATE"
-#define HALO_STATE_DSP_CTL_TYPE		5
-#define HALO_STATE_DSP_CTL_ALG		262308
-#define CAL_R_DSP_CTL_NAME		"CAL_R"
-#define CAL_STATUS_DSP_CTL_NAME		"CAL_STATUS"
-#define CAL_CHECKSUM_DSP_CTL_NAME	"CAL_CHECKSUM"
-#define CAL_AMBIENT_DSP_CTL_NAME	"CAL_AMBIENT"
-#define CAL_DSP_CTL_TYPE		5
-#define CAL_DSP_CTL_ALG			205
-
-static bool firmware_autostart = 1;
-module_param(firmware_autostart, bool, 0444);
-MODULE_PARM_DESC(firmware_autostart, "Allow automatic firmware download on boot"
-			     "(0=Disable, 1=Enable) (default=1); ");
-
-static const struct reg_sequence cs35l41_hda_config[] = {
-	{ CS35L41_PLL_CLK_CTRL,		0x00000430 }, // 3072000Hz, BCLK Input, PLL_REFCLK_EN = 1
-	{ CS35L41_DSP_CLK_CTRL,		0x00000003 }, // DSP CLK EN
-	{ CS35L41_GLOBAL_CLK_CTRL,	0x00000003 }, // GLOBAL_FS = 48 kHz
-	{ CS35L41_SP_ENABLES,		0x00010000 }, // ASP_RX1_EN = 1
-	{ CS35L41_SP_RATE_CTRL,		0x00000021 }, // ASP_BCLK_FREQ = 3.072 MHz
-	{ CS35L41_SP_FORMAT,		0x20200200 }, // 32 bits RX/TX slots, I2S, clk consumer
-	{ CS35L41_SP_HIZ_CTRL,		0x00000002 }, // Hi-Z unused
-	{ CS35L41_SP_TX_WL,		0x00000018 }, // 24 cycles/slot
-	{ CS35L41_SP_RX_WL,		0x00000018 }, // 24 cycles/slot
-	{ CS35L41_DAC_PCM1_SRC,		0x00000008 }, // DACPCM1_SRC = ASPRX1
-	{ CS35L41_ASP_TX1_SRC,		0x00000018 }, // ASPTX1 SRC = VMON
-	{ CS35L41_ASP_TX2_SRC,		0x00000019 }, // ASPTX2 SRC = IMON
-	{ CS35L41_ASP_TX3_SRC,		0x00000032 }, // ASPTX3 SRC = ERRVOL
-	{ CS35L41_ASP_TX4_SRC,		0x00000033 }, // ASPTX4 SRC = CLASSH_TGT
-	{ CS35L41_DSP1_RX1_SRC,		0x00000008 }, // DSP1RX1 SRC = ASPRX1
-	{ CS35L41_DSP1_RX2_SRC,		0x00000009 }, // DSP1RX2 SRC = ASPRX2
-	{ CS35L41_DSP1_RX3_SRC,         0x00000018 }, // DSP1RX3 SRC = VMON
-	{ CS35L41_DSP1_RX4_SRC,         0x00000019 }, // DSP1RX4 SRC = IMON
-	{ CS35L41_DSP1_RX5_SRC,         0x00000020 }, // DSP1RX5 SRC = ERRVOL
-	{ CS35L41_AMP_DIG_VOL_CTRL,	0x00000000 }, // AMP_VOL_PCM  0.0 dB
-	{ CS35L41_AMP_GAIN_CTRL,	0x00000084 }, // AMP_GAIN_PCM 4.5 dB
-};
-
-static const struct reg_sequence cs35l41_hda_config_dsp[] = {
-	{ CS35L41_PLL_CLK_CTRL,		0x00000430 }, // 3072000Hz, BCLK Input, PLL_REFCLK_EN = 1
-	{ CS35L41_DSP_CLK_CTRL,		0x00000003 }, // DSP CLK EN
-	{ CS35L41_GLOBAL_CLK_CTRL,	0x00000003 }, // GLOBAL_FS = 48 kHz
-	{ CS35L41_SP_ENABLES,		0x00010001 }, // ASP_RX1_EN = 1, ASP_TX1_EN = 1
-	{ CS35L41_SP_RATE_CTRL,		0x00000021 }, // ASP_BCLK_FREQ = 3.072 MHz
-	{ CS35L41_SP_FORMAT,		0x20200200 }, // 32 bits RX/TX slots, I2S, clk consumer
-	{ CS35L41_SP_HIZ_CTRL,		0x00000003 }, // Hi-Z unused/disabled
-	{ CS35L41_SP_TX_WL,		0x00000018 }, // 24 cycles/slot
-	{ CS35L41_SP_RX_WL,		0x00000018 }, // 24 cycles/slot
-	{ CS35L41_DAC_PCM1_SRC,		0x00000032 }, // DACPCM1_SRC = ERR_VOL
-	{ CS35L41_ASP_TX1_SRC,		0x00000018 }, // ASPTX1 SRC = VMON
-	{ CS35L41_ASP_TX2_SRC,		0x00000019 }, // ASPTX2 SRC = IMON
-	{ CS35L41_ASP_TX3_SRC,		0x00000028 }, // ASPTX3 SRC = VPMON
-	{ CS35L41_ASP_TX4_SRC,		0x00000029 }, // ASPTX4 SRC = VBSTMON
-	{ CS35L41_DSP1_RX1_SRC,		0x00000008 }, // DSP1RX1 SRC = ASPRX1
-	{ CS35L41_DSP1_RX2_SRC,		0x00000008 }, // DSP1RX2 SRC = ASPRX1
-	{ CS35L41_DSP1_RX3_SRC,         0x00000018 }, // DSP1RX3 SRC = VMON
-	{ CS35L41_DSP1_RX4_SRC,         0x00000019 }, // DSP1RX4 SRC = IMON
-	{ CS35L41_DSP1_RX5_SRC,         0x00000029 }, // DSP1RX5 SRC = VBSTMON
-	{ CS35L41_AMP_DIG_VOL_CTRL,	0x00000000 }, // AMP_VOL_PCM  0.0 dB
-	{ CS35L41_AMP_GAIN_CTRL,	0x00000233 }, // AMP_GAIN_PCM = 17.5dB AMP_GAIN_PDM = 19.5dB
-};
-
-static const struct reg_sequence cs35l41_hda_mute[] = {
-	{ CS35L41_AMP_GAIN_CTRL,	0x00000000 }, // AMP_GAIN_PCM 0.5 dB
-	{ CS35L41_AMP_DIG_VOL_CTRL,	0x0000A678 }, // AMP_VOL_PCM Mute
-};
-
-static int cs35l41_control_add(struct cs_dsp_coeff_ctl *cs_ctl)
-{
-	struct cs35l41_hda *cs35l41 = container_of(cs_ctl->dsp, struct cs35l41_hda, cs_dsp);
-	struct hda_cs_dsp_ctl_info info;
-
-	info.device_name = cs35l41->amp_name;
-	info.fw_type = cs35l41->firmware_type;
-	info.card = cs35l41->codec->card;
-
-	return hda_cs_dsp_control_add(cs_ctl, &info);
-}
-
-static const struct cs_dsp_client_ops client_ops = {
-	.control_add = cs35l41_control_add,
-	.control_remove = hda_cs_dsp_control_remove,
-};
-
-static int cs35l41_request_firmware_file(struct cs35l41_hda *cs35l41,
-					 const struct firmware **firmware, char **filename,
-					 const char *dir, const char *ssid, const char *amp_name,
-					 int spkid, const char *filetype)
-{
-	const char * const dsp_name = cs35l41->cs_dsp.name;
-	char *s, c;
-	int ret = 0;
-
-	if (spkid > -1 && ssid && amp_name)
-		*filename = kasprintf(GFP_KERNEL, "%s%s-%s-%s-%s-spkid%d-%s.%s", dir, CS35L41_PART,
-				      dsp_name, hda_cs_dsp_fw_ids[cs35l41->firmware_type],
-				      ssid, spkid, amp_name, filetype);
-	else if (spkid > -1 && ssid)
-		*filename = kasprintf(GFP_KERNEL, "%s%s-%s-%s-%s-spkid%d.%s", dir, CS35L41_PART,
-				      dsp_name, hda_cs_dsp_fw_ids[cs35l41->firmware_type],
-				      ssid, spkid, filetype);
-	else if (ssid && amp_name)
-		*filename = kasprintf(GFP_KERNEL, "%s%s-%s-%s-%s-%s.%s", dir, CS35L41_PART,
-				      dsp_name, hda_cs_dsp_fw_ids[cs35l41->firmware_type],
-				      ssid, amp_name, filetype);
-	else if (ssid)
-		*filename = kasprintf(GFP_KERNEL, "%s%s-%s-%s-%s.%s", dir, CS35L41_PART,
-				      dsp_name, hda_cs_dsp_fw_ids[cs35l41->firmware_type],
-				      ssid, filetype);
-	else
-		*filename = kasprintf(GFP_KERNEL, "%s%s-%s-%s.%s", dir, CS35L41_PART,
-				      dsp_name, hda_cs_dsp_fw_ids[cs35l41->firmware_type],
-				      filetype);
-
-	if (*filename == NULL)
-		return -ENOMEM;
-
-	/*
-	 * Make sure that filename is lower-case and any non alpha-numeric
-	 * characters except full stop and '/' are replaced with hyphens.
-	 */
-	s = *filename;
-	while (*s) {
-		c = *s;
-		if (isalnum(c))
-			*s = tolower(c);
-		else if (c != '.' && c != '/')
-			*s = '-';
-		s++;
-	}
-
-	ret = firmware_request_nowarn(firmware, *filename, cs35l41->dev);
-	if (ret != 0) {
-		dev_dbg(cs35l41->dev, "Failed to request '%s'\n", *filename);
-		kfree(*filename);
-		*filename = NULL;
-	}
-
-	return ret;
-}
-
-static int cs35l41_request_firmware_files_spkid(struct cs35l41_hda *cs35l41,
-						const struct firmware **wmfw_firmware,
-						char **wmfw_filename,
-						const struct firmware **coeff_firmware,
-						char **coeff_filename)
-{
-	int ret;
-
-	/* try cirrus/part-dspN-fwtype-sub<-spkidN><-ampname>.wmfw */
-	ret = cs35l41_request_firmware_file(cs35l41, wmfw_firmware, wmfw_filename,
-					    CS35L41_FIRMWARE_ROOT,
-					    cs35l41->acpi_subsystem_id, cs35l41->amp_name,
-					    cs35l41->speaker_id, "wmfw");
-	if (!ret) {
-		/* try cirrus/part-dspN-fwtype-sub<-spkidN><-ampname>.bin */
-		cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,
-					      CS35L41_FIRMWARE_ROOT,
-					      cs35l41->acpi_subsystem_id, cs35l41->amp_name,
-					      cs35l41->speaker_id, "bin");
-		return 0;
-	}
-
-	/* try cirrus/part-dspN-fwtype-sub<-ampname>.wmfw */
-	ret = cs35l41_request_firmware_file(cs35l41, wmfw_firmware, wmfw_filename,
-					    CS35L41_FIRMWARE_ROOT, cs35l41->acpi_subsystem_id,
-					    cs35l41->amp_name, -1, "wmfw");
-	if (!ret) {
-		/* try cirrus/part-dspN-fwtype-sub<-spkidN><-ampname>.bin */
-		cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,
-					      CS35L41_FIRMWARE_ROOT, cs35l41->acpi_subsystem_id,
-					      cs35l41->amp_name, cs35l41->speaker_id, "bin");
-		return 0;
-	}
-
-	/* try cirrus/part-dspN-fwtype-sub<-spkidN>.wmfw */
-	ret = cs35l41_request_firmware_file(cs35l41, wmfw_firmware, wmfw_filename,
-					    CS35L41_FIRMWARE_ROOT, cs35l41->acpi_subsystem_id,
-					    NULL, cs35l41->speaker_id, "wmfw");
-	if (!ret) {
-		/* try cirrus/part-dspN-fwtype-sub<-spkidN><-ampname>.bin */
-		ret = cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,
-						    CS35L41_FIRMWARE_ROOT,
-						    cs35l41->acpi_subsystem_id,
-						    cs35l41->amp_name, cs35l41->speaker_id, "bin");
-		if (ret)
-			/* try cirrus/part-dspN-fwtype-sub<-spkidN>.bin */
-			cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,
-						CS35L41_FIRMWARE_ROOT,
-						cs35l41->acpi_subsystem_id,
-						NULL, cs35l41->speaker_id, "bin");
-		return 0;
-	}
-
-	/* try cirrus/part-dspN-fwtype-sub.wmfw */
-	ret = cs35l41_request_firmware_file(cs35l41, wmfw_firmware, wmfw_filename,
-					    CS35L41_FIRMWARE_ROOT, cs35l41->acpi_subsystem_id,
-					    NULL, -1, "wmfw");
-	if (!ret) {
-		/* try cirrus/part-dspN-fwtype-sub<-spkidN><-ampname>.bin */
-		ret = cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,
-						    CS35L41_FIRMWARE_ROOT,
-						    cs35l41->acpi_subsystem_id,
-						    cs35l41->amp_name, cs35l41->speaker_id, "bin");
-		if (ret)
-			/* try cirrus/part-dspN-fwtype-sub<-spkidN>.bin */
-			cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,
-						      CS35L41_FIRMWARE_ROOT,
-						      cs35l41->acpi_subsystem_id,
-						      NULL, cs35l41->speaker_id, "bin");
-		return 0;
-	}
-
-	/* fallback try cirrus/part-dspN-fwtype.wmfw */
-	ret = cs35l41_request_firmware_file(cs35l41, wmfw_firmware, wmfw_filename,
-					    CS35L41_FIRMWARE_ROOT, NULL, NULL, -1, "wmfw");
-	if (!ret) {
-		/* fallback try cirrus/part-dspN-fwtype.bin */
-		cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,
-					      CS35L41_FIRMWARE_ROOT, NULL, NULL, -1, "bin");
-		return 0;
-	}
-
-	dev_warn(cs35l41->dev, "Failed to request firmware\n");
-
-	return ret;
-}
-
-static int cs35l41_request_firmware_files(struct cs35l41_hda *cs35l41,
-					  const struct firmware **wmfw_firmware,
-					  char **wmfw_filename,
-					  const struct firmware **coeff_firmware,
-					  char **coeff_filename)
-{
-	int ret;
-
-	if (cs35l41->speaker_id > -1)
-		return cs35l41_request_firmware_files_spkid(cs35l41, wmfw_firmware, wmfw_filename,
-							    coeff_firmware, coeff_filename);
-
-	/* try cirrus/part-dspN-fwtype-sub<-ampname>.wmfw */
-	ret = cs35l41_request_firmware_file(cs35l41, wmfw_firmware, wmfw_filename,
-					    CS35L41_FIRMWARE_ROOT, cs35l41->acpi_subsystem_id,
-					    cs35l41->amp_name, -1, "wmfw");
-	if (!ret) {
-		/* try cirrus/part-dspN-fwtype-sub<-ampname>.bin */
-		cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,
-					      CS35L41_FIRMWARE_ROOT, cs35l41->acpi_subsystem_id,
-					      cs35l41->amp_name, -1, "bin");
-		return 0;
-	}
-
-	/* try cirrus/part-dspN-fwtype-sub.wmfw */
-	ret = cs35l41_request_firmware_file(cs35l41, wmfw_firmware, wmfw_filename,
-					    CS35L41_FIRMWARE_ROOT, cs35l41->acpi_subsystem_id,
-					    NULL, -1, "wmfw");
-	if (!ret) {
-		/* try cirrus/part-dspN-fwtype-sub<-ampname>.bin */
-		ret = cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,
-						    CS35L41_FIRMWARE_ROOT,
-						    cs35l41->acpi_subsystem_id,
-						    cs35l41->amp_name, -1, "bin");
-		if (ret)
-			/* try cirrus/part-dspN-fwtype-sub.bin */
-			cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,
-						      CS35L41_FIRMWARE_ROOT,
-						      cs35l41->acpi_subsystem_id,
-						      NULL, -1, "bin");
-		return 0;
-	}
-
-	/* fallback try cirrus/part-dspN-fwtype.wmfw */
-	ret = cs35l41_request_firmware_file(cs35l41, wmfw_firmware, wmfw_filename,
-					    CS35L41_FIRMWARE_ROOT, NULL, NULL, -1, "wmfw");
-	if (!ret) {
-		/* fallback try cirrus/part-dspN-fwtype.bin */
-		cs35l41_request_firmware_file(cs35l41, coeff_firmware, coeff_filename,
-					      CS35L41_FIRMWARE_ROOT, NULL, NULL, -1, "bin");
-		return 0;
-	}
-
-	dev_warn(cs35l41->dev, "Failed to request firmware\n");
-
-	return ret;
-}
-
-#if IS_ENABLED(CONFIG_EFI)
-static int cs35l41_apply_calibration(struct cs35l41_hda *cs35l41, unsigned int ambient,
-				     unsigned int r0, unsigned int status, unsigned int checksum)
-{
-	int ret;
-
-	ret = hda_cs_dsp_write_ctl(&cs35l41->cs_dsp, CAL_AMBIENT_DSP_CTL_NAME, CAL_DSP_CTL_TYPE,
-				   CAL_DSP_CTL_ALG, &ambient, 4);
-	if (ret) {
-		dev_err(cs35l41->dev, "Cannot Write Control: %s - %d\n", CAL_AMBIENT_DSP_CTL_NAME,
-			ret);
-		return ret;
-	}
-	ret = hda_cs_dsp_write_ctl(&cs35l41->cs_dsp, CAL_R_DSP_CTL_NAME, CAL_DSP_CTL_TYPE,
-				   CAL_DSP_CTL_ALG, &r0, 4);
-	if (ret) {
-		dev_err(cs35l41->dev, "Cannot Write Control: %s - %d\n", CAL_R_DSP_CTL_NAME, ret);
-		return ret;
-	}
-	ret = hda_cs_dsp_write_ctl(&cs35l41->cs_dsp, CAL_STATUS_DSP_CTL_NAME, CAL_DSP_CTL_TYPE,
-				   CAL_DSP_CTL_ALG, &status, 4);
-	if (ret) {
-		dev_err(cs35l41->dev, "Cannot Write Control: %s - %d\n", CAL_STATUS_DSP_CTL_NAME,
-			ret);
-		return ret;
-	}
-	ret = hda_cs_dsp_write_ctl(&cs35l41->cs_dsp, CAL_CHECKSUM_DSP_CTL_NAME, CAL_DSP_CTL_TYPE,
-				   CAL_DSP_CTL_ALG, &checksum, 4);
-	if (ret) {
-		dev_err(cs35l41->dev, "Cannot Write Control: %s - %d\n", CAL_CHECKSUM_DSP_CTL_NAME,
-			ret);
-		return ret;
-	}
-
-	return 0;
-}
-
-static int cs35l41_save_calibration(struct cs35l41_hda *cs35l41)
-{
-	static efi_guid_t efi_guid = EFI_GUID(0x02f9af02, 0x7734, 0x4233, 0xb4, 0x3d, 0x93, 0xfe,
-					      0x5a, 0xa3, 0x5d, 0xb3);
-	static efi_char16_t efi_name[] = L"CirrusSmartAmpCalibrationData";
-	const struct cs35l41_amp_efi_data *efi_data;
-	const struct cs35l41_amp_cal_data *cl;
-	unsigned long data_size = 0;
-	efi_status_t status;
-	int ret = 0;
-	u8 *data = NULL;
-	u32 attr;
-
-	/* Get real size of UEFI variable */
-	status = efi.get_variable(efi_name, &efi_guid, &attr, &data_size, data);
-	if (status == EFI_BUFFER_TOO_SMALL) {
-		ret = -ENODEV;
-		/* Allocate data buffer of data_size bytes */
-		data = vmalloc(data_size);
-		if (!data)
-			return -ENOMEM;
-		/* Get variable contents into buffer */
-		status = efi.get_variable(efi_name, &efi_guid, &attr, &data_size, data);
-		if (status == EFI_SUCCESS) {
-			efi_data = (struct cs35l41_amp_efi_data *)data;
-			dev_dbg(cs35l41->dev, "Calibration: Size=%d, Amp Count=%d\n",
-				efi_data->size, efi_data->count);
-			if (efi_data->count > cs35l41->index) {
-				cl = &efi_data->data[cs35l41->index];
-				dev_dbg(cs35l41->dev,
-					"Calibration: Ambient=%02x, Status=%02x, R0=%d\n",
-					cl->calAmbient, cl->calStatus, cl->calR);
-
-				/* Calibration can only be applied whilst the DSP is not running */
-				ret = cs35l41_apply_calibration(cs35l41,
-								cpu_to_be32(cl->calAmbient),
-								cpu_to_be32(cl->calR),
-								cpu_to_be32(cl->calStatus),
-								cpu_to_be32(cl->calR + 1));
-			}
-		}
-		vfree(data);
-	}
-	return ret;
-}
-#else
-static int cs35l41_save_calibration(struct cs35l41_hda *cs35l41)
-{
-	dev_warn(cs35l41->dev, "Calibration not supported without EFI support.\n");
-	return 0;
-}
-#endif
-
-static int cs35l41_init_dsp(struct cs35l41_hda *cs35l41)
-{
-	const struct firmware *coeff_firmware = NULL;
-	const struct firmware *wmfw_firmware = NULL;
-	struct cs_dsp *dsp = &cs35l41->cs_dsp;
-	char *coeff_filename = NULL;
-	char *wmfw_filename = NULL;
-	int ret;
-
-	if (!cs35l41->halo_initialized) {
-		cs35l41_configure_cs_dsp(cs35l41->dev, cs35l41->regmap, dsp);
-		dsp->client_ops = &client_ops;
-
-		ret = cs_dsp_halo_init(&cs35l41->cs_dsp);
-		if (ret)
-			return ret;
-		cs35l41->halo_initialized = true;
-	}
-
-	ret = cs35l41_request_firmware_files(cs35l41, &wmfw_firmware, &wmfw_filename,
-					     &coeff_firmware, &coeff_filename);
-	if (ret < 0)
-		return ret;
-
-	dev_dbg(cs35l41->dev, "Loading WMFW Firmware: %s\n", wmfw_filename);
-	if (coeff_filename)
-		dev_dbg(cs35l41->dev, "Loading Coefficient File: %s\n", coeff_filename);
-	else
-		dev_warn(cs35l41->dev, "No Coefficient File available.\n");
-
-	ret = cs_dsp_power_up(dsp, wmfw_firmware, wmfw_filename, coeff_firmware, coeff_filename,
-			      hda_cs_dsp_fw_ids[cs35l41->firmware_type]);
-	if (ret)
-		goto err_release;
-
-	ret = cs35l41_save_calibration(cs35l41);
-
-err_release:
-	release_firmware(wmfw_firmware);
-	release_firmware(coeff_firmware);
-	kfree(wmfw_filename);
-	kfree(coeff_filename);
-
-	return ret;
-}
-
-static void cs35l41_shutdown_dsp(struct cs35l41_hda *cs35l41)
-{
-	struct cs_dsp *dsp = &cs35l41->cs_dsp;
-
-	cs_dsp_stop(dsp);
-	cs_dsp_power_down(dsp);
-	cs35l41->firmware_running = false;
-	dev_dbg(cs35l41->dev, "Unloaded Firmware\n");
-}
-
-static void cs35l41_remove_dsp(struct cs35l41_hda *cs35l41)
-{
-	struct cs_dsp *dsp = &cs35l41->cs_dsp;
-
-	cancel_work_sync(&cs35l41->fw_load_work);
-	cs35l41_shutdown_dsp(cs35l41);
-	cs_dsp_remove(dsp);
-	cs35l41->halo_initialized = false;
-}
-
-/* Protection release cycle to get the speaker out of Safe-Mode */
-static void cs35l41_error_release(struct device *dev, struct regmap *regmap, unsigned int mask)
-{
-	regmap_write(regmap, CS35L41_PROTECT_REL_ERR_IGN, 0);
-	regmap_set_bits(regmap, CS35L41_PROTECT_REL_ERR_IGN, mask);
-	regmap_clear_bits(regmap, CS35L41_PROTECT_REL_ERR_IGN, mask);
-}
-
-/* Clear all errors to release safe mode. Global Enable must be cleared first. */
-static void cs35l41_irq_release(struct cs35l41_hda *cs35l41)
-{
-	cs35l41_error_release(cs35l41->dev, cs35l41->regmap, cs35l41->irq_errors);
-	cs35l41->irq_errors = 0;
-}
-
-static void cs35l41_hda_playback_hook(struct device *dev, int action)
-{
-	struct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);
-	struct regmap *reg = cs35l41->regmap;
-	int ret = 0;
-
-	mutex_lock(&cs35l41->fw_mutex);
-
-	switch (action) {
-	case HDA_GEN_PCM_ACT_OPEN:
-		cs35l41->playback_started = true;
-		if (cs35l41->firmware_running) {
-			regmap_multi_reg_write(reg, cs35l41_hda_config_dsp,
-					       ARRAY_SIZE(cs35l41_hda_config_dsp));
-			regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL2,
-					   CS35L41_VMON_EN_MASK | CS35L41_IMON_EN_MASK,
-					   1 << CS35L41_VMON_EN_SHIFT | 1 << CS35L41_IMON_EN_SHIFT);
-			cs35l41_set_cspl_mbox_cmd(cs35l41->dev, cs35l41->regmap,
-						  CSPL_MBOX_CMD_RESUME);
-		} else {
-			regmap_multi_reg_write(reg, cs35l41_hda_config,
-					       ARRAY_SIZE(cs35l41_hda_config));
-		}
-		ret = regmap_update_bits(reg, CS35L41_PWR_CTRL2,
-					 CS35L41_AMP_EN_MASK, 1 << CS35L41_AMP_EN_SHIFT);
-		if (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST)
-			regmap_write(reg, CS35L41_GPIO1_CTRL1, 0x00008001);
-		break;
-	case HDA_GEN_PCM_ACT_PREPARE:
-		ret = cs35l41_global_enable(reg, cs35l41->hw_cfg.bst_type, 1);
-		break;
-	case HDA_GEN_PCM_ACT_CLEANUP:
-		regmap_multi_reg_write(reg, cs35l41_hda_mute, ARRAY_SIZE(cs35l41_hda_mute));
-		ret = cs35l41_global_enable(reg, cs35l41->hw_cfg.bst_type, 0);
-		break;
-	case HDA_GEN_PCM_ACT_CLOSE:
-		ret = regmap_update_bits(reg, CS35L41_PWR_CTRL2,
-					 CS35L41_AMP_EN_MASK, 0 << CS35L41_AMP_EN_SHIFT);
-		if (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST)
-			regmap_write(reg, CS35L41_GPIO1_CTRL1, 0x00000001);
-		if (cs35l41->firmware_running) {
-			cs35l41_set_cspl_mbox_cmd(cs35l41->dev, cs35l41->regmap,
-						  CSPL_MBOX_CMD_PAUSE);
-			regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL2,
-					   CS35L41_VMON_EN_MASK | CS35L41_IMON_EN_MASK,
-					   0 << CS35L41_VMON_EN_SHIFT | 0 << CS35L41_IMON_EN_SHIFT);
-		}
-		cs35l41_irq_release(cs35l41);
-		cs35l41->playback_started = false;
-		break;
-	default:
-		dev_warn(cs35l41->dev, "Playback action not supported: %d\n", action);
-		break;
-	}
-
-	mutex_unlock(&cs35l41->fw_mutex);
-
-	if (ret)
-		dev_err(cs35l41->dev, "Regmap access fail: %d\n", ret);
-}
-
-static int cs35l41_hda_channel_map(struct device *dev, unsigned int tx_num, unsigned int *tx_slot,
-				    unsigned int rx_num, unsigned int *rx_slot)
-{
-	struct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);
-	static const char * const channel_name[] = { "L", "R" };
-
-	if (!cs35l41->amp_name) {
-		if (*rx_slot >= ARRAY_SIZE(channel_name))
-			return -EINVAL;
-
-		cs35l41->amp_name = devm_kasprintf(cs35l41->dev, GFP_KERNEL, "%s%d",
-						   channel_name[*rx_slot], cs35l41->channel_index);
-		if (!cs35l41->amp_name)
-			return -ENOMEM;
-	}
-
-	return cs35l41_set_channels(cs35l41->dev, cs35l41->regmap, tx_num, tx_slot, rx_num,
-				    rx_slot);
-}
-
-static int cs35l41_runtime_suspend(struct device *dev)
-{
-	struct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);
-
-	dev_dbg(cs35l41->dev, "Suspend\n");
-
-	if (!cs35l41->firmware_running)
-		return 0;
-
-	if (cs35l41_enter_hibernate(cs35l41->dev, cs35l41->regmap, cs35l41->hw_cfg.bst_type) < 0)
-		return 0;
-
-	regcache_cache_only(cs35l41->regmap, true);
-	regcache_mark_dirty(cs35l41->regmap);
-
-	return 0;
-}
-
-static int cs35l41_runtime_resume(struct device *dev)
-{
-	struct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);
-	int ret;
-
-	dev_dbg(cs35l41->dev, "Resume.\n");
-
-	if (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST_NO_VSPK_SWITCH) {
-		dev_dbg(cs35l41->dev, "System does not support Resume\n");
-		return 0;
-	}
-
-	if (!cs35l41->firmware_running)
-		return 0;
-
-	regcache_cache_only(cs35l41->regmap, false);
-
-	ret = cs35l41_exit_hibernate(cs35l41->dev, cs35l41->regmap);
-	if (ret) {
-		regcache_cache_only(cs35l41->regmap, true);
-		return ret;
-	}
-
-	/* Test key needs to be unlocked to allow the OTP settings to re-apply */
-	cs35l41_test_key_unlock(cs35l41->dev, cs35l41->regmap);
-	ret = regcache_sync(cs35l41->regmap);
-	cs35l41_test_key_lock(cs35l41->dev, cs35l41->regmap);
-	if (ret) {
-		dev_err(cs35l41->dev, "Failed to restore register cache: %d\n", ret);
-		return ret;
-	}
-
-	if (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST)
-		cs35l41_init_boost(cs35l41->dev, cs35l41->regmap, &cs35l41->hw_cfg);
-
-	return 0;
-}
-
-static int cs35l41_hda_suspend_hook(struct device *dev)
-{
-	dev_dbg(dev, "Request Suspend\n");
-	pm_runtime_mark_last_busy(dev);
-	return pm_runtime_put_autosuspend(dev);
-}
-
-static int cs35l41_hda_resume_hook(struct device *dev)
-{
-	dev_dbg(dev, "Request Resume\n");
-	return pm_runtime_get_sync(dev);
-}
-
-static int cs35l41_smart_amp(struct cs35l41_hda *cs35l41)
-{
-	int halo_sts;
-	int ret;
-
-	ret = cs35l41_init_dsp(cs35l41);
-	if (ret) {
-		dev_warn(cs35l41->dev, "Cannot Initialize Firmware. Error: %d\n", ret);
-		goto clean_dsp;
-	}
-
-	ret = cs35l41_write_fs_errata(cs35l41->dev, cs35l41->regmap);
-	if (ret) {
-		dev_err(cs35l41->dev, "Cannot Write FS Errata: %d\n", ret);
-		goto clean_dsp;
-	}
-
-	ret = cs_dsp_run(&cs35l41->cs_dsp);
-	if (ret) {
-		dev_err(cs35l41->dev, "Fail to start dsp: %d\n", ret);
-		goto clean_dsp;
-	}
-
-	ret = read_poll_timeout(hda_cs_dsp_read_ctl, ret,
-				be32_to_cpu(halo_sts) == HALO_STATE_CODE_RUN,
-				1000, 15000, false, &cs35l41->cs_dsp, HALO_STATE_DSP_CTL_NAME,
-				HALO_STATE_DSP_CTL_TYPE, HALO_STATE_DSP_CTL_ALG,
-				&halo_sts, sizeof(halo_sts));
-
-	if (ret) {
-		dev_err(cs35l41->dev, "Timeout waiting for HALO Core to start. State: %d\n",
-			 halo_sts);
-		goto clean_dsp;
-	}
-
-	cs35l41_set_cspl_mbox_cmd(cs35l41->dev, cs35l41->regmap, CSPL_MBOX_CMD_PAUSE);
-	cs35l41->firmware_running = true;
-
-	return 0;
-
-clean_dsp:
-	cs35l41_shutdown_dsp(cs35l41);
-	return ret;
-}
-
-static void cs35l41_load_firmware(struct cs35l41_hda *cs35l41, bool load)
-{
-	pm_runtime_get_sync(cs35l41->dev);
-
-	if (cs35l41->firmware_running && !load) {
-		dev_dbg(cs35l41->dev, "Unloading Firmware\n");
-		cs35l41_shutdown_dsp(cs35l41);
-	} else if (!cs35l41->firmware_running && load) {
-		dev_dbg(cs35l41->dev, "Loading Firmware\n");
-		cs35l41_smart_amp(cs35l41);
-	} else {
-		dev_dbg(cs35l41->dev, "Unable to Load firmware.\n");
-	}
-
-	pm_runtime_mark_last_busy(cs35l41->dev);
-	pm_runtime_put_autosuspend(cs35l41->dev);
-}
-
-static int cs35l41_fw_load_ctl_get(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_value *ucontrol)
-{
-	struct cs35l41_hda *cs35l41 = snd_kcontrol_chip(kcontrol);
-
-	ucontrol->value.integer.value[0] = cs35l41->request_fw_load;
-	return 0;
-}
-
-static void cs35l41_fw_load_work(struct work_struct *work)
-{
-	struct cs35l41_hda *cs35l41 = container_of(work, struct cs35l41_hda, fw_load_work);
-
-	mutex_lock(&cs35l41->fw_mutex);
-
-	/* Recheck if playback is ongoing, mutex will block playback during firmware loading */
-	if (cs35l41->playback_started)
-		dev_err(cs35l41->dev, "Cannot Load/Unload firmware during Playback\n");
-	else
-		cs35l41_load_firmware(cs35l41, cs35l41->request_fw_load);
-
-	cs35l41->fw_request_ongoing = false;
-	mutex_unlock(&cs35l41->fw_mutex);
-}
-
-static int cs35l41_fw_load_ctl_put(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_value *ucontrol)
-{
-	struct cs35l41_hda *cs35l41 = snd_kcontrol_chip(kcontrol);
-	unsigned int ret = 0;
-
-	mutex_lock(&cs35l41->fw_mutex);
-
-	if (cs35l41->request_fw_load == ucontrol->value.integer.value[0])
-		goto err;
-
-	if (cs35l41->fw_request_ongoing) {
-		dev_dbg(cs35l41->dev, "Existing request not complete\n");
-		ret = -EBUSY;
-		goto err;
-	}
-
-	/* Check if playback is ongoing when initial request is made */
-	if (cs35l41->playback_started) {
-		dev_err(cs35l41->dev, "Cannot Load/Unload firmware during Playback\n");
-		ret = -EBUSY;
-		goto err;
-	}
-
-	cs35l41->fw_request_ongoing = true;
-	cs35l41->request_fw_load = ucontrol->value.integer.value[0];
-	schedule_work(&cs35l41->fw_load_work);
-
-err:
-	mutex_unlock(&cs35l41->fw_mutex);
-
-	return ret;
-}
-
-static int cs35l41_fw_type_ctl_get(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_value *ucontrol)
-{
-	struct cs35l41_hda *cs35l41 = snd_kcontrol_chip(kcontrol);
-
-	ucontrol->value.enumerated.item[0] = cs35l41->firmware_type;
-
-	return 0;
-}
-
-static int cs35l41_fw_type_ctl_put(struct snd_kcontrol *kcontrol,
-				   struct snd_ctl_elem_value *ucontrol)
-{
-	struct cs35l41_hda *cs35l41 = snd_kcontrol_chip(kcontrol);
-
-	if (ucontrol->value.enumerated.item[0] < HDA_CS_DSP_NUM_FW) {
-		cs35l41->firmware_type = ucontrol->value.enumerated.item[0];
-		return 0;
-	}
-
-	return -EINVAL;
-}
-
-static int cs35l41_fw_type_ctl_info(struct snd_kcontrol *kcontrol, struct snd_ctl_elem_info *uinfo)
-{
-	return snd_ctl_enum_info(uinfo, 1, ARRAY_SIZE(hda_cs_dsp_fw_ids), hda_cs_dsp_fw_ids);
-}
-
-static int cs35l41_create_controls(struct cs35l41_hda *cs35l41)
-{
-	char fw_type_ctl_name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
-	char fw_load_ctl_name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
-	struct snd_kcontrol_new fw_type_ctl = {
-		.name = fw_type_ctl_name,
-		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
-		.info = cs35l41_fw_type_ctl_info,
-		.get = cs35l41_fw_type_ctl_get,
-		.put = cs35l41_fw_type_ctl_put,
-	};
-	struct snd_kcontrol_new fw_load_ctl = {
-		.name = fw_load_ctl_name,
-		.iface = SNDRV_CTL_ELEM_IFACE_CARD,
-		.info = snd_ctl_boolean_mono_info,
-		.get = cs35l41_fw_load_ctl_get,
-		.put = cs35l41_fw_load_ctl_put,
-	};
-	int ret;
-
-	scnprintf(fw_type_ctl_name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, "%s DSP1 Firmware Type",
-		  cs35l41->amp_name);
-	scnprintf(fw_load_ctl_name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, "%s DSP1 Firmware Load",
-		  cs35l41->amp_name);
-
-	ret = snd_ctl_add(cs35l41->codec->card, snd_ctl_new1(&fw_type_ctl, cs35l41));
-	if (ret) {
-		dev_err(cs35l41->dev, "Failed to add KControl %s = %d\n", fw_type_ctl.name, ret);
-		return ret;
-	}
-
-	dev_dbg(cs35l41->dev, "Added Control %s\n", fw_type_ctl.name);
-
-	ret = snd_ctl_add(cs35l41->codec->card, snd_ctl_new1(&fw_load_ctl, cs35l41));
-	if (ret) {
-		dev_err(cs35l41->dev, "Failed to add KControl %s = %d\n", fw_load_ctl.name, ret);
-		return ret;
-	}
-
-	dev_dbg(cs35l41->dev, "Added Control %s\n", fw_load_ctl.name);
-
-	return 0;
-}
-
-static int cs35l41_hda_bind(struct device *dev, struct device *master, void *master_data)
-{
-	struct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);
-	struct hda_component *comps = master_data;
-	int ret = 0;
-
-	if (!comps || cs35l41->index < 0 || cs35l41->index >= HDA_MAX_COMPONENTS)
-		return -EINVAL;
-
-	comps = &comps[cs35l41->index];
-	if (comps->dev)
-		return -EBUSY;
-
-	pm_runtime_get_sync(dev);
-
-	comps->dev = dev;
-	if (!cs35l41->acpi_subsystem_id)
-		cs35l41->acpi_subsystem_id = devm_kasprintf(dev, GFP_KERNEL, "%.8x",
-							    comps->codec->core.subsystem_id);
-	cs35l41->codec = comps->codec;
-	strscpy(comps->name, dev_name(dev), sizeof(comps->name));
-
-	cs35l41->firmware_type = HDA_CS_DSP_FW_SPK_PROT;
-
-	if (firmware_autostart) {
-		dev_dbg(cs35l41->dev, "Firmware Autostart.\n");
-		cs35l41->request_fw_load = true;
-		mutex_lock(&cs35l41->fw_mutex);
-		if (cs35l41_smart_amp(cs35l41) < 0)
-			dev_warn(cs35l41->dev, "Cannot Run Firmware, reverting to dsp bypass...\n");
-		mutex_unlock(&cs35l41->fw_mutex);
-	} else {
-		dev_dbg(cs35l41->dev, "Firmware Autostart is disabled.\n");
-	}
-
-	ret = cs35l41_create_controls(cs35l41);
-
-	comps->playback_hook = cs35l41_hda_playback_hook;
-	comps->suspend_hook = cs35l41_hda_suspend_hook;
-	comps->resume_hook = cs35l41_hda_resume_hook;
-
-	pm_runtime_mark_last_busy(dev);
-	pm_runtime_put_autosuspend(dev);
-
-	return ret;
-}
-
-static void cs35l41_hda_unbind(struct device *dev, struct device *master, void *master_data)
-{
-	struct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);
-	struct hda_component *comps = master_data;
-
-	if (comps[cs35l41->index].dev == dev)
-		memset(&comps[cs35l41->index], 0, sizeof(*comps));
-}
-
-static const struct component_ops cs35l41_hda_comp_ops = {
-	.bind = cs35l41_hda_bind,
-	.unbind = cs35l41_hda_unbind,
-};
-
-static irqreturn_t cs35l41_bst_short_err(int irq, void *data)
-{
-	struct cs35l41_hda *cs35l41 = data;
-
-	dev_crit_ratelimited(cs35l41->dev, "LBST Error\n");
-	set_bit(CS35L41_BST_SHORT_ERR_RLS_SHIFT, &cs35l41->irq_errors);
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t cs35l41_bst_dcm_uvp_err(int irq, void *data)
-{
-	struct cs35l41_hda *cs35l41 = data;
-
-	dev_crit_ratelimited(cs35l41->dev, "DCM VBST Under Voltage Error\n");
-	set_bit(CS35L41_BST_UVP_ERR_RLS_SHIFT, &cs35l41->irq_errors);
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t cs35l41_bst_ovp_err(int irq, void *data)
-{
-	struct cs35l41_hda *cs35l41 = data;
-
-	dev_crit_ratelimited(cs35l41->dev, "VBST Over Voltage error\n");
-	set_bit(CS35L41_BST_OVP_ERR_RLS_SHIFT, &cs35l41->irq_errors);
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t cs35l41_temp_err(int irq, void *data)
-{
-	struct cs35l41_hda *cs35l41 = data;
-
-	dev_crit_ratelimited(cs35l41->dev, "Over temperature error\n");
-	set_bit(CS35L41_TEMP_ERR_RLS_SHIFT, &cs35l41->irq_errors);
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t cs35l41_temp_warn(int irq, void *data)
-{
-	struct cs35l41_hda *cs35l41 = data;
-
-	dev_crit_ratelimited(cs35l41->dev, "Over temperature warning\n");
-	set_bit(CS35L41_TEMP_WARN_ERR_RLS_SHIFT, &cs35l41->irq_errors);
-
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t cs35l41_amp_short(int irq, void *data)
-{
-	struct cs35l41_hda *cs35l41 = data;
-
-	dev_crit_ratelimited(cs35l41->dev, "Amp short error\n");
-	set_bit(CS35L41_AMP_SHORT_ERR_RLS_SHIFT, &cs35l41->irq_errors);
-
-	return IRQ_HANDLED;
-}
-
-static const struct cs35l41_irq cs35l41_irqs[] = {
-	CS35L41_IRQ(BST_OVP_ERR, "Boost Overvoltage Error", cs35l41_bst_ovp_err),
-	CS35L41_IRQ(BST_DCM_UVP_ERR, "Boost Undervoltage Error", cs35l41_bst_dcm_uvp_err),
-	CS35L41_IRQ(BST_SHORT_ERR, "Boost Inductor Short Error", cs35l41_bst_short_err),
-	CS35L41_IRQ(TEMP_WARN, "Temperature Warning", cs35l41_temp_warn),
-	CS35L41_IRQ(TEMP_ERR, "Temperature Error", cs35l41_temp_err),
-	CS35L41_IRQ(AMP_SHORT_ERR, "Amp Short", cs35l41_amp_short),
-};
-
-static const struct regmap_irq cs35l41_reg_irqs[] = {
-	CS35L41_REG_IRQ(IRQ1_STATUS1, BST_OVP_ERR),
-	CS35L41_REG_IRQ(IRQ1_STATUS1, BST_DCM_UVP_ERR),
-	CS35L41_REG_IRQ(IRQ1_STATUS1, BST_SHORT_ERR),
-	CS35L41_REG_IRQ(IRQ1_STATUS1, TEMP_WARN),
-	CS35L41_REG_IRQ(IRQ1_STATUS1, TEMP_ERR),
-	CS35L41_REG_IRQ(IRQ1_STATUS1, AMP_SHORT_ERR),
-};
-
-static struct regmap_irq_chip cs35l41_regmap_irq_chip = {
-	.name = "cs35l41 IRQ1 Controller",
-	.status_base = CS35L41_IRQ1_STATUS1,
-	.mask_base = CS35L41_IRQ1_MASK1,
-	.ack_base = CS35L41_IRQ1_STATUS1,
-	.num_regs = 4,
-	.irqs = cs35l41_reg_irqs,
-	.num_irqs = ARRAY_SIZE(cs35l41_reg_irqs),
-	.runtime_pm = true,
-};
-
-static int cs35l41_hda_apply_properties(struct cs35l41_hda *cs35l41)
-{
-	struct cs35l41_hw_cfg *hw_cfg = &cs35l41->hw_cfg;
-	bool using_irq = false;
-	int irq, irq_pol;
-	int ret;
-	int i;
-
-	if (!cs35l41->hw_cfg.valid)
-		return -EINVAL;
-
-	ret = cs35l41_init_boost(cs35l41->dev, cs35l41->regmap, hw_cfg);
-	if (ret)
-		return ret;
-
-	if (hw_cfg->gpio1.valid) {
-		switch (hw_cfg->gpio1.func) {
-		case CS35L41_NOT_USED:
-			break;
-		case CS35l41_VSPK_SWITCH:
-			hw_cfg->gpio1.func = CS35L41_GPIO1_GPIO;
-			hw_cfg->gpio1.out_en = true;
-			break;
-		case CS35l41_SYNC:
-			hw_cfg->gpio1.func = CS35L41_GPIO1_MDSYNC;
-			break;
-		default:
-			dev_err(cs35l41->dev, "Invalid function %d for GPIO1\n",
-				hw_cfg->gpio1.func);
-			return -EINVAL;
-		}
-	}
-
-	if (hw_cfg->gpio2.valid) {
-		switch (hw_cfg->gpio2.func) {
-		case CS35L41_NOT_USED:
-			break;
-		case CS35L41_INTERRUPT:
-			using_irq = true;
-			hw_cfg->gpio2.func = CS35L41_GPIO2_INT_OPEN_DRAIN;
-			break;
-		default:
-			dev_err(cs35l41->dev, "Invalid GPIO2 function %d\n", hw_cfg->gpio2.func);
-			return -EINVAL;
-		}
-	}
-
-	irq_pol = cs35l41_gpio_config(cs35l41->regmap, hw_cfg);
-
-	if (cs35l41->irq && using_irq) {
-		ret = devm_regmap_add_irq_chip(cs35l41->dev, cs35l41->regmap, cs35l41->irq,
-					       IRQF_ONESHOT | IRQF_SHARED | irq_pol,
-					       0, &cs35l41_regmap_irq_chip, &cs35l41->irq_data);
-		if (ret)
-			return ret;
-
-		for (i = 0; i < ARRAY_SIZE(cs35l41_irqs); i++) {
-			irq = regmap_irq_get_virq(cs35l41->irq_data, cs35l41_irqs[i].irq);
-			if (irq < 0)
-				return irq;
-
-			ret = devm_request_threaded_irq(cs35l41->dev, irq, NULL,
-							cs35l41_irqs[i].handler,
-							IRQF_ONESHOT | IRQF_SHARED | irq_pol,
-							cs35l41_irqs[i].name, cs35l41);
-			if (ret)
-				return ret;
-		}
-	}
-
-	return cs35l41_hda_channel_map(cs35l41->dev, 0, NULL, 1, &hw_cfg->spk_pos);
-}
-
-static int cs35l41_get_acpi_sub_string(struct device *dev, struct acpi_device *adev,
-				       const char **subsysid)
-{
-	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
-	union acpi_object *obj;
-	acpi_status status;
-	int ret = 0;
-
-	status = acpi_evaluate_object(adev->handle, "_SUB", NULL, &buffer);
-	if (ACPI_SUCCESS(status)) {
-		obj = buffer.pointer;
-		if (obj->type == ACPI_TYPE_STRING) {
-			*subsysid = devm_kstrdup(dev, obj->string.pointer, GFP_KERNEL);
-			if (*subsysid == NULL) {
-				dev_err(dev, "Cannot allocate Subsystem ID");
-				ret = -ENOMEM;
-			}
-		} else {
-			dev_warn(dev, "Warning ACPI _SUB did not return a string\n");
-			ret = -ENODEV;
-		}
-		acpi_os_free(buffer.pointer);
-	} else {
-		dev_dbg(dev, "Warning ACPI _SUB failed: %#x\n", status);
-		ret = -ENODEV;
-	}
-
-	return ret;
-}
-
-static int cs35l41_get_speaker_id(struct device *dev, int amp_index,
-				  int num_amps, int fixed_gpio_id)
-{
-	struct gpio_desc *speaker_id_desc;
-	int speaker_id = -ENODEV;
-
-	if (fixed_gpio_id >= 0) {
-		dev_dbg(dev, "Found Fixed Speaker ID GPIO (index = %d)\n", fixed_gpio_id);
-		speaker_id_desc = gpiod_get_index(dev, NULL, fixed_gpio_id, GPIOD_IN);
-		if (IS_ERR(speaker_id_desc)) {
-			speaker_id = PTR_ERR(speaker_id_desc);
-			return speaker_id;
-		}
-		speaker_id = gpiod_get_value_cansleep(speaker_id_desc);
-		gpiod_put(speaker_id_desc);
-		dev_dbg(dev, "Speaker ID = %d\n", speaker_id);
-	} else {
-		int base_index;
-		int gpios_per_amp;
-		int count;
-		int tmp;
-		int i;
-
-		count = gpiod_count(dev, "spk-id");
-		if (count > 0) {
-			speaker_id = 0;
-			gpios_per_amp = count / num_amps;
-			base_index = gpios_per_amp * amp_index;
-
-			if (count % num_amps)
-				return -EINVAL;
-
-			dev_dbg(dev, "Found %d Speaker ID GPIOs per Amp\n", gpios_per_amp);
-
-			for (i = 0; i < gpios_per_amp; i++) {
-				speaker_id_desc = gpiod_get_index(dev, "spk-id", i + base_index,
-								  GPIOD_IN);
-				if (IS_ERR(speaker_id_desc)) {
-					speaker_id = PTR_ERR(speaker_id_desc);
-					break;
-				}
-				tmp = gpiod_get_value_cansleep(speaker_id_desc);
-				gpiod_put(speaker_id_desc);
-				if (tmp < 0) {
-					speaker_id = tmp;
-					break;
-				}
-				speaker_id |= tmp << i;
-			}
-			dev_dbg(dev, "Speaker ID = %d\n", speaker_id);
-		}
-	}
-	return speaker_id;
-}
-
-/*
- * Device CLSA010(0/1) doesn't have _DSD so a gpiod_get by the label reset won't work.
- * And devices created by serial-multi-instantiate don't have their device struct
- * pointing to the correct fwnode, so acpi_dev must be used here.
- * And devm functions expect that the device requesting the resource has the correct
- * fwnode.
- */
-static int cs35l41_no_acpi_dsd(struct cs35l41_hda *cs35l41, struct device *physdev, int id,
-			       const char *hid)
-{
-	struct cs35l41_hw_cfg *hw_cfg = &cs35l41->hw_cfg;
-
-	/* check I2C address to assign the index */
-	cs35l41->index = id == 0x40 ? 0 : 1;
-	cs35l41->channel_index = 0;
-	cs35l41->reset_gpio = gpiod_get_index(physdev, NULL, 0, GPIOD_OUT_HIGH);
-	cs35l41->speaker_id = cs35l41_get_speaker_id(physdev, 0, 0, 2);
-	hw_cfg->spk_pos = cs35l41->index;
-	hw_cfg->gpio2.func = CS35L41_INTERRUPT;
-	hw_cfg->gpio2.valid = true;
-	hw_cfg->valid = true;
-	put_device(physdev);
-
-	if (strncmp(hid, "CLSA0100", 8) == 0) {
-		hw_cfg->bst_type = CS35L41_EXT_BOOST_NO_VSPK_SWITCH;
-	} else if (strncmp(hid, "CLSA0101", 8) == 0) {
-		hw_cfg->bst_type = CS35L41_EXT_BOOST;
-		hw_cfg->gpio1.func = CS35l41_VSPK_SWITCH;
-		hw_cfg->gpio1.valid = true;
-	} else {
-		/*
-		 * Note: CLSA010(0/1) are special cases which use a slightly different design.
-		 * All other HIDs e.g. CSC3551 require valid ACPI _DSD properties to be supported.
-		 */
-		dev_err(cs35l41->dev, "Error: ACPI _DSD Properties are missing for HID %s.\n", hid);
-		hw_cfg->valid = false;
-		hw_cfg->gpio1.valid = false;
-		hw_cfg->gpio2.valid = false;
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int cs35l41_hda_read_acpi(struct cs35l41_hda *cs35l41, const char *hid, int id)
-{
-	struct cs35l41_hw_cfg *hw_cfg = &cs35l41->hw_cfg;
-	u32 values[HDA_MAX_COMPONENTS];
-	struct acpi_device *adev;
-	struct device *physdev;
-	char *property;
-	size_t nval;
-	int i, ret;
-
-	adev = acpi_dev_get_first_match_dev(hid, NULL, -1);
-	if (!adev) {
-		dev_err(cs35l41->dev, "Failed to find an ACPI device for %s\n", hid);
-		return -ENODEV;
-	}
-
-	physdev = get_device(acpi_get_first_physical_node(adev));
-	acpi_dev_put(adev);
-
-	ret = cs35l41_get_acpi_sub_string(cs35l41->dev, adev, &cs35l41->acpi_subsystem_id);
-	if (ret)
-		dev_info(cs35l41->dev, "No Subsystem ID found in ACPI: %d", ret);
-	else
-		dev_dbg(cs35l41->dev, "Subsystem ID %s found", cs35l41->acpi_subsystem_id);
-
-	property = "cirrus,dev-index";
-	ret = device_property_count_u32(physdev, property);
-	if (ret <= 0)
-		return cs35l41_no_acpi_dsd(cs35l41, physdev, id, hid);
-
-	if (ret > ARRAY_SIZE(values)) {
-		ret = -EINVAL;
-		goto err;
-	}
-	nval = ret;
-
-	ret = device_property_read_u32_array(physdev, property, values, nval);
-	if (ret)
-		goto err;
-
-	cs35l41->index = -1;
-	for (i = 0; i < nval; i++) {
-		if (values[i] == id) {
-			cs35l41->index = i;
-			break;
-		}
-	}
-	if (cs35l41->index == -1) {
-		dev_err(cs35l41->dev, "No index found in %s\n", property);
-		ret = -ENODEV;
-		goto err;
-	}
-
-	/* To use the same release code for all laptop variants we can't use devm_ version of
-	 * gpiod_get here, as CLSA010* don't have a fully functional bios with an _DSD node
-	 */
-	cs35l41->reset_gpio = fwnode_gpiod_get_index(acpi_fwnode_handle(adev), "reset", cs35l41->index,
-						     GPIOD_OUT_LOW, "cs35l41-reset");
-
-	property = "cirrus,speaker-position";
-	ret = device_property_read_u32_array(physdev, property, values, nval);
-	if (ret)
-		goto err;
-	hw_cfg->spk_pos = values[cs35l41->index];
-
-	cs35l41->channel_index = 0;
-	for (i = 0; i < cs35l41->index; i++)
-		if (values[i] == hw_cfg->spk_pos)
-			cs35l41->channel_index++;
-
-	property = "cirrus,gpio1-func";
-	ret = device_property_read_u32_array(physdev, property, values, nval);
-	if (ret)
-		goto err;
-	hw_cfg->gpio1.func = values[cs35l41->index];
-	hw_cfg->gpio1.valid = true;
-
-	property = "cirrus,gpio2-func";
-	ret = device_property_read_u32_array(physdev, property, values, nval);
-	if (ret)
-		goto err;
-	hw_cfg->gpio2.func = values[cs35l41->index];
-	hw_cfg->gpio2.valid = true;
-
-	property = "cirrus,boost-peak-milliamp";
-	ret = device_property_read_u32_array(physdev, property, values, nval);
-	if (ret == 0)
-		hw_cfg->bst_ipk = values[cs35l41->index];
-	else
-		hw_cfg->bst_ipk = -1;
-
-	property = "cirrus,boost-ind-nanohenry";
-	ret = device_property_read_u32_array(physdev, property, values, nval);
-	if (ret == 0)
-		hw_cfg->bst_ind = values[cs35l41->index];
-	else
-		hw_cfg->bst_ind = -1;
-
-	property = "cirrus,boost-cap-microfarad";
-	ret = device_property_read_u32_array(physdev, property, values, nval);
-	if (ret == 0)
-		hw_cfg->bst_cap = values[cs35l41->index];
-	else
-		hw_cfg->bst_cap = -1;
-
-	cs35l41->speaker_id = cs35l41_get_speaker_id(physdev, cs35l41->index, nval, -1);
-
-	if (hw_cfg->bst_ind > 0 || hw_cfg->bst_cap > 0 || hw_cfg->bst_ipk > 0)
-		hw_cfg->bst_type = CS35L41_INT_BOOST;
-	else
-		hw_cfg->bst_type = CS35L41_EXT_BOOST;
-
-	hw_cfg->valid = true;
-	put_device(physdev);
-
-	return 0;
-
-err:
-	put_device(physdev);
-	dev_err(cs35l41->dev, "Failed property %s: %d\n", property, ret);
-
-	return ret;
-}
-
-int cs35l41_hda_probe(struct device *dev, const char *device_name, int id, int irq,
-		      struct regmap *regmap)
-{
-	unsigned int int_sts, regid, reg_revid, mtl_revid, chipid, int_status;
-	struct cs35l41_hda *cs35l41;
-	int ret;
-
-	BUILD_BUG_ON(ARRAY_SIZE(cs35l41_irqs) != ARRAY_SIZE(cs35l41_reg_irqs));
-	BUILD_BUG_ON(ARRAY_SIZE(cs35l41_irqs) != CS35L41_NUM_IRQ);
-
-	if (IS_ERR(regmap))
-		return PTR_ERR(regmap);
-
-	cs35l41 = devm_kzalloc(dev, sizeof(*cs35l41), GFP_KERNEL);
-	if (!cs35l41)
-		return -ENOMEM;
-
-	cs35l41->dev = dev;
-	cs35l41->irq = irq;
-	cs35l41->regmap = regmap;
-	dev_set_drvdata(dev, cs35l41);
-
-	ret = cs35l41_hda_read_acpi(cs35l41, device_name, id);
-	if (ret)
-		return dev_err_probe(cs35l41->dev, ret, "Platform not supported\n");
-
-	if (IS_ERR(cs35l41->reset_gpio)) {
-		ret = PTR_ERR(cs35l41->reset_gpio);
-		cs35l41->reset_gpio = NULL;
-		if (ret == -EBUSY) {
-			dev_info(cs35l41->dev, "Reset line busy, assuming shared reset\n");
-		} else {
-			dev_err_probe(cs35l41->dev, ret, "Failed to get reset GPIO\n");
-			goto err;
-		}
-	}
-	if (cs35l41->reset_gpio) {
-		usleep_range(2000, 2100);
-		gpiod_set_value_cansleep(cs35l41->reset_gpio, 1);
-	}
-
-	usleep_range(2000, 2100);
-
-	ret = regmap_read_poll_timeout(cs35l41->regmap, CS35L41_IRQ1_STATUS4, int_status,
-				       int_status & CS35L41_OTP_BOOT_DONE, 1000, 100000);
-	if (ret) {
-		dev_err(cs35l41->dev, "Failed waiting for OTP_BOOT_DONE: %d\n", ret);
-		goto err;
-	}
-
-	ret = regmap_read(cs35l41->regmap, CS35L41_IRQ1_STATUS3, &int_sts);
-	if (ret || (int_sts & CS35L41_OTP_BOOT_ERR)) {
-		dev_err(cs35l41->dev, "OTP Boot status %x error: %d\n",
-			int_sts & CS35L41_OTP_BOOT_ERR, ret);
-		ret = -EIO;
-		goto err;
-	}
-
-	ret = regmap_read(cs35l41->regmap, CS35L41_DEVID, &regid);
-	if (ret) {
-		dev_err(cs35l41->dev, "Get Device ID failed: %d\n", ret);
-		goto err;
-	}
-
-	ret = regmap_read(cs35l41->regmap, CS35L41_REVID, &reg_revid);
-	if (ret) {
-		dev_err(cs35l41->dev, "Get Revision ID failed: %d\n", ret);
-		goto err;
-	}
-
-	mtl_revid = reg_revid & CS35L41_MTLREVID_MASK;
-
-	chipid = (mtl_revid % 2) ? CS35L41R_CHIP_ID : CS35L41_CHIP_ID;
-	if (regid != chipid) {
-		dev_err(cs35l41->dev, "CS35L41 Device ID (%X). Expected ID %X\n", regid, chipid);
-		ret = -ENODEV;
-		goto err;
-	}
-
-	ret = cs35l41_test_key_unlock(cs35l41->dev, cs35l41->regmap);
-	if (ret)
-		goto err;
-
-	ret = cs35l41_register_errata_patch(cs35l41->dev, cs35l41->regmap, reg_revid);
-	if (ret)
-		goto err;
-
-	ret = cs35l41_otp_unpack(cs35l41->dev, cs35l41->regmap);
-	if (ret) {
-		dev_err(cs35l41->dev, "OTP Unpack failed: %d\n", ret);
-		goto err;
-	}
-
-	ret = cs35l41_test_key_lock(cs35l41->dev, cs35l41->regmap);
-	if (ret)
-		goto err;
-
-	INIT_WORK(&cs35l41->fw_load_work, cs35l41_fw_load_work);
-	mutex_init(&cs35l41->fw_mutex);
-
-	pm_runtime_set_autosuspend_delay(cs35l41->dev, 3000);
-	pm_runtime_use_autosuspend(cs35l41->dev);
-	pm_runtime_mark_last_busy(cs35l41->dev);
-	pm_runtime_set_active(cs35l41->dev);
-	pm_runtime_get_noresume(cs35l41->dev);
-	pm_runtime_enable(cs35l41->dev);
-
-	ret = cs35l41_hda_apply_properties(cs35l41);
-	if (ret)
-		goto err_pm;
-
-	pm_runtime_put_autosuspend(cs35l41->dev);
-
-	ret = component_add(cs35l41->dev, &cs35l41_hda_comp_ops);
-	if (ret) {
-		dev_err(cs35l41->dev, "Register component failed: %d\n", ret);
-		pm_runtime_disable(cs35l41->dev);
-		goto err;
-	}
-
-	dev_info(cs35l41->dev, "Cirrus Logic CS35L41 (%x), Revision: %02X\n", regid, reg_revid);
-
-	return 0;
-
-err_pm:
-	pm_runtime_disable(cs35l41->dev);
-	pm_runtime_put_noidle(cs35l41->dev);
-
-err:
-	if (cs35l41_safe_reset(cs35l41->regmap, cs35l41->hw_cfg.bst_type))
-		gpiod_set_value_cansleep(cs35l41->reset_gpio, 0);
-	gpiod_put(cs35l41->reset_gpio);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(cs35l41_hda_probe);
-
-void cs35l41_hda_remove(struct device *dev)
-{
-	struct cs35l41_hda *cs35l41 = dev_get_drvdata(dev);
-
-	pm_runtime_get_sync(cs35l41->dev);
-	pm_runtime_disable(cs35l41->dev);
-
-	if (cs35l41->halo_initialized)
-		cs35l41_remove_dsp(cs35l41);
-
-	component_del(cs35l41->dev, &cs35l41_hda_comp_ops);
-
-	pm_runtime_put_noidle(cs35l41->dev);
-
-	if (cs35l41_safe_reset(cs35l41->regmap, cs35l41->hw_cfg.bst_type))
-		gpiod_set_value_cansleep(cs35l41->reset_gpio, 0);
-	gpiod_put(cs35l41->reset_gpio);
-}
-EXPORT_SYMBOL_GPL(cs35l41_hda_remove);
-
-
-const struct dev_pm_ops cs35l41_hda_pm_ops = {
-	RUNTIME_PM_OPS(cs35l41_runtime_suspend, cs35l41_runtime_resume, NULL)
-};
-EXPORT_SYMBOL_NS_GPL(cs35l41_hda_pm_ops, SND_HDA_SCODEC_CS35L41);
-
-MODULE_DESCRIPTION("CS35L41 HDA Driver");
-MODULE_IMPORT_NS(SND_HDA_CS_DSP_CONTROLS);
-MODULE_AUTHOR("Lucas Tanure, Cirrus Logic Inc, <tanureal@opensource.cirrus.com>");
-MODULE_LICENSE("GPL");
diff -ruN a/sound/pci/hda/cs35l41_hda.h b/sound/pci/hda/cs35l41_hda.h
--- a/sound/pci/hda/cs35l41_hda.h	2023-02-15 21:19:59.000000000 +0100
+++ b/sound/pci/hda/cs35l41_hda.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,87 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
- * CS35L41 ALSA HDA audio driver
- *
- * Copyright 2021 Cirrus Logic, Inc.
- *
- * Author: Lucas Tanure <tanureal@opensource.cirrus.com>
- */
-
-#ifndef __CS35L41_HDA_H__
-#define __CS35L41_HDA_H__
-
-#include <linux/efi.h>
-#include <linux/regulator/consumer.h>
-#include <linux/gpio/consumer.h>
-#include <linux/device.h>
-#include <sound/cs35l41.h>
-
-#include <linux/firmware/cirrus/cs_dsp.h>
-#include <linux/firmware/cirrus/wmfw.h>
-
-struct cs35l41_amp_cal_data {
-	u32 calTarget[2];
-	u32 calTime[2];
-	s8 calAmbient;
-	u8 calStatus;
-	u16 calR;
-} __packed;
-
-struct cs35l41_amp_efi_data {
-	u32 size;
-	u32 count;
-	struct cs35l41_amp_cal_data data[];
-} __packed;
-
-enum cs35l41_hda_spk_pos {
-	CS35l41_LEFT,
-	CS35l41_RIGHT,
-};
-
-enum cs35l41_hda_gpio_function {
-	CS35L41_NOT_USED,
-	CS35l41_VSPK_SWITCH,
-	CS35L41_INTERRUPT,
-	CS35l41_SYNC,
-};
-
-struct cs35l41_hda {
-	struct device *dev;
-	struct regmap *regmap;
-	struct gpio_desc *reset_gpio;
-	struct cs35l41_hw_cfg hw_cfg;
-	struct hda_codec *codec;
-
-	int irq;
-	int index;
-	int channel_index;
-	unsigned volatile long irq_errors;
-	const char *amp_name;
-	const char *acpi_subsystem_id;
-	int firmware_type;
-	int speaker_id;
-	struct mutex fw_mutex;
-	struct work_struct fw_load_work;
-
-	struct regmap_irq_chip_data *irq_data;
-	bool firmware_running;
-	bool request_fw_load;
-	bool fw_request_ongoing;
-	bool halo_initialized;
-	bool playback_started;
-	struct cs_dsp cs_dsp;
-};
-
-enum halo_state {
-	HALO_STATE_CODE_INIT_DOWNLOAD = 0,
-	HALO_STATE_CODE_START,
-	HALO_STATE_CODE_RUN
-};
-
-extern const struct dev_pm_ops cs35l41_hda_pm_ops;
-
-int cs35l41_hda_probe(struct device *dev, const char *device_name, int id, int irq,
-		      struct regmap *regmap);
-void cs35l41_hda_remove(struct device *dev);
-
-#endif /*__CS35L41_HDA_H__*/
diff -ruN a/sound/pci/hda/cs35l41_hda_i2c.c b/sound/pci/hda/cs35l41_hda_i2c.c
--- a/sound/pci/hda/cs35l41_hda_i2c.c	2023-02-15 21:19:59.000000000 +0100
+++ b/sound/pci/hda/cs35l41_hda_i2c.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,70 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-//
-// CS35l41 HDA I2C driver
-//
-// Copyright 2021 Cirrus Logic, Inc.
-//
-// Author: Lucas Tanure <tanureal@opensource.cirrus.com>
-
-#include <linux/mod_devicetable.h>
-#include <linux/module.h>
-#include <linux/i2c.h>
-
-#include "cs35l41_hda.h"
-
-static int cs35l41_hda_i2c_probe(struct i2c_client *clt, const struct i2c_device_id *id)
-{
-	const char *device_name;
-
-	/*
-	 * Compare against the device name so it works for SPI, normal ACPI
-	 * and for ACPI by serial-multi-instantiate matching cases.
-	 */
-	if (strstr(dev_name(&clt->dev), "CLSA0100"))
-		device_name = "CLSA0100";
-	else if (strstr(dev_name(&clt->dev), "CLSA0101"))
-		device_name = "CLSA0101";
-	else if (strstr(dev_name(&clt->dev), "CSC3551"))
-		device_name = "CSC3551";
-	else
-		return -ENODEV;
-
-	return cs35l41_hda_probe(&clt->dev, device_name, clt->addr, clt->irq,
-				 devm_regmap_init_i2c(clt, &cs35l41_regmap_i2c));
-}
-
-static int cs35l41_hda_i2c_remove(struct i2c_client *clt)
-{
-	cs35l41_hda_remove(&clt->dev);
-
-	return 0;
-}
-
-static const struct i2c_device_id cs35l41_hda_i2c_id[] = {
-	{ "cs35l41-hda", 0 },
-	{}
-};
-
-static const struct acpi_device_id cs35l41_acpi_hda_match[] = {
-	{"CLSA0100", 0 },
-	{"CLSA0101", 0 },
-	{"CSC3551", 0 },
-	{}
-};
-MODULE_DEVICE_TABLE(acpi, cs35l41_acpi_hda_match);
-
-static struct i2c_driver cs35l41_i2c_driver = {
-	.driver = {
-		.name		= "cs35l41-hda",
-		.acpi_match_table = cs35l41_acpi_hda_match,
-		.pm		= &cs35l41_hda_pm_ops,
-	},
-	.id_table	= cs35l41_hda_i2c_id,
-	.probe		= cs35l41_hda_i2c_probe,
-	.remove		= cs35l41_hda_i2c_remove,
-};
-module_i2c_driver(cs35l41_i2c_driver);
-
-MODULE_DESCRIPTION("HDA CS35L41 driver");
-MODULE_AUTHOR("Lucas Tanure <tanureal@opensource.cirrus.com>");
-MODULE_LICENSE("GPL");
diff -ruN a/sound/pci/hda/cs35l41_hda_spi.c b/sound/pci/hda/cs35l41_hda_spi.c
--- a/sound/pci/hda/cs35l41_hda_spi.c	2023-02-15 21:19:59.000000000 +0100
+++ b/sound/pci/hda/cs35l41_hda_spi.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,62 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-//
-// CS35l41 HDA SPI driver
-//
-// Copyright 2021 Cirrus Logic, Inc.
-//
-// Author: Lucas Tanure <tanureal@opensource.cirrus.com>
-
-#include <linux/mod_devicetable.h>
-#include <linux/module.h>
-#include <linux/spi/spi.h>
-
-#include "cs35l41_hda.h"
-
-static int cs35l41_hda_spi_probe(struct spi_device *spi)
-{
-	const char *device_name;
-
-	/*
-	 * Compare against the device name so it works for SPI, normal ACPI
-	 * and for ACPI by serial-multi-instantiate matching cases.
-	 */
-	if (strstr(dev_name(&spi->dev), "CSC3551"))
-		device_name = "CSC3551";
-	else
-		return -ENODEV;
-
-	return cs35l41_hda_probe(&spi->dev, device_name, spi->chip_select, spi->irq,
-				 devm_regmap_init_spi(spi, &cs35l41_regmap_spi));
-}
-
-static void cs35l41_hda_spi_remove(struct spi_device *spi)
-{
-	cs35l41_hda_remove(&spi->dev);
-}
-
-static const struct spi_device_id cs35l41_hda_spi_id[] = {
-	{ "cs35l41-hda", 0 },
-	{}
-};
-
-static const struct acpi_device_id cs35l41_acpi_hda_match[] = {
-	{ "CSC3551", 0 },
-	{}
-};
-MODULE_DEVICE_TABLE(acpi, cs35l41_acpi_hda_match);
-
-static struct spi_driver cs35l41_spi_driver = {
-	.driver = {
-		.name		= "cs35l41-hda",
-		.acpi_match_table = cs35l41_acpi_hda_match,
-		.pm		= &cs35l41_hda_pm_ops,
-	},
-	.id_table	= cs35l41_hda_spi_id,
-	.probe		= cs35l41_hda_spi_probe,
-	.remove		= cs35l41_hda_spi_remove,
-};
-module_spi_driver(cs35l41_spi_driver);
-
-MODULE_DESCRIPTION("HDA CS35L41 driver");
-MODULE_AUTHOR("Lucas Tanure <tanureal@opensource.cirrus.com>");
-MODULE_LICENSE("GPL");
diff -ruN a/sound/soc/amd/acp3x-rt5682-max9836.c b/sound/soc/amd/acp3x-rt5682-max9836.c
--- a/sound/soc/amd/acp3x-rt5682-max9836.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/acp3x-rt5682-max9836.c	2022-07-08 01:12:12.000000000 +0200
@@ -512,11 +512,17 @@
 
 	ret = devm_snd_soc_register_card(&pdev->dev, card);
 	if (ret) {
-		return dev_err_probe(&pdev->dev, ret,
-				"devm_snd_soc_register_card(%s) failed\n",
-				card->name);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev,
+				"devm_snd_soc_register_card(%s) failed: %d\n",
+				card->name, ret);
+		else
+			dev_dbg(&pdev->dev,
+				"devm_snd_soc_register_card(%s) probe deferred: %d\n",
+				card->name, ret);
 	}
-	return 0;
+
+	return ret;
 }
 
 static const struct acpi_device_id acp3x_audio_acpi_match[] = {
diff -ruN a/sound/soc/amd/acp-config.c b/sound/soc/amd/acp-config.c
--- a/sound/soc/amd/acp-config.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/acp-config.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,163 +0,0 @@
-// SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause)
-//
-// This file is provided under a dual BSD/GPLv2 license. When using or
-// redistributing this file, you may do so under either license.
-//
-// Copyright(c) 2021 Advanced Micro Devices, Inc.
-//
-// Authors: Ajit Kumar Pandey <AjitKumar.Pandey@amd.com>
-//
-
-/* ACP machine configuration module */
-
-#include <linux/acpi.h>
-#include <linux/bits.h>
-#include <linux/dmi.h>
-#include <linux/module.h>
-#include <linux/pci.h>
-
-#include "../sof/amd/acp.h"
-#include "mach-config.h"
-
-static int acp_quirk_data;
-
-static const struct config_entry config_table[] = {
-	{
-		.flags = FLAG_AMD_SOF,
-		.device = ACP_PCI_DEV_ID,
-		.dmi_table = (const struct dmi_system_id []) {
-			{
-				.matches = {
-					DMI_MATCH(DMI_SYS_VENDOR, "AMD"),
-					DMI_MATCH(DMI_PRODUCT_NAME, "Majolica-CZN"),
-				},
-			},
-			{}
-		},
-	},
-	{
-		.flags = FLAG_AMD_SOF,
-		.device = ACP_PCI_DEV_ID,
-		.dmi_table = (const struct dmi_system_id []) {
-			{
-				.matches = {
-					DMI_MATCH(DMI_SYS_VENDOR, "Google"),
-				},
-			},
-			{}
-		},
-	},
-};
-
-int snd_amd_acp_find_config(struct pci_dev *pci)
-{
-	const struct config_entry *table = config_table;
-	u16 device = pci->device;
-	int i;
-
-	/* Do not enable FLAGS on older platforms with Rev id zero */
-	if (!pci->revision)
-		return 0;
-
-	for (i = 0; i < ARRAY_SIZE(config_table); i++, table++) {
-		if (table->device != device)
-			continue;
-		if (table->dmi_table && !dmi_check_system(table->dmi_table))
-			continue;
-		acp_quirk_data = table->flags;
-		return table->flags;
-	}
-
-	return 0;
-}
-EXPORT_SYMBOL(snd_amd_acp_find_config);
-
-static struct snd_soc_acpi_codecs amp_rt1019 = {
-	.num_codecs = 1,
-	.codecs = {"10EC1019"}
-};
-
-static struct snd_soc_acpi_codecs amp_max = {
-	.num_codecs = 1,
-	.codecs = {"MX98360A"}
-};
-
-struct snd_soc_acpi_mach snd_soc_acpi_amd_sof_machines[] = {
-	{
-		.id = "10EC5682",
-		.drv_name = "rt5682-rt1019",
-		.pdata = (void *)&acp_quirk_data,
-		.machine_quirk = snd_soc_acpi_codec_list,
-		.quirk_data = &amp_rt1019,
-		.fw_filename = "sof-rn.ri",
-		.sof_tplg_filename = "sof-rn-rt5682-rt1019.tplg",
-	},
-	{
-		.id = "10EC5682",
-		.drv_name = "rt5682-max",
-		.pdata = (void *)&acp_quirk_data,
-		.machine_quirk = snd_soc_acpi_codec_list,
-		.quirk_data = &amp_max,
-		.fw_filename = "sof-rn.ri",
-		.sof_tplg_filename = "sof-rn-rt5682-max98360.tplg",
-	},
-	{
-		.id = "RTL5682",
-		.drv_name = "rt5682s-max",
-		.pdata = (void *)&acp_quirk_data,
-		.machine_quirk = snd_soc_acpi_codec_list,
-		.quirk_data = &amp_max,
-		.fw_filename = "sof-rn.ri",
-		.sof_tplg_filename = "sof-rn-rt5682-max98360.tplg",
-	},
-	{
-		.id = "RTL5682",
-		.drv_name = "rt5682s-rt1019",
-		.pdata = (void *)&acp_quirk_data,
-		.machine_quirk = snd_soc_acpi_codec_list,
-		.quirk_data = &amp_rt1019,
-		.fw_filename = "sof-rn.ri",
-		.sof_tplg_filename = "sof-rn-rt5682-rt1019.tplg",
-	},
-	{
-		.id = "AMDI1019",
-		.drv_name = "renoir-dsp",
-		.pdata = (void *)&acp_quirk_data,
-		.fw_filename = "sof-rn.ri",
-		.sof_tplg_filename = "sof-acp.tplg",
-	},
-	{},
-};
-EXPORT_SYMBOL(snd_soc_acpi_amd_sof_machines);
-
-struct snd_soc_acpi_mach snd_soc_acpi_amd_rmb_sof_machines[] = {
-	{
-		.id = "AMDI1019",
-		.drv_name = "rmb-dsp",
-		.pdata = &acp_quirk_data,
-		.fw_filename = "sof-rmb.ri",
-		.sof_tplg_filename = "sof-acp-rmb.tplg",
-	},
-	{
-		.id = "10508825",
-		.drv_name = "nau8825-max",
-		.pdata = &acp_quirk_data,
-		.machine_quirk = snd_soc_acpi_codec_list,
-		.quirk_data = &amp_max,
-		.fw_filename = "sof-rmb.ri",
-		.sof_tplg_filename = "sof-rmb-nau8825-max98360.tplg",
-	},
-	{
-		.id = "RTL5682",
-		.drv_name = "rt5682s-hs-rt1019",
-		.pdata = &acp_quirk_data,
-		.machine_quirk = snd_soc_acpi_codec_list,
-		.quirk_data = &amp_rt1019,
-		.fw_filename = "sof-rmb.ri",
-		.sof_tplg_filename = "sof-rmb-rt5682s-rt1019.tplg",
-	},
-	{},
-};
-EXPORT_SYMBOL(snd_soc_acpi_amd_rmb_sof_machines);
-
-MODULE_LICENSE("Dual BSD/GPL");
diff -ruN a/sound/soc/amd/acp-da7219-max98357a.c b/sound/soc/amd/acp-da7219-max98357a.c
--- a/sound/soc/amd/acp-da7219-max98357a.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/acp-da7219-max98357a.c	2022-07-08 01:12:12.000000000 +0200
@@ -756,9 +746,15 @@
 	snd_soc_card_set_drvdata(card, machine);
 	ret = devm_snd_soc_register_card(&pdev->dev, card);
 	if (ret) {
-		return dev_err_probe(&pdev->dev, ret,
-				"devm_snd_soc_register_card(%s) failed\n",
-				card->name);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev,
+				"devm_snd_soc_register_card(%s) failed: %d\n",
+				card->name, ret);
+		else
+			dev_dbg(&pdev->dev,
+				"devm_snd_soc_register_card(%s) probe deferred: %d\n",
+				card->name, ret);
+		return ret;
 	}
 	bt_uart_enable = !device_property_read_bool(&pdev->dev,
 						    "bt-pad-enable");
diff -ruN a/sound/soc/amd/acp-pcm-dma.c b/sound/soc/amd/acp-pcm-dma.c
--- a/sound/soc/amd/acp-pcm-dma.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/acp-pcm-dma.c	2022-07-08 01:12:12.000000000 +0200
@@ -156,7 +156,7 @@
 	acp_reg_write(priority_level, acp_mmio, mmACP_DMA_PRIO_0 + ch_num);
 }
 
-/* Initialize a dma descriptor in SRAM based on descriptor information passed */
+/* Initialize a dma descriptor in SRAM based on descritor information passed */
 static void config_dma_descriptor_in_sram(void __iomem *acp_mmio,
 					  u16 descr_idx,
 					  acp_dma_dscr_transfer_t *descr_info)
@@ -288,7 +288,7 @@
 					      &dmadscr[i]);
 	}
 	pre_config_reset(acp_mmio, ch);
-	/* Configure the DMA channel with the above descriptor */
+	/* Configure the DMA channel with the above descriptore */
 	config_acp_dma_channel(acp_mmio, ch, dma_dscr_idx - 1,
 			       NUM_DSCRS_PER_CHANNEL,
 			       ACP_DMA_PRIORITY_LEVEL_NORMAL);
@@ -322,7 +322,7 @@
 		high |= BIT(31);
 		acp_reg_write(high, acp_mmio, mmACP_SRBM_Targ_Idx_Data);
 
-		/* Move to next physically contiguous page */
+		/* Move to next physically contiguos page */
 		addr += PAGE_SIZE;
 	}
 }
@@ -602,11 +602,11 @@
 		acp_reg_write(val, acp_mmio, mmACP_BT_UART_PAD_SEL);
 	}
 
-	/* initialize Onion control DAGB register */
+	/* initiailize Onion control DAGB register */
 	acp_reg_write(ACP_ONION_CNTL_DEFAULT, acp_mmio,
 		      mmACP_AXI2DAGB_ONION_CNTL);
 
-	/* initialize Garlic control DAGB registers */
+	/* initiailize Garlic control DAGB registers */
 	acp_reg_write(ACP_GARLIC_CNTL_DEFAULT, acp_mmio,
 		      mmACP_AXI2DAGB_GARLIC_CNTL);
 
@@ -621,7 +621,7 @@
 	acp_reg_write(ACP_SRAM_BASE_ADDRESS, acp_mmio,
 		      mmACP_DMA_DESC_BASE_ADDR);
 
-	/* Num of descriptors in SRAM 0x4, means 256 descriptors;(64 * 4) */
+	/* Num of descriptiors in SRAM 0x4, means 256 descriptors;(64 * 4) */
 	acp_reg_write(0x4, acp_mmio, mmACP_DMA_DESC_MAX_NUM_DSCR);
 	acp_reg_write(ACP_EXTERNAL_INTR_CNTL__DMAIOCMask_MASK,
 		      acp_mmio, mmACP_EXTERNAL_INTR_CNTL);
@@ -1035,6 +1035,13 @@
 	return bytes_to_frames(runtime, pos);
 }
 
+static int acp_dma_mmap(struct snd_soc_component *component,
+			struct snd_pcm_substream *substream,
+			struct vm_area_struct *vma)
+{
+	return snd_pcm_lib_default_mmap(substream, vma);
+}
+
 static int acp_dma_prepare(struct snd_soc_component *component,
 			   struct snd_pcm_substream *substream)
 {
@@ -1198,14 +1205,16 @@
 	.hw_params	= acp_dma_hw_params,
 	.trigger	= acp_dma_trigger,
 	.pointer	= acp_dma_pointer,
+	.mmap		= acp_dma_mmap,
 	.prepare	= acp_dma_prepare,
 	.pcm_construct	= acp_dma_new,
 };
 
 static int acp_audio_probe(struct platform_device *pdev)
 {
-	int status, irq;
+	int status;
 	struct audio_drv_data *audio_drv_data;
+	struct resource *res;
 	const u32 *pdata = pdev->dev.platform_data;
 
 	if (!pdata) {
@@ -1235,11 +1244,13 @@
 
 	audio_drv_data->asic_type =  *pdata;
 
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0)
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "IORESOURCE_IRQ FAILED\n");
 		return -ENODEV;
+	}
 
-	status = devm_request_irq(&pdev->dev, irq, dma_irq_handler,
+	status = devm_request_irq(&pdev->dev, res->start, dma_irq_handler,
 				  0, "ACP_IRQ", &pdev->dev);
 	if (status) {
 		dev_err(&pdev->dev, "ACP IRQ request failed\n");
diff -ruN a/sound/soc/amd/Kconfig b/sound/soc/amd/Kconfig
--- a/sound/soc/amd/Kconfig	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/Kconfig	2022-07-08 01:12:12.000000000 +0200
@@ -36,13 +36,12 @@
 	select I2C_CROS_EC_TUNNEL
 	select SND_SOC_RT1015
 	select SND_SOC_RT1015P
-	depends on SND_SOC_AMD_ACP3x && I2C && CROS_EC && GPIOLIB
+	depends on SND_SOC_AMD_ACP3x && I2C && CROS_EC
 	help
 	 This option enables machine driver for RT5682 and MAX9835.
 
 config SND_SOC_AMD_RENOIR
 	tristate "AMD Audio Coprocessor - Renoir support"
-	select SND_AMD_ACP_CONFIG
 	depends on X86 && PCI
 	help
 	 This option enables ACP support for Renoir platform
@@ -50,7 +49,7 @@
 config SND_SOC_AMD_RENOIR_MACH
 	tristate "AMD Renoir support for DMIC"
 	select SND_SOC_DMIC
-	depends on SND_SOC_AMD_RENOIR && GPIOLIB
+	depends on SND_SOC_AMD_RENOIR
 	help
 	 This option enables machine driver for DMIC
 
@@ -67,39 +66,9 @@
 	tristate "AMD Vangogh support for NAU8821 CS35L41"
 	select SND_SOC_NAU8821
 	select SND_SOC_CS35L41_SPI
-	depends on SND_SOC_AMD_ACP5x && I2C
+	depends on SND_SOC_AMD_ACP5x && I2C && SPI
 	help
 	  This option enables machine driver for Vangogh platform
 	  using NAU8821 and CS35L41 codecs.
 	  Say m if you have such a device.
 	  If unsure select "N".
-
-config SND_SOC_AMD_ACP6x
-	tristate "AMD Audio Coprocessor-v6.x Yellow Carp support"
-	depends on X86 && PCI
-	help
-	  This option enables Audio Coprocessor i.e ACP v6.x support on
-	  AMD Yellow Carp platform. By enabling this flag build will be
-	  triggered for ACP PCI driver, ACP PDM DMA driver.
-	  Say m if you have such a device.
-	  If unsure select "N".
-
-config SND_SOC_AMD_YC_MACH
-	tristate "AMD YC support for DMIC"
-	select SND_SOC_DMIC
-	depends on SND_SOC_AMD_ACP6x
-	help
-	  This option enables machine driver for Yellow Carp platform
-	  using dmic. ACP IP has PDM Decoder block with DMA controller.
-	  DMIC can be connected directly to ACP IP.
-	  Say m if you have such a device.
-	  If unsure select "N".
-
-config SND_AMD_ACP_CONFIG
-	tristate "AMD ACP configuration selection"
-	select SND_SOC_ACPI if ACPI
-	help
-	 This option adds an auto detection to determine which ACP
-	 driver modules to use
-
-source "sound/soc/amd/acp/Kconfig"
diff -ruN a/sound/soc/amd/mach-config.h b/sound/soc/amd/mach-config.h
--- a/sound/soc/amd/mach-config.h	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/mach-config.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,30 +0,0 @@
-/* SPDX-License-Identifier: (GPL-2.0-only OR BSD-3-Clause) */
-/*
- * This file is provided under a dual BSD/GPLv2 license. When using or
- * redistributing this file, you may do so under either license.
- *
- * Copyright(c) 2021 Advanced Micro Devices, Inc. All rights reserved.
- *
- * Author: Ajit Kumar Pandey <AjitKumar.Pandey@amd.com>
- */
-#ifndef __AMD_MACH_CONFIG_H
-#define __AMD_MACH_CONFIG_H
-
-#include <sound/soc-acpi.h>
-
-#define FLAG_AMD_SOF			BIT(1)
-#define FLAG_AMD_SOF_ONLY_DMIC		BIT(2)
-#define FLAG_AMD_LEGACY			BIT(3)
-
-#define ACP_PCI_DEV_ID			0x15E2
-
-extern struct snd_soc_acpi_mach snd_soc_acpi_amd_sof_machines[];
-extern struct snd_soc_acpi_mach snd_soc_acpi_amd_rmb_sof_machines[];
-
-struct config_entry {
-	u32 flags;
-	u16 device;
-	const struct dmi_system_id *dmi_table;
-};
-
-#endif
diff -ruN a/sound/soc/amd/Makefile b/sound/soc/amd/Makefile
--- a/sound/soc/amd/Makefile	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/Makefile	2022-07-08 01:12:12.000000000 +0200
@@ -3,7 +3,6 @@
 snd-soc-acp-da7219mx98357-mach-objs := acp-da7219-max98357a.o
 snd-soc-acp-rt5645-mach-objs := acp-rt5645.o
 snd-soc-acp-rt5682-mach-objs := acp3x-rt5682-max9836.o
-snd-acp-config-objs := acp-config.o
 
 obj-$(CONFIG_SND_SOC_AMD_ACP) += acp_audio_dma.o
 obj-$(CONFIG_SND_SOC_AMD_CZ_DA7219MX98357_MACH) += snd-soc-acp-da7219mx98357-mach.o
@@ -12,5 +11,3 @@
 obj-$(CONFIG_SND_SOC_AMD_RV_RT5682_MACH) += snd-soc-acp-rt5682-mach.o
 obj-$(CONFIG_SND_SOC_AMD_RENOIR) += renoir/
 obj-$(CONFIG_SND_SOC_AMD_ACP5x) += vangogh/
-obj-$(CONFIG_SND_SOC_AMD_ACP_COMMON) += acp/
-obj-$(CONFIG_SND_AMD_ACP_CONFIG) += snd-acp-config.o
diff -ruN a/sound/soc/amd/raven/acp3x.h b/sound/soc/amd/raven/acp3x.h
--- a/sound/soc/amd/raven/acp3x.h	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/raven/acp3x.h	2022-07-08 01:12:12.000000000 +0200
@@ -87,7 +87,7 @@
 
 struct i2s_dev_data {
 	bool tdm_mode;
-	int i2s_irq;
+	unsigned int i2s_irq;
 	u16 i2s_instance;
 	u32 tdm_fmt;
 	u32 substream_type;
diff -ruN a/sound/soc/amd/raven/acp3x-pcm-dma.c b/sound/soc/amd/raven/acp3x-pcm-dma.c
--- a/sound/soc/amd/raven/acp3x-pcm-dma.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/raven/acp3x-pcm-dma.c	2022-07-08 01:12:12.000000000 +0200
@@ -147,7 +147,7 @@
 		high |= BIT(31);
 		rv_writel(high, rtd->acp3x_base + mmACP_SCRATCH_REG_0 + val
 				+ 4);
-		/* Move to next physically contiguous page */
+		/* Move to next physically contiguos page */
 		val += 8;
 		addr += PAGE_SIZE;
 	}
@@ -286,7 +286,7 @@
 		pr_err("pinfo failed\n");
 	}
 	size = params_buffer_bytes(params);
-	rtd->dma_addr = substream->runtime->dma_addr;
+	rtd->dma_addr = substream->dma_buffer.addr;
 	rtd->num_pages = (PAGE_ALIGN(size) >> PAGE_SHIFT);
 	config_acp3x_dma(rtd, substream->stream);
 	return 0;
@@ -320,6 +320,13 @@
 	return 0;
 }
 
+static int acp3x_dma_mmap(struct snd_soc_component *component,
+			  struct snd_pcm_substream *substream,
+			  struct vm_area_struct *vma)
+{
+	return snd_pcm_lib_default_mmap(substream, vma);
+}
+
 static int acp3x_dma_close(struct snd_soc_component *component,
 			   struct snd_pcm_substream *substream)
 {
@@ -363,6 +370,7 @@
 	.close		= acp3x_dma_close,
 	.hw_params	= acp3x_dma_hw_params,
 	.pointer	= acp3x_dma_pointer,
+	.mmap		= acp3x_dma_mmap,
 	.pcm_construct	= acp3x_dma_new,
 };
 
@@ -394,10 +402,13 @@
 	if (!adata->acp3x_base)
 		return -ENOMEM;
 
-	status = platform_get_irq(pdev, 0);
-	if (status < 0)
-		return status;
-	adata->i2s_irq = status;
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "IORESOURCE_IRQ FAILED\n");
+		return -ENODEV;
+	}
+
+	adata->i2s_irq = res->start;
 
 	dev_set_drvdata(&pdev->dev, adata);
 	status = devm_snd_soc_register_component(&pdev->dev,
diff -ruN a/sound/soc/amd/renoir/acp3x-pdm-dma.c b/sound/soc/amd/renoir/acp3x-pdm-dma.c
--- a/sound/soc/amd/renoir/acp3x-pdm-dma.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/renoir/acp3x-pdm-dma.c	2022-07-08 01:12:12.000000000 +0200
@@ -77,6 +77,7 @@
 	u32 pdm_clk_enable, pdm_ctrl;
 
 	pdm_clk_enable = ACP_PDM_CLK_FREQ_MASK;
+	pdm_ctrl = 0x00;
 
 	rn_writel(pdm_clk_enable, acp_base + ACP_WOV_CLK_CTRL);
 	pdm_ctrl = rn_readl(acp_base + ACP_WOV_MISC_CTRL);
@@ -143,6 +144,9 @@
 	u32 pdm_enable, pdm_dma_enable;
 	int timeout;
 
+	pdm_enable = 0x00;
+	pdm_dma_enable  = 0x00;
+
 	pdm_enable = rn_readl(acp_base + ACP_WOV_PDM_ENABLE);
 	pdm_dma_enable = rn_readl(acp_base + ACP_WOV_PDM_DMA_ENABLE);
 	if (pdm_dma_enable & 0x01) {
@@ -291,6 +295,13 @@
 	return 0;
 }
 
+static int acp_pdm_dma_mmap(struct snd_soc_component *component,
+			    struct snd_pcm_substream *substream,
+			    struct vm_area_struct *vma)
+{
+	return snd_pcm_lib_default_mmap(substream, vma);
+}
+
 static int acp_pdm_dma_close(struct snd_soc_component *component,
 			     struct snd_pcm_substream *substream)
 {
@@ -363,13 +374,14 @@
 };
 
 static const struct snd_soc_component_driver acp_pdm_component = {
-	.name			= DRV_NAME,
-	.open			= acp_pdm_dma_open,
-	.close			= acp_pdm_dma_close,
-	.hw_params		= acp_pdm_dma_hw_params,
-	.pointer		= acp_pdm_dma_pointer,
-	.pcm_construct		= acp_pdm_dma_new,
-	.legacy_dai_naming	= 1,
+	.name		= DRV_NAME,
+	.open		= acp_pdm_dma_open,
+	.close		= acp_pdm_dma_close,
+	.hw_params	= acp_pdm_dma_hw_params,
+	.pointer	= acp_pdm_dma_pointer,
+	.mmap		= acp_pdm_dma_mmap,
+	.pcm_construct	= acp_pdm_dma_new,
+	.legacy_dai_naming	= 1,
 };
 
 static int acp_pdm_audio_probe(struct platform_device *pdev)
@@ -400,11 +411,13 @@
 	if (!adata->acp_base)
 		return -ENOMEM;
 
-	status = platform_get_irq(pdev, 0);
-	if (status < 0)
-		return status;
-	adata->pdm_irq = status;
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "IORESOURCE_IRQ FAILED\n");
+		return -ENODEV;
+	}
 
+	adata->pdm_irq = res->start;
 	adata->capture_stream = NULL;
 
 	dev_set_drvdata(&pdev->dev, adata);
diff -ruN a/sound/soc/amd/renoir/acp3x-rn.c b/sound/soc/amd/renoir/acp3x-rn.c
--- a/sound/soc/amd/renoir/acp3x-rn.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/renoir/acp3x-rn.c	2022-07-08 01:12:12.000000000 +0200
@@ -54,9 +54,10 @@
 	snd_soc_card_set_drvdata(card, machine);
 	ret = devm_snd_soc_register_card(&pdev->dev, card);
 	if (ret) {
-		return dev_err_probe(&pdev->dev, ret,
-				"snd_soc_register_card(%s) failed\n",
-				card->name);
+		dev_err(&pdev->dev,
+			"snd_soc_register_card(%s) failed: %d\n",
+			acp_card.name, ret);
+		return ret;
 	}
 	return 0;
 }
diff -ruN a/sound/soc/amd/renoir/rn_acp3x.h b/sound/soc/amd/renoir/rn_acp3x.h
--- a/sound/soc/amd/renoir/rn_acp3x.h	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/renoir/rn_acp3x.h	2022-07-08 01:12:12.000000000 +0200
@@ -88,6 +88,3 @@
 {
 	writel(val, base_addr - ACP_PHY_BASE_ADDRESS);
 }
-
-/* Machine configuration */
-int snd_amd_acp_find_config(struct pci_dev *pci);
diff -ruN a/sound/soc/amd/renoir/rn-pci-acp3x.c b/sound/soc/amd/renoir/rn-pci-acp3x.c
--- a/sound/soc/amd/renoir/rn-pci-acp3x.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/renoir/rn-pci-acp3x.c	2022-07-08 01:12:12.000000000 +0200
@@ -212,15 +212,10 @@
 	acpi_integer dmic_status;
 #endif
 	const struct dmi_system_id *dmi_id;
-	unsigned int irqflags, flag;
+	unsigned int irqflags;
 	int ret, index;
 	u32 addr;
 
-	/* Return if acp config flag is defined */
-	flag = snd_amd_acp_find_config(pci);
-	if (flag)
-		return -ENODEV;
-
 	/* Renoir device check */
 	if (pci->revision != 0x01)
 		return -ENODEV;
diff -ruN a/sound/soc/amd/vangogh/acp5x.h b/sound/soc/amd/vangogh/acp5x.h
--- a/sound/soc/amd/vangogh/acp5x.h	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/vangogh/acp5x.h	2022-07-08 01:12:12.000000000 +0200
@@ -23,7 +23,7 @@
 #define ACP_ERR_INTR_MASK	0x20000000
 #define ACP_EXT_INTR_STAT_CLEAR_MASK 0xFFFFFFFF
 
-#define ACP5x_DEVS 3
+#define ACP5x_DEVS 4
 #define	ACP5x_REG_START	0x1240000
 #define	ACP5x_REG_END	0x1250200
 #define ACP5x_I2STDM_REG_START	0x1242400
@@ -85,7 +85,7 @@
 struct i2s_dev_data {
 	bool tdm_mode;
 	bool master_mode;
-	int i2s_irq;
+	unsigned int i2s_irq;
 	u16 i2s_instance;
 	u32 tdm_fmt;
 	void __iomem *acp5x_base;
@@ -105,6 +105,8 @@
 	dma_addr_t dma_addr;
 	u64 bytescount;
 	void __iomem *acp5x_base;
+	u32 lrclk_div;
+	u32 bclk_div;
 };
 
 union acp_dma_count {
@@ -191,3 +193,30 @@
 	}
 	return byte_count.bytescount;
 }
+
+static inline void acp5x_i2s_set_mclk(struct i2s_dev_data *adata,
+				      struct i2s_stream_instance *rtd)
+{
+	union acp_i2stdm_mstrclkgen mclkgen;
+	u32 master_reg;
+
+	switch (rtd->i2s_instance) {
+	case I2S_HS_INSTANCE:
+		master_reg = ACP_I2STDM2_MSTRCLKGEN;
+		break;
+	case I2S_SP_INSTANCE:
+	default:
+		master_reg = ACP_I2STDM0_MSTRCLKGEN;
+		break;
+	}
+
+	mclkgen.bits.i2stdm_master_mode = 0x1;
+	if (adata->tdm_mode)
+		mclkgen.bits.i2stdm_format_mode = 0x01;
+	else
+		mclkgen.bits.i2stdm_format_mode = 0x00;
+
+	mclkgen.bits.i2stdm_bclk_div_val = rtd->bclk_div;
+	mclkgen.bits.i2stdm_lrclk_div_val = rtd->lrclk_div;
+	acp_writel(mclkgen.u32_all, rtd->acp5x_base + master_reg);
+}
diff -ruN a/sound/soc/amd/vangogh/acp5x-i2s.c b/sound/soc/amd/vangogh/acp5x-i2s.c
--- a/sound/soc/amd/vangogh/acp5x-i2s.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/vangogh/acp5x-i2s.c	2022-07-08 01:12:12.000000000 +0200
@@ -88,10 +88,9 @@
 	struct snd_soc_card *card;
 	struct acp5x_platform_info *pinfo;
 	struct i2s_dev_data *adata;
-	union acp_i2stdm_mstrclkgen mclkgen;
 
 	u32 val;
-	u32 reg_val, frmt_reg, master_reg;
+	u32 reg_val, frmt_reg;
 	u32 lrclk_div_val, bclk_div_val;
 
 	lrclk_div_val = 0;
@@ -160,20 +159,6 @@
 	acp_writel(val, rtd->acp5x_base + reg_val);
 
 	if (adata->master_mode) {
-		switch (rtd->i2s_instance) {
-		case I2S_HS_INSTANCE:
-			master_reg = ACP_I2STDM2_MSTRCLKGEN;
-			break;
-		case I2S_SP_INSTANCE:
-		default:
-			master_reg = ACP_I2STDM0_MSTRCLKGEN;
-			break;
-		}
-		mclkgen.bits.i2stdm_master_mode = 0x1;
-		if (adata->tdm_mode)
-			mclkgen.bits.i2stdm_format_mode = 0x01;
-		else
-			mclkgen.bits.i2stdm_format_mode = 0x0;
 		switch (params_format(params)) {
 		case SNDRV_PCM_FORMAT_S16_LE:
 			switch (params_rate(params)) {
@@ -238,9 +223,8 @@
 		default:
 			return -EINVAL;
 		}
-		mclkgen.bits.i2stdm_bclk_div_val = bclk_div_val;
-		mclkgen.bits.i2stdm_lrclk_div_val = lrclk_div_val;
-		acp_writel(mclkgen.u32_all, rtd->acp5x_base + master_reg);
+		rtd->lrclk_div = lrclk_div_val;
+		rtd->bclk_div = bclk_div_val;
 	}
 	return 0;
 }
@@ -249,9 +233,11 @@
 			     int cmd, struct snd_soc_dai *dai)
 {
 	struct i2s_stream_instance *rtd;
+	struct i2s_dev_data *adata;
 	u32 ret, val, period_bytes, reg_val, ier_val, water_val;
 	u32 buf_size, buf_reg;
 
+	adata = snd_soc_dai_get_drvdata(dai);
 	rtd = substream->runtime->private_data;
 	period_bytes = frames_to_bytes(substream->runtime,
 				       substream->runtime->period_size);
@@ -300,6 +286,8 @@
 		}
 		acp_writel(period_bytes, rtd->acp5x_base + water_val);
 		acp_writel(buf_size, rtd->acp5x_base + buf_reg);
+		if (adata->master_mode)
+			acp5x_i2s_set_mclk(adata, rtd);
 		val = acp_readl(rtd->acp5x_base + reg_val);
 		val = val | BIT(0);
 		acp_writel(val, rtd->acp5x_base + reg_val);
@@ -400,8 +387,8 @@
 	}
 	adata->acp5x_base = devm_ioremap(&pdev->dev, res->start,
 					 resource_size(res));
-	if (!adata->acp5x_base)
-		return -ENOMEM;
+	if (IS_ERR(adata->acp5x_base))
+		return PTR_ERR(adata->acp5x_base);
 
 	adata->master_mode = I2S_MASTER_MODE_ENABLE;
 	dev_set_drvdata(&pdev->dev, adata);
diff -ruN a/sound/soc/amd/vangogh/acp5x-mach.c b/sound/soc/amd/vangogh/acp5x-mach.c
--- a/sound/soc/amd/vangogh/acp5x-mach.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/vangogh/acp5x-mach.c	2022-07-08 01:12:12.000000000 +0200
@@ -243,7 +242,7 @@
 
 static struct snd_soc_dai_link acp5x_dai[] = {
 	{
-		.name = "acp5x-8821-play",
+		.name = "acp5x-8825-play",
 		.stream_name = "Playback/Capture",
 		.dai_fmt = SND_SOC_DAIFMT_I2S  | SND_SOC_DAIFMT_NB_NF |
 			   SND_SOC_DAIFMT_CBC_CFC,
@@ -291,7 +290,7 @@
 		ret = snd_soc_dai_set_sysclk(codec_dai, NAU8821_CLK_FLL_BLK, 0,
 					     SND_SOC_CLOCK_IN);
 		if (ret < 0)
-			dev_err(codec_dai->dev, "can't set BLK clock %d\n", ret);
+			dev_err(codec_dai->dev, "can't set FS clock %d\n", ret);
 		ret = snd_soc_dai_set_pll(codec_dai, 0, 0, ACP5X_NUVOTON_BCLK,
 					  ACP5X_NAU8821_FREQ_OUT);
 		if (ret < 0)
@@ -342,6 +341,7 @@
 	.num_controls = ARRAY_SIZE(acp5x_8821_controls),
 };
 
+
 static int acp5x_vg_quirk_cb(const struct dmi_system_id *id)
 {
 	acp5x_machine_id = VG_JUPITER;
@@ -371,7 +371,7 @@
 		return -ENOMEM;
 
 	dmi_check_system(acp5x_vg_quirk_table);
-	switch (acp5x_machine_id) {
+	switch(acp5x_machine_id) {
 	case VG_JUPITER:
 		card = &acp5x_card;
 		acp5x_card.dev = &pdev->dev;
diff -ruN a/sound/soc/amd/vangogh/acp5x-pcm-dma.c b/sound/soc/amd/vangogh/acp5x-pcm-dma.c
--- a/sound/soc/amd/vangogh/acp5x-pcm-dma.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/vangogh/acp5x-pcm-dma.c	2022-07-08 01:12:12.000000000 +0200
@@ -388,11 +388,13 @@
 	if (!adata->acp5x_base)
 		return -ENOMEM;
 
-	status = platform_get_irq(pdev, 0);
-	if (status < 0)
-		return status;
-	adata->i2s_irq = status;
+	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!res) {
+		dev_err(&pdev->dev, "IORESOURCE_IRQ FAILED\n");
+		return -ENODEV;
+	}
 
+	adata->i2s_irq = res->start;
 	dev_set_drvdata(&pdev->dev, adata);
 	status = devm_snd_soc_register_component(&pdev->dev,
 						 &acp5x_i2s_component,
@@ -425,8 +427,10 @@
 {
 	struct i2s_dev_data *adata;
 	struct i2s_stream_instance *rtd;
-	u32 val;
+	u32 val, reg_val, frmt_val;
 
+	reg_val = 0;
+	frmt_val = 0;
 	adata = dev_get_drvdata(dev);
 
 	if (adata->play_stream && adata->play_stream->runtime) {
diff -ruN a/sound/soc/amd/vangogh/Makefile b/sound/soc/amd/vangogh/Makefile
--- a/sound/soc/amd/vangogh/Makefile	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/vangogh/Makefile	2022-07-08 01:12:12.000000000 +0200
@@ -3,7 +3,9 @@
 snd-pci-acp5x-objs	:= pci-acp5x.o
 snd-acp5x-i2s-objs	:= acp5x-i2s.o
 snd-acp5x-pcm-dma-objs	:= acp5x-pcm-dma.o
+snd-soc-acp5x-mach-objs := acp5x-mach.o
 
 obj-$(CONFIG_SND_SOC_AMD_ACP5x) += snd-pci-acp5x.o
 obj-$(CONFIG_SND_SOC_AMD_ACP5x)	+= snd-acp5x-i2s.o
 obj-$(CONFIG_SND_SOC_AMD_ACP5x) += snd-acp5x-pcm-dma.o
+obj-$(CONFIG_SND_SOC_AMD_VANGOGH_MACH)   += snd-soc-acp5x-mach.o
diff -ruN a/sound/soc/amd/vangogh/pci-acp5x.c b/sound/soc/amd/vangogh/pci-acp5x.c
--- a/sound/soc/amd/vangogh/pci-acp5x.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/vangogh/pci-acp5x.c	2022-07-08 01:12:12.000000000 +0200
@@ -92,12 +92,14 @@
 		pr_err("ACP5x power on failed\n");
 		return ret;
 	}
+	acp_writel(0x01, acp5x_base + ACP_CONTROL);
 	/* Reset */
 	ret = acp5x_reset(acp5x_base);
 	if (ret) {
 		pr_err("ACP5x reset failed\n");
 		return ret;
 	}
+	acp_writel(0x03, acp5x_base + ACP_CLKMUX_SEL);
 	acp5x_enable_interrupts(acp5x_base);
 	return 0;
 }
@@ -113,6 +115,8 @@
 		pr_err("ACP5x reset failed\n");
 		return ret;
 	}
+	acp_writel(0x00, acp5x_base + ACP_CLKMUX_SEL);
+	acp_writel(0x00, acp5x_base + ACP_CONTROL);
 	return 0;
 }
 
@@ -213,6 +217,9 @@
 		pdevinfo[2].num_res = 1;
 		pdevinfo[2].res = &adata->res[2];
 
+		pdevinfo[3].name = "acp5x_mach";
+		pdevinfo[3].id = 0;
+		pdevinfo[3].parent = &pci->dev;
 		for (i = 0; i < ACP5x_DEVS; i++) {
 			adata->pdev[i] =
 				platform_device_register_full(&pdevinfo[i]);
diff -ruN a/sound/soc/amd/yc/acp6x.h b/sound/soc/amd/yc/acp6x.h
--- a/sound/soc/amd/yc/acp6x.h	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/yc/acp6x.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,107 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0+ */
-/*
- * AMD ALSA SoC PDM Driver
- *
- * Copyright (C) 2021 Advanced Micro Devices, Inc. All rights reserved.
- */
-
-#include "acp6x_chip_offset_byte.h"
-
-#define ACP_DEVICE_ID 0x15E2
-#define ACP6x_PHY_BASE_ADDRESS 0x1240000
-#define ACP6x_REG_START		0x1240000
-#define ACP6x_REG_END		0x1250200
-#define ACP6x_DEVS		3
-#define ACP6x_PDM_MODE		1
-
-#define ACP_SOFT_RESET_SOFTRESET_AUDDONE_MASK	0x00010001
-#define ACP_PGFSM_CNTL_POWER_ON_MASK	1
-#define ACP_PGFSM_CNTL_POWER_OFF_MASK	0
-#define ACP_PGFSM_STATUS_MASK		3
-#define ACP_POWERED_ON			0
-#define ACP_POWER_ON_IN_PROGRESS	1
-#define ACP_POWERED_OFF			2
-#define ACP_POWER_OFF_IN_PROGRESS	3
-
-#define ACP_ERROR_MASK 0x20000000
-#define ACP_EXT_INTR_STAT_CLEAR_MASK 0xFFFFFFFF
-#define PDM_DMA_STAT 0x10
-
-#define PDM_DMA_INTR_MASK	0x10000
-#define ACP_ERROR_STAT	29
-#define PDM_DECIMATION_FACTOR	2
-#define ACP_PDM_CLK_FREQ_MASK	7
-#define ACP_WOV_MISC_CTRL_MASK	0x10
-#define ACP_PDM_ENABLE		1
-#define ACP_PDM_DISABLE		0
-#define ACP_PDM_DMA_EN_STATUS	2
-#define TWO_CH		2
-#define DELAY_US	5
-#define ACP_COUNTER	20000
-
-#define ACP_SRAM_PTE_OFFSET	0x03800000
-#define PAGE_SIZE_4K_ENABLE	2
-#define PDM_PTE_OFFSET		0
-#define PDM_MEM_WINDOW_START	0x4000000
-
-#define CAPTURE_MIN_NUM_PERIODS     4
-#define CAPTURE_MAX_NUM_PERIODS     4
-#define CAPTURE_MAX_PERIOD_SIZE     8192
-#define CAPTURE_MIN_PERIOD_SIZE     4096
-
-#define MAX_BUFFER (CAPTURE_MAX_PERIOD_SIZE * CAPTURE_MAX_NUM_PERIODS)
-#define MIN_BUFFER MAX_BUFFER
-
-/* time in ms for runtime suspend delay */
-#define ACP_SUSPEND_DELAY_MS	2000
-
-enum acp_config {
-	ACP_CONFIG_0 = 0,
-	ACP_CONFIG_1,
-	ACP_CONFIG_2,
-	ACP_CONFIG_3,
-	ACP_CONFIG_4,
-	ACP_CONFIG_5,
-	ACP_CONFIG_6,
-	ACP_CONFIG_7,
-	ACP_CONFIG_8,
-	ACP_CONFIG_9,
-	ACP_CONFIG_10,
-	ACP_CONFIG_11,
-	ACP_CONFIG_12,
-	ACP_CONFIG_13,
-	ACP_CONFIG_14,
-	ACP_CONFIG_15,
-};
-
-struct pdm_dev_data {
-	u32 pdm_irq;
-	void __iomem *acp6x_base;
-	struct snd_pcm_substream *capture_stream;
-};
-
-struct pdm_stream_instance {
-	u16 num_pages;
-	u16 channels;
-	dma_addr_t dma_addr;
-	u64 bytescount;
-	void __iomem *acp6x_base;
-};
-
-union acp_pdm_dma_count {
-	struct {
-	u32 low;
-	u32 high;
-	} bcount;
-	u64 bytescount;
-};
-
-static inline u32 acp6x_readl(void __iomem *base_addr)
-{
-	return readl(base_addr - ACP6x_PHY_BASE_ADDRESS);
-}
-
-static inline void acp6x_writel(u32 val, void __iomem *base_addr)
-{
-	writel(val, base_addr - ACP6x_PHY_BASE_ADDRESS);
-}
diff -ruN a/sound/soc/amd/yc/acp6x-pdm-dma.c b/sound/soc/amd/yc/acp6x-pdm-dma.c
--- a/sound/soc/amd/yc/acp6x-pdm-dma.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/yc/acp6x-pdm-dma.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,392 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * AMD ALSA SoC Yellow Carp PDM Driver
- *
- * Copyright 2021 Advanced Micro Devices, Inc.
- */
-
-#include <linux/platform_device.h>
-#include <linux/module.h>
-#include <linux/err.h>
-#include <linux/io.h>
-#include <sound/pcm_params.h>
-#include <sound/soc.h>
-#include <sound/soc-dai.h>
-
-#include "acp6x.h"
-
-#define DRV_NAME "acp_yc_pdm_dma"
-
-static const struct snd_pcm_hardware acp6x_pdm_hardware_capture = {
-	.info = SNDRV_PCM_INFO_INTERLEAVED |
-		SNDRV_PCM_INFO_BLOCK_TRANSFER |
-		SNDRV_PCM_INFO_MMAP |
-		SNDRV_PCM_INFO_MMAP_VALID |
-		SNDRV_PCM_INFO_PAUSE | SNDRV_PCM_INFO_RESUME,
-	.formats = SNDRV_PCM_FMTBIT_S32_LE,
-	.channels_min = 2,
-	.channels_max = 2,
-	.rates = SNDRV_PCM_RATE_48000,
-	.rate_min = 48000,
-	.rate_max = 48000,
-	.buffer_bytes_max = CAPTURE_MAX_NUM_PERIODS * CAPTURE_MAX_PERIOD_SIZE,
-	.period_bytes_min = CAPTURE_MIN_PERIOD_SIZE,
-	.period_bytes_max = CAPTURE_MAX_PERIOD_SIZE,
-	.periods_min = CAPTURE_MIN_NUM_PERIODS,
-	.periods_max = CAPTURE_MAX_NUM_PERIODS,
-};
-
-static void acp6x_init_pdm_ring_buffer(u32 physical_addr, u32 buffer_size,
-				       u32 watermark_size, void __iomem *acp_base)
-{
-	acp6x_writel(physical_addr, acp_base + ACP_WOV_RX_RINGBUFADDR);
-	acp6x_writel(buffer_size, acp_base + ACP_WOV_RX_RINGBUFSIZE);
-	acp6x_writel(watermark_size, acp_base + ACP_WOV_RX_INTR_WATERMARK_SIZE);
-	acp6x_writel(0x01, acp_base + ACPAXI2AXI_ATU_CTRL);
-}
-
-static void acp6x_enable_pdm_clock(void __iomem *acp_base)
-{
-	u32 pdm_clk_enable, pdm_ctrl;
-
-	pdm_clk_enable = ACP_PDM_CLK_FREQ_MASK;
-	pdm_ctrl = 0x00;
-
-	acp6x_writel(pdm_clk_enable, acp_base + ACP_WOV_CLK_CTRL);
-	pdm_ctrl = acp6x_readl(acp_base + ACP_WOV_MISC_CTRL);
-	pdm_ctrl |= ACP_WOV_MISC_CTRL_MASK;
-	acp6x_writel(pdm_ctrl, acp_base + ACP_WOV_MISC_CTRL);
-}
-
-static void acp6x_enable_pdm_interrupts(void __iomem *acp_base)
-{
-	u32 ext_int_ctrl;
-
-	ext_int_ctrl = acp6x_readl(acp_base + ACP_EXTERNAL_INTR_CNTL);
-	ext_int_ctrl |= PDM_DMA_INTR_MASK;
-	acp6x_writel(ext_int_ctrl, acp_base + ACP_EXTERNAL_INTR_CNTL);
-}
-
-static void acp6x_disable_pdm_interrupts(void __iomem *acp_base)
-{
-	u32 ext_int_ctrl;
-
-	ext_int_ctrl = acp6x_readl(acp_base + ACP_EXTERNAL_INTR_CNTL);
-	ext_int_ctrl &= ~PDM_DMA_INTR_MASK;
-	acp6x_writel(ext_int_ctrl, acp_base + ACP_EXTERNAL_INTR_CNTL);
-}
-
-static bool acp6x_check_pdm_dma_status(void __iomem *acp_base)
-{
-	bool pdm_dma_status;
-	u32 pdm_enable, pdm_dma_enable;
-
-	pdm_dma_status = false;
-	pdm_enable = acp6x_readl(acp_base + ACP_WOV_PDM_ENABLE);
-	pdm_dma_enable = acp6x_readl(acp_base + ACP_WOV_PDM_DMA_ENABLE);
-	if ((pdm_enable & ACP_PDM_ENABLE) && (pdm_dma_enable & ACP_PDM_DMA_EN_STATUS))
-		pdm_dma_status = true;
-
-	return pdm_dma_status;
-}
-
-static int acp6x_start_pdm_dma(void __iomem *acp_base)
-{
-	u32 pdm_enable;
-	u32 pdm_dma_enable;
-	int timeout;
-
-	pdm_enable = 0x01;
-	pdm_dma_enable  = 0x01;
-
-	acp6x_enable_pdm_clock(acp_base);
-	acp6x_writel(pdm_enable, acp_base + ACP_WOV_PDM_ENABLE);
-	acp6x_writel(pdm_dma_enable, acp_base + ACP_WOV_PDM_DMA_ENABLE);
-	timeout = 0;
-	while (++timeout < ACP_COUNTER) {
-		pdm_dma_enable = acp6x_readl(acp_base + ACP_WOV_PDM_DMA_ENABLE);
-		if ((pdm_dma_enable & 0x02) == ACP_PDM_DMA_EN_STATUS)
-			return 0;
-		udelay(DELAY_US);
-	}
-	return -ETIMEDOUT;
-}
-
-static int acp6x_stop_pdm_dma(void __iomem *acp_base)
-{
-	u32 pdm_enable, pdm_dma_enable;
-	int timeout;
-
-	pdm_enable = 0x00;
-	pdm_dma_enable  = 0x00;
-
-	pdm_enable = acp6x_readl(acp_base + ACP_WOV_PDM_ENABLE);
-	pdm_dma_enable = acp6x_readl(acp_base + ACP_WOV_PDM_DMA_ENABLE);
-	if (pdm_dma_enable & 0x01) {
-		pdm_dma_enable = 0x02;
-		acp6x_writel(pdm_dma_enable, acp_base + ACP_WOV_PDM_DMA_ENABLE);
-		timeout = 0;
-		while (++timeout < ACP_COUNTER) {
-			pdm_dma_enable = acp6x_readl(acp_base + ACP_WOV_PDM_DMA_ENABLE);
-			if ((pdm_dma_enable & 0x02) == 0x00)
-				break;
-			udelay(DELAY_US);
-		}
-		if (timeout == ACP_COUNTER)
-			return -ETIMEDOUT;
-	}
-	if (pdm_enable == ACP_PDM_ENABLE) {
-		pdm_enable = ACP_PDM_DISABLE;
-		acp6x_writel(pdm_enable, acp_base + ACP_WOV_PDM_ENABLE);
-	}
-	acp6x_writel(0x01, acp_base + ACP_WOV_PDM_FIFO_FLUSH);
-	return 0;
-}
-
-static void acp6x_config_dma(struct pdm_stream_instance *rtd, int direction)
-{
-	u16 page_idx;
-	u32 low, high, val;
-	dma_addr_t addr;
-
-	addr = rtd->dma_addr;
-	val = PDM_PTE_OFFSET;
-
-	/* Group Enable */
-	acp6x_writel(ACP_SRAM_PTE_OFFSET | BIT(31), rtd->acp6x_base +
-		     ACPAXI2AXI_ATU_BASE_ADDR_GRP_1);
-	acp6x_writel(PAGE_SIZE_4K_ENABLE, rtd->acp6x_base +
-		     ACPAXI2AXI_ATU_PAGE_SIZE_GRP_1);
-	for (page_idx = 0; page_idx < rtd->num_pages; page_idx++) {
-		/* Load the low address of page int ACP SRAM through SRBM */
-		low = lower_32_bits(addr);
-		high = upper_32_bits(addr);
-
-		acp6x_writel(low, rtd->acp6x_base + ACP_SCRATCH_REG_0 + val);
-		high |= BIT(31);
-		acp6x_writel(high, rtd->acp6x_base + ACP_SCRATCH_REG_0 + val + 4);
-		val += 8;
-		addr += PAGE_SIZE;
-	}
-}
-
-static int acp6x_pdm_dma_open(struct snd_soc_component *component,
-			      struct snd_pcm_substream *substream)
-{
-	struct snd_pcm_runtime *runtime;
-	struct pdm_dev_data *adata;
-	struct pdm_stream_instance *pdm_data;
-	int ret;
-
-	runtime = substream->runtime;
-	adata = dev_get_drvdata(component->dev);
-	pdm_data = kzalloc(sizeof(*pdm_data), GFP_KERNEL);
-	if (!pdm_data)
-		return -EINVAL;
-
-	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-		runtime->hw = acp6x_pdm_hardware_capture;
-
-	ret = snd_pcm_hw_constraint_integer(runtime,
-					    SNDRV_PCM_HW_PARAM_PERIODS);
-	if (ret < 0) {
-		dev_err(component->dev, "set integer constraint failed\n");
-		kfree(pdm_data);
-		return ret;
-	}
-
-	acp6x_enable_pdm_interrupts(adata->acp6x_base);
-
-	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
-		adata->capture_stream = substream;
-
-	pdm_data->acp6x_base = adata->acp6x_base;
-	runtime->private_data = pdm_data;
-	return ret;
-}
-
-static int acp6x_pdm_dma_hw_params(struct snd_soc_component *component,
-				   struct snd_pcm_substream *substream,
-				   struct snd_pcm_hw_params *params)
-{
-	struct pdm_stream_instance *rtd;
-	size_t size, period_bytes;
-
-	rtd = substream->runtime->private_data;
-	if (!rtd)
-		return -EINVAL;
-	size = params_buffer_bytes(params);
-	period_bytes = params_period_bytes(params);
-	rtd->dma_addr = substream->runtime->dma_addr;
-	rtd->num_pages = (PAGE_ALIGN(size) >> PAGE_SHIFT);
-	acp6x_config_dma(rtd, substream->stream);
-	acp6x_init_pdm_ring_buffer(PDM_MEM_WINDOW_START, size,
-				   period_bytes, rtd->acp6x_base);
-	return 0;
-}
-
-static u64 acp6x_pdm_get_byte_count(struct pdm_stream_instance *rtd,
-				    int direction)
-{
-	union acp_pdm_dma_count byte_count;
-
-	byte_count.bcount.high =
-			acp6x_readl(rtd->acp6x_base + ACP_WOV_RX_LINEARPOSITIONCNTR_HIGH);
-	byte_count.bcount.low =
-			acp6x_readl(rtd->acp6x_base + ACP_WOV_RX_LINEARPOSITIONCNTR_LOW);
-	return byte_count.bytescount;
-}
-
-static snd_pcm_uframes_t acp6x_pdm_dma_pointer(struct snd_soc_component *comp,
-					       struct snd_pcm_substream *stream)
-{
-	struct pdm_stream_instance *rtd;
-	u32 pos, buffersize;
-	u64 bytescount;
-
-	rtd = stream->runtime->private_data;
-	buffersize = frames_to_bytes(stream->runtime,
-				     stream->runtime->buffer_size);
-	bytescount = acp6x_pdm_get_byte_count(rtd, stream->stream);
-	if (bytescount > rtd->bytescount)
-		bytescount -= rtd->bytescount;
-	pos = do_div(bytescount, buffersize);
-	return bytes_to_frames(stream->runtime, pos);
-}
-
-static int acp6x_pdm_dma_new(struct snd_soc_component *component,
-			     struct snd_soc_pcm_runtime *rtd)
-{
-	struct device *parent = component->dev->parent;
-
-	snd_pcm_set_managed_buffer_all(rtd->pcm, SNDRV_DMA_TYPE_DEV,
-				       parent, MIN_BUFFER, MAX_BUFFER);
-	return 0;
-}
-
-static int acp6x_pdm_dma_close(struct snd_soc_component *component,
-			       struct snd_pcm_substream *substream)
-{
-	struct pdm_dev_data *adata = dev_get_drvdata(component->dev);
-
-	acp6x_disable_pdm_interrupts(adata->acp6x_base);
-	adata->capture_stream = NULL;
-	return 0;
-}
-
-static int acp6x_pdm_dai_trigger(struct snd_pcm_substream *substream,
-				 int cmd, struct snd_soc_dai *dai)
-{
-	struct pdm_stream_instance *rtd;
-	int ret;
-	bool pdm_status;
-	unsigned int ch_mask;
-
-	rtd = substream->runtime->private_data;
-	ret = 0;
-	switch (substream->runtime->channels) {
-	case TWO_CH:
-		ch_mask = 0x00;
-		break;
-	default:
-		return -EINVAL;
-	}
-	switch (cmd) {
-	case SNDRV_PCM_TRIGGER_START:
-	case SNDRV_PCM_TRIGGER_RESUME:
-	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
-		acp6x_writel(ch_mask, rtd->acp6x_base + ACP_WOV_PDM_NO_OF_CHANNELS);
-		acp6x_writel(PDM_DECIMATION_FACTOR, rtd->acp6x_base +
-			     ACP_WOV_PDM_DECIMATION_FACTOR);
-		rtd->bytescount = acp6x_pdm_get_byte_count(rtd, substream->stream);
-		pdm_status = acp6x_check_pdm_dma_status(rtd->acp6x_base);
-		if (!pdm_status)
-			ret = acp6x_start_pdm_dma(rtd->acp6x_base);
-		break;
-	case SNDRV_PCM_TRIGGER_STOP:
-	case SNDRV_PCM_TRIGGER_SUSPEND:
-	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
-		pdm_status = acp6x_check_pdm_dma_status(rtd->acp6x_base);
-		if (pdm_status)
-			ret = acp6x_stop_pdm_dma(rtd->acp6x_base);
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-	return ret;
-}
-
-static struct snd_soc_dai_ops acp6x_pdm_dai_ops = {
-	.trigger   = acp6x_pdm_dai_trigger,
-};
-
-static struct snd_soc_dai_driver acp6x_pdm_dai_driver = {
-	.capture = {
-		.rates = SNDRV_PCM_RATE_48000,
-		.formats = SNDRV_PCM_FMTBIT_S32_LE,
-		.channels_min = 2,
-		.channels_max = 2,
-		.rate_min = 48000,
-		.rate_max = 48000,
-	},
-	.ops = &acp6x_pdm_dai_ops,
-};
-
-static const struct snd_soc_component_driver acp6x_pdm_component = {
-	.name			= DRV_NAME,
-	.open			= acp6x_pdm_dma_open,
-	.close			= acp6x_pdm_dma_close,
-	.hw_params		= acp6x_pdm_dma_hw_params,
-	.pointer		= acp6x_pdm_dma_pointer,
-	.pcm_construct		= acp6x_pdm_dma_new,
-	.legacy_dai_naming	= 1,
-};
-
-static int acp6x_pdm_audio_probe(struct platform_device *pdev)
-{
-	struct resource *res;
-	struct pdm_dev_data *adata;
-	int status;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		dev_err(&pdev->dev, "IORESOURCE_MEM FAILED\n");
-		return -ENODEV;
-	}
-
-	adata = devm_kzalloc(&pdev->dev, sizeof(*adata), GFP_KERNEL);
-	if (!adata)
-		return -ENOMEM;
-
-	adata->acp6x_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
-	if (!adata->acp6x_base)
-		return -ENOMEM;
-
-	adata->capture_stream = NULL;
-
-	dev_set_drvdata(&pdev->dev, adata);
-	status = devm_snd_soc_register_component(&pdev->dev,
-						 &acp6x_pdm_component,
-						 &acp6x_pdm_dai_driver, 1);
-	if (status) {
-		dev_err(&pdev->dev, "Fail to register acp pdm dai\n");
-
-		return -ENODEV;
-	}
-	return 0;
-}
-
-static struct platform_driver acp6x_pdm_dma_driver = {
-	.probe = acp6x_pdm_audio_probe,
-	.driver = {
-		.name = "acp_yc_pdm_dma",
-	},
-};
-
-module_platform_driver(acp6x_pdm_dma_driver);
-
-MODULE_AUTHOR("Vijendar.Mukunda@amd.com");
-MODULE_DESCRIPTION("AMD ACP6x YC PDM Driver");
-MODULE_LICENSE("GPL v2");
-MODULE_ALIAS("platform:" DRV_NAME);
diff -ruN a/sound/soc/amd/yc/pci-acp6x.c b/sound/soc/amd/yc/pci-acp6x.c
--- a/sound/soc/amd/yc/pci-acp6x.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/amd/yc/pci-acp6x.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,344 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0+
-/*
- * AMD Yellow Carp ACP PCI Driver
- *
- * Copyright 2021 Advanced Micro Devices, Inc.
- */
-
-#include <linux/pci.h>
-#include <linux/module.h>
-#include <linux/io.h>
-#include <linux/delay.h>
-#include <linux/platform_device.h>
-#include <linux/interrupt.h>
-#include <sound/pcm_params.h>
-#include <linux/pm_runtime.h>
-
-#include "acp6x.h"
-
-struct acp6x_dev_data {
-	void __iomem *acp6x_base;
-	struct resource *res;
-	bool acp6x_audio_mode;
-	struct platform_device *pdev[ACP6x_DEVS];
-};
-
-static int acp6x_power_on(void __iomem *acp_base)
-{
-	u32 val;
-	int timeout;
-
-	val = acp6x_readl(acp_base + ACP_PGFSM_STATUS);
-
-	if (!val)
-		return val;
-
-	if ((val & ACP_PGFSM_STATUS_MASK) != ACP_POWER_ON_IN_PROGRESS)
-		acp6x_writel(ACP_PGFSM_CNTL_POWER_ON_MASK, acp_base + ACP_PGFSM_CONTROL);
-	timeout = 0;
-	while (++timeout < 500) {
-		val = acp6x_readl(acp_base + ACP_PGFSM_STATUS);
-		if (!val)
-			return 0;
-		udelay(1);
-	}
-	return -ETIMEDOUT;
-}
-
-static int acp6x_reset(void __iomem *acp_base)
-{
-	u32 val;
-	int timeout;
-
-	acp6x_writel(1, acp_base + ACP_SOFT_RESET);
-	timeout = 0;
-	while (++timeout < 500) {
-		val = acp6x_readl(acp_base + ACP_SOFT_RESET);
-		if (val & ACP_SOFT_RESET_SOFTRESET_AUDDONE_MASK)
-			break;
-		cpu_relax();
-	}
-	acp6x_writel(0, acp_base + ACP_SOFT_RESET);
-	timeout = 0;
-	while (++timeout < 500) {
-		val = acp6x_readl(acp_base + ACP_SOFT_RESET);
-		if (!val)
-			return 0;
-		cpu_relax();
-	}
-	return -ETIMEDOUT;
-}
-
-static void acp6x_enable_interrupts(void __iomem *acp_base)
-{
-	acp6x_writel(0x01, acp_base + ACP_EXTERNAL_INTR_ENB);
-}
-
-static void acp6x_disable_interrupts(void __iomem *acp_base)
-{
-	acp6x_writel(ACP_EXT_INTR_STAT_CLEAR_MASK, acp_base +
-		     ACP_EXTERNAL_INTR_STAT);
-	acp6x_writel(0x00, acp_base + ACP_EXTERNAL_INTR_CNTL);
-	acp6x_writel(0x00, acp_base + ACP_EXTERNAL_INTR_ENB);
-}
-
-static int acp6x_init(void __iomem *acp_base)
-{
-	int ret;
-
-	/* power on */
-	ret = acp6x_power_on(acp_base);
-	if (ret) {
-		pr_err("ACP power on failed\n");
-		return ret;
-	}
-	acp6x_writel(0x01, acp_base + ACP_CONTROL);
-	/* Reset */
-	ret = acp6x_reset(acp_base);
-	if (ret) {
-		pr_err("ACP reset failed\n");
-		return ret;
-	}
-	acp6x_writel(0x03, acp_base + ACP_CLKMUX_SEL);
-	acp6x_enable_interrupts(acp_base);
-	return 0;
-}
-
-static int acp6x_deinit(void __iomem *acp_base)
-{
-	int ret;
-
-	acp6x_disable_interrupts(acp_base);
-	/* Reset */
-	ret = acp6x_reset(acp_base);
-	if (ret) {
-		pr_err("ACP reset failed\n");
-		return ret;
-	}
-	acp6x_writel(0x00, acp_base + ACP_CLKMUX_SEL);
-	acp6x_writel(0x00, acp_base + ACP_CONTROL);
-	return 0;
-}
-
-static irqreturn_t acp6x_irq_handler(int irq, void *dev_id)
-{
-	struct acp6x_dev_data *adata;
-	struct pdm_dev_data *yc_pdm_data;
-	u32 val;
-
-	adata = dev_id;
-	if (!adata)
-		return IRQ_NONE;
-
-	val = acp6x_readl(adata->acp6x_base + ACP_EXTERNAL_INTR_STAT);
-	if (val & BIT(PDM_DMA_STAT)) {
-		yc_pdm_data = dev_get_drvdata(&adata->pdev[0]->dev);
-		acp6x_writel(BIT(PDM_DMA_STAT), adata->acp6x_base + ACP_EXTERNAL_INTR_STAT);
-		if (yc_pdm_data->capture_stream)
-			snd_pcm_period_elapsed(yc_pdm_data->capture_stream);
-		return IRQ_HANDLED;
-	}
-	return IRQ_NONE;
-}
-
-static int snd_acp6x_probe(struct pci_dev *pci,
-			   const struct pci_device_id *pci_id)
-{
-	struct acp6x_dev_data *adata;
-	struct platform_device_info pdevinfo[ACP6x_DEVS];
-	int index = 0;
-	int val = 0x00;
-	u32 addr;
-	unsigned int irqflags;
-	int ret;
-
-	irqflags = IRQF_SHARED;
-	/* Yellow Carp device check */
-	switch (pci->revision) {
-	case 0x60:
-	case 0x6f:
-		break;
-	default:
-		dev_dbg(&pci->dev, "acp6x pci device not found\n");
-		return -ENODEV;
-	}
-	if (pci_enable_device(pci)) {
-		dev_err(&pci->dev, "pci_enable_device failed\n");
-		return -ENODEV;
-	}
-
-	ret = pci_request_regions(pci, "AMD ACP3x audio");
-	if (ret < 0) {
-		dev_err(&pci->dev, "pci_request_regions failed\n");
-		goto disable_pci;
-	}
-
-	adata = devm_kzalloc(&pci->dev, sizeof(struct acp6x_dev_data),
-			     GFP_KERNEL);
-	if (!adata) {
-		ret = -ENOMEM;
-		goto release_regions;
-	}
-
-	addr = pci_resource_start(pci, 0);
-	adata->acp6x_base = devm_ioremap(&pci->dev, addr,
-					 pci_resource_len(pci, 0));
-	if (!adata->acp6x_base) {
-		ret = -ENOMEM;
-		goto release_regions;
-	}
-	pci_set_master(pci);
-	pci_set_drvdata(pci, adata);
-	ret = acp6x_init(adata->acp6x_base);
-	if (ret)
-		goto release_regions;
-	val = acp6x_readl(adata->acp6x_base + ACP_PIN_CONFIG);
-	switch (val) {
-	case ACP_CONFIG_0:
-	case ACP_CONFIG_1:
-	case ACP_CONFIG_2:
-	case ACP_CONFIG_3:
-	case ACP_CONFIG_9:
-	case ACP_CONFIG_15:
-		dev_info(&pci->dev, "Audio Mode %d\n", val);
-		break;
-	default:
-		adata->res = devm_kzalloc(&pci->dev,
-					  sizeof(struct resource),
-					  GFP_KERNEL);
-		if (!adata->res) {
-			ret = -ENOMEM;
-			goto de_init;
-		}
-
-		adata->res->name = "acp_iomem";
-		adata->res->flags = IORESOURCE_MEM;
-		adata->res->start = addr;
-		adata->res->end = addr + (ACP6x_REG_END - ACP6x_REG_START);
-
-		adata->acp6x_audio_mode = ACP6x_PDM_MODE;
-
-		memset(&pdevinfo, 0, sizeof(pdevinfo));
-		pdevinfo[0].name = "acp_yc_pdm_dma";
-		pdevinfo[0].id = 0;
-		pdevinfo[0].parent = &pci->dev;
-		pdevinfo[0].num_res = 1;
-		pdevinfo[0].res = adata->res;
-
-		pdevinfo[1].name = "dmic-codec";
-		pdevinfo[1].id = 0;
-		pdevinfo[1].parent = &pci->dev;
-
-		pdevinfo[2].name = "acp_yc_mach";
-		pdevinfo[2].id = 0;
-		pdevinfo[2].parent = &pci->dev;
-
-		for (index = 0; index < ACP6x_DEVS; index++) {
-			adata->pdev[index] =
-				platform_device_register_full(&pdevinfo[index]);
-			if (IS_ERR(adata->pdev[index])) {
-				dev_err(&pci->dev, "cannot register %s device\n",
-					pdevinfo[index].name);
-				ret = PTR_ERR(adata->pdev[index]);
-				goto unregister_devs;
-			}
-		}
-		break;
-	}
-	ret = devm_request_irq(&pci->dev, pci->irq, acp6x_irq_handler,
-			       irqflags, "ACP_PCI_IRQ", adata);
-	if (ret) {
-		dev_err(&pci->dev, "ACP PCI IRQ request failed\n");
-		goto unregister_devs;
-	}
-	pm_runtime_set_autosuspend_delay(&pci->dev, ACP_SUSPEND_DELAY_MS);
-	pm_runtime_use_autosuspend(&pci->dev);
-	pm_runtime_put_noidle(&pci->dev);
-	pm_runtime_allow(&pci->dev);
-
-	return 0;
-unregister_devs:
-	for (--index; index >= 0; index--)
-		platform_device_unregister(adata->pdev[index]);
-de_init:
-	if (acp6x_deinit(adata->acp6x_base))
-		dev_err(&pci->dev, "ACP de-init failed\n");
-release_regions:
-	pci_release_regions(pci);
-disable_pci:
-	pci_disable_device(pci);
-
-	return ret;
-}
-
-static int __maybe_unused snd_acp6x_suspend(struct device *dev)
-{
-	struct acp6x_dev_data *adata;
-	int ret;
-
-	adata = dev_get_drvdata(dev);
-	ret = acp6x_deinit(adata->acp6x_base);
-	if (ret)
-		dev_err(dev, "ACP de-init failed\n");
-	return ret;
-}
-
-static int __maybe_unused snd_acp6x_resume(struct device *dev)
-{
-	struct acp6x_dev_data *adata;
-	int ret;
-
-	adata = dev_get_drvdata(dev);
-	ret = acp6x_init(adata->acp6x_base);
-	if (ret)
-		dev_err(dev, "ACP init failed\n");
-	return ret;
-}
-
-static const struct dev_pm_ops acp6x_pm = {
-	SET_RUNTIME_PM_OPS(snd_acp6x_suspend, snd_acp6x_resume, NULL)
-	SET_SYSTEM_SLEEP_PM_OPS(snd_acp6x_suspend, snd_acp6x_resume)
-};
-
-static void snd_acp6x_remove(struct pci_dev *pci)
-{
-	struct acp6x_dev_data *adata;
-	int ret, index;
-
-	adata = pci_get_drvdata(pci);
-	if (adata->acp6x_audio_mode == ACP6x_PDM_MODE) {
-		for (index = 0; index < ACP6x_DEVS; index++)
-			platform_device_unregister(adata->pdev[index]);
-	}
-	ret = acp6x_deinit(adata->acp6x_base);
-	if (ret)
-		dev_err(&pci->dev, "ACP de-init failed\n");
-	pm_runtime_forbid(&pci->dev);
-	pm_runtime_get_noresume(&pci->dev);
-	pci_release_regions(pci);
-	pci_disable_device(pci);
-}
-
-static const struct pci_device_id snd_acp6x_ids[] = {
-	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, ACP_DEVICE_ID),
-	.class = PCI_CLASS_MULTIMEDIA_OTHER << 8,
-	.class_mask = 0xffffff },
-	{ 0, },
-};
-MODULE_DEVICE_TABLE(pci, snd_acp6x_ids);
-
-static struct pci_driver yc_acp6x_driver  = {
-	.name = KBUILD_MODNAME,
-	.id_table = snd_acp6x_ids,
-	.probe = snd_acp6x_probe,
-	.remove = snd_acp6x_remove,
-	.driver = {
-		.pm = &acp6x_pm,
-	}
-};
-
-module_pci_driver(yc_acp6x_driver);
-
-MODULE_AUTHOR("Vijendar.Mukunda@amd.com");
-MODULE_DESCRIPTION("AMD ACP Yellow Carp PCI driver");
-MODULE_LICENSE("GPL v2");
diff -ruN a/sound/soc/codecs/cs35l41.c b/sound/soc/codecs/cs35l41.c
--- a/sound/soc/codecs/cs35l41.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/codecs/cs35l41.c	2022-07-08 01:12:12.000000000 +0200
@@ -1,31 +1,53 @@
 // SPDX-License-Identifier: GPL-2.0
-//
-// cs35l41.c -- CS35l41 ALSA SoC audio driver
-//
-// Copyright 2017-2021 Cirrus Logic, Inc.
-//
-// Author: David Rhodes <david.rhodes@cirrus.com>
 
-#include <linux/acpi.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
+/*
+ * cs35l41.c -- CS35l41 ALSA SoC audio driver
+ *
+ * Copyright 2017-2020 Cirrus Logic, Inc.
+ *
+ * Author:	David Rhodes	<david.rhodes@cirrus.com>
+ *		Brian Austin	<brian.austin@cirrus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
 #include <linux/module.h>
 #include <linux/moduleparam.h>
-#include <linux/of_device.h>
-#include <linux/pm_runtime.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/gpio/consumer.h>
+#include <linux/regmap.h>
 #include <linux/property.h>
-#include <sound/initval.h>
+#include <linux/of_device.h>
+#include <sound/core.h>
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
+#include <linux/gpio.h>
+#include <sound/initval.h>
 #include <sound/tlv.h>
+#include <linux/completion.h>
+#include <linux/err.h>
+#include <linux/firmware.h>
+#include <linux/timekeeping.h>
 
+#include "wm_adsp.h"
 #include "cs35l41.h"
+#include <sound/cs35l41.h>
+#include "cs35l41_dsp_events.h"
 
-static const char * const cs35l41_supplies[CS35L41_NUM_SUPPLIES] = {
+static const char * const cs35l41_supplies[] = {
 	"VA",
 	"VP",
 };
@@ -152,6 +174,29 @@
 	{ 6144000,	16,	24 },
 };
 
+static const unsigned char cs35l41_bst_k1_table[4][5] = {
+	{0x24, 0x32, 0x32, 0x4F, 0x57},
+	{0x24, 0x32, 0x32, 0x4F, 0x57},
+	{0x40, 0x32, 0x32, 0x4F, 0x57},
+	{0x40, 0x32, 0x32, 0x4F, 0x57}
+};
+
+static const unsigned char cs35l41_bst_k2_table[4][5] = {
+	{0x24, 0x49, 0x66, 0xA3, 0xEA},
+	{0x24, 0x49, 0x66, 0xA3, 0xEA},
+	{0x48, 0x49, 0x66, 0xA3, 0xEA},
+	{0x48, 0x49, 0x66, 0xA3, 0xEA}
+};
+
+static const unsigned char cs35l41_bst_slope_table[4] = {
+					0x75, 0x6B, 0x3B, 0x28};
+
+static int cs35l41_enter_hibernate(struct cs35l41_private *cs35l41);
+static int cs35l41_exit_hibernate(struct cs35l41_private *cs35l41);
+static int cs35l41_restore(struct cs35l41_private *cs35l41);
+static int cs35l41_set_cspl_mbox_cmd(struct cs35l41_private *cs35l41,
+				   enum cs35l41_cspl_mbox_cmd cmd);
+
 static int cs35l41_get_fs_mon_config_index(int freq)
 {
 	int i;
@@ -164,207 +209,1540 @@
 	return -EINVAL;
 }
 
+static int cs35l41_dsp_power_ev(struct snd_soc_dapm_widget *w,
+		       struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_component *component =
+		snd_soc_dapm_to_component(w->dapm);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		dev_dbg(cs35l41->dev, "dsp_power_ev PMU\n");
+		wm_adsp_early_event(w, kcontrol, event);
+		wm_adsp_event(w, kcontrol, SND_SOC_DAPM_POST_PMU);
+
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		dev_dbg(cs35l41->dev, "dsp_power_ev attempting DSP unload\n");
+		cancel_delayed_work(&cs35l41->hb_work);
+		mutex_lock(&cs35l41->hb_lock);
+		cs35l41_exit_hibernate(cs35l41);
+		mutex_unlock(&cs35l41->hb_lock);
+
+		if (cs35l41->amp_hibernate !=
+					CS35L41_HIBERNATE_INCOMPATIBLE)
+			cs35l41->amp_hibernate =
+						CS35L41_HIBERNATE_NOT_LOADED;
+
+		wm_adsp_event(w, kcontrol, event);
+		wm_adsp_early_event(w, kcontrol, event);
+
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+
+static int cs35l41_dsp_load_ev(struct snd_soc_dapm_widget *w,
+		       struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_component *component =
+		snd_soc_dapm_to_component(w->dapm);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+	enum cs35l41_cspl_mbox_cmd mboxcmd = CSPL_MBOX_CMD_NONE;
+	enum cs35l41_cspl_mbox_status fw_status = CSPL_MBOX_STS_RUNNING;
+	int ret = 0;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+
+		if (cs35l41->dsp.running) {
+			regmap_read(cs35l41->regmap, CS35L41_DSP_MBOX_2,
+				    (unsigned int *)&fw_status);
+			switch (fw_status) {
+			case CSPL_MBOX_STS_RDY_FOR_REINIT:
+				mboxcmd = CSPL_MBOX_CMD_REINIT;
+				break;
+			case CSPL_MBOX_STS_PAUSED:
+				mboxcmd = CSPL_MBOX_CMD_RESUME;
+				break;
+			case CSPL_MBOX_STS_RUNNING:
+				/*
+				 * First time playing audio
+				 * means fw_status is running
+				 */
+				mboxcmd = CSPL_MBOX_CMD_RESUME;
+				break;
+			default:
+				dev_err(cs35l41->dev,
+					"Firmware status is invalid(%u)\n",
+					fw_status);
+				break;
+			}
+			ret = cs35l41_set_cspl_mbox_cmd(cs35l41, mboxcmd);
+		}
+		cs35l41->enabled = true;
+		break;
+	default:
+		break;
+	}
+
+	return 0;
+}
+
+static int cs35l41_halo_booted_get(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = cs35l41->halo_booted;
+
+	return 0;
+}
+
+static int cs35l41_halo_booted_put(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+
+	cs35l41->halo_booted = ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+static int cs35l41_force_int_get(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = cs35l41->force_int;
+
+	return 0;
+}
+
+static int cs35l41_force_int_put(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+	bool force_int_changed = (cs35l41->force_int !=
+		(bool)ucontrol->value.integer.value[0]);
+
+	mutex_lock(&cs35l41->force_int_lock);
+
+	cs35l41->force_int = ucontrol->value.integer.value[0];
+
+	if (force_int_changed) {
+		if (cs35l41->force_int) {
+			disable_irq(cs35l41->irq);
+			regmap_write(cs35l41->regmap, CS35L41_IRQ1_MASK1,
+					CS35L41_INT1_MASK_FORCE);
+			regmap_write(cs35l41->regmap, CS35L41_IRQ1_FRC1, 1);
+		} else {
+			regmap_write(cs35l41->regmap, CS35L41_IRQ1_FRC1, 0);
+			regmap_write(cs35l41->regmap, CS35L41_IRQ1_MASK1,
+					CS35L41_INT1_MASK_DEFAULT);
+			regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS1, 1);
+			enable_irq(cs35l41->irq);
+		}
+	}
+
+	mutex_unlock(&cs35l41->force_int_lock);
+
+	return 0;
+}
+
+static int cs35l41_amp_reset_get(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	return 0;
+}
+
+static int cs35l41_amp_reset_put(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+	struct snd_soc_dapm_context *dapm =
+		snd_soc_component_get_dapm(component);
+	int ret, retries, timeout = 100;
+	u32 status;
+
+	if (!ucontrol->value.integer.value[0])
+		return 0;
+
+	dev_info(cs35l41->dev, "AMP reset requested\n");
+
+	if (!cs35l41->reset_gpio) {
+		dev_info(cs35l41->dev, "Reset GPIO is not configured\n");
+		return 0;
+	}
+
+	disable_irq(cs35l41->irq);
+	cs35l41->halo_booted = false;
+
+	/* invalidate all cached values which have now been reset */
+	regcache_cache_only(cs35l41->regmap, true);
+	regcache_mark_dirty(cs35l41->regmap);
+
+	/* Toggle reset pin */
+	gpiod_set_value_cansleep(cs35l41->reset_gpio, 0);
+	/* satisfy minimum reset pulse width spec */
+	usleep_range(2000, 2100);
+	gpiod_set_value_cansleep(cs35l41->reset_gpio, 1);
+	usleep_range(2000, 2100);
+
+	regcache_cache_only(cs35l41->regmap, false);
+
+	do {
+		if (timeout == 0) {
+			dev_err(cs35l41->dev,
+				"Timeout waiting for OTP_BOOT_DONE\n");
+			return -EBUSY;
+		}
+		usleep_range(1000, 1100);
+		regmap_read(cs35l41->regmap, CS35L41_IRQ1_STATUS4, &status);
+		timeout--;
+	} while (!(status & CS35L41_OTP_BOOT_DONE));
+
+	/* Sync regmap */
+	regcache_sync(cs35l41->regmap);
+
+	/* Reset DSP */
+	regmap_update_bits(cs35l41->regmap, CS35L41_DSP_CLK_CTRL,
+			0x3, 0x2);
+	regmap_update_bits(cs35l41->regmap,
+			CS35L41_DSP1_CCM_CORE_CTRL,
+			CS35L41_HALO_CORE_RESET, CS35L41_HALO_CORE_RESET);
+	regmap_update_bits(cs35l41->regmap, CS35L41_DSP_CLK_CTRL,
+			0x3, 0x3);
+
+	/* Restore OTP and cached values */
+	retries = 5;
+	do {
+		dev_info(cs35l41->dev, "cs35l41_restore attempt %d\n",
+		 6 - retries);
+		ret = cs35l41_restore(cs35l41);
+		usleep_range(4000, 5000);
+	} while (ret < 0 && --retries > 0);
+
+	enable_irq(cs35l41->irq);
+
+	if (retries < 0) {
+		dev_err(cs35l41->dev, "Failed to reset AMP\n");
+		return 0;
+	}
+
+	dev_dbg(cs35l41->dev, "cs35l41 restored in %d attempts\n",
+			6 - retries);
+
+	if (cs35l41->dsp.preloaded) {
+		dev_info(cs35l41->dev, "Reload DSP\n");
+		snd_soc_component_disable_pin(component, "DSP1 Preload");
+		snd_soc_dapm_sync(dapm);
+		usleep_range(4000, 5000);
+		snd_soc_component_force_enable_pin(component, "DSP1 Preload");
+		snd_soc_dapm_sync(dapm);
+		flush_work(&cs35l41->dsp.boot_work);
+	}
+	return 0;
+}
+
+static int cs35l41_ccm_reset_get(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	return 0;
+}
+
+static int cs35l41_ccm_reset_put(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+	unsigned int val = 0;
+	int ret = 0;
+
+	val = ucontrol->value.integer.value[0];
+
+	if (val) {
+		ret = regmap_update_bits(cs35l41->regmap, CS35L41_DSP_CLK_CTRL,
+			0x3, 0x2);
+		ret = regmap_update_bits(cs35l41->regmap,
+			CS35L41_DSP1_CCM_CORE_CTRL,
+			CS35L41_HALO_CORE_RESET, CS35L41_HALO_CORE_RESET);
+		ret = regmap_update_bits(cs35l41->regmap, CS35L41_DSP_CLK_CTRL,
+			0x3, 0x3);
+	}
+
+	return 0;
+}
+
+static int cs35l41_hibernate_force_wake_get(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = cs35l41->hibernate_force_wake;
+
+	return 0;
+}
+
+static int cs35l41_hibernate_force_wake_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+	bool valid_transition = cs35l41->hibernate_force_wake !=
+				ucontrol->value.integer.value[0];
+	unsigned int amp_active;
+
+	regmap_read(cs35l41->regmap, CS35L41_PWR_CTRL1, &amp_active);
+
+	if (cs35l41->amp_hibernate == CS35L41_HIBERNATE_AWAKE ||
+		(cs35l41->amp_hibernate == CS35L41_HIBERNATE_NOT_LOADED &&
+		 cs35l41->dsp.running)) {
+		cs35l41->hibernate_force_wake =
+					ucontrol->value.integer.value[0];
+		if (!cs35l41->hibernate_force_wake && valid_transition &&
+			!(amp_active & CS35L41_GLOBAL_EN_MASK)) {
+			/* return to standby */
+			queue_delayed_work(cs35l41->wq, &cs35l41->hb_work,
+					msecs_to_jiffies(100));
+		}
+	} else if (cs35l41->amp_hibernate == CS35L41_HIBERNATE_STANDBY) {
+		cs35l41->hibernate_force_wake =
+					ucontrol->value.integer.value[0];
+		if (cs35l41->hibernate_force_wake && valid_transition) {
+			/* wake from standby */
+			cancel_delayed_work(&cs35l41->hb_work);
+			mutex_lock(&cs35l41->hb_lock);
+			cs35l41_exit_hibernate(cs35l41);
+			mutex_unlock(&cs35l41->hb_lock);
+		}
+	}
+
+	return 0;
+}
+
+static const char *cs35l41_fast_switch_text[] = {
+	"fast_switch1.txt",
+	"fast_switch2.txt",
+	"fast_switch3.txt",
+	"fast_switch4.txt",
+	"fast_switch5.txt",
+};
+
+static int cs35l41_fast_switch_en_get(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = cs35l41->fast_switch_en;
+
+	return 0;
+}
+
+static int cs35l41_do_fast_switch(struct cs35l41_private *cs35l41)
+{
+	char val_str[CS35L41_BUFSIZE];
+	const char *fw_name = NULL;
+	const struct firmware *fw = NULL;
+	int ret;
+	unsigned int i, j, k;
+	s32 data_ctl_len, val;
+	__be32 *data_ctl_buf, cmd_ctl, st_ctl;
+	bool fw_running	= false;
+
+	data_ctl_buf = NULL;
+
+	fw_name	= cs35l41->fast_switch_names[cs35l41->fast_switch_file_idx];
+	dev_dbg(cs35l41->dev, "fw_name:%s\n", fw_name);
+	ret = request_firmware(&fw, fw_name, cs35l41->dev);
+	if (ret < 0) {
+		dev_err(cs35l41->dev, "Failed to request firmware:%s\n",
+			fw_name);
+		return -EIO;
+	}
+
+	/* Parse number of data words in file */
+	for (i = 0, j = 0; (char)fw->data[i] != ','; i++) {
+		if ((char)fw->data[i] == ' ') {
+			/* Skip white space */
+		} else {
+			/* fw->data[i] must be numerical digit */
+			if (j < CS35L41_BUFSIZE - 1) {
+				val_str[j] = fw->data[i];
+				j++;
+			} else {
+				dev_err(cs35l41->dev, "Invalid input\n");
+				ret = -EINVAL;
+				goto exit;
+			}
+		}
+	}
+	/* points to beginning of next number */
+	i++;
+	val_str[j] = '\0';
+	ret = kstrtos32(val_str, 10, &data_ctl_len);
+	if (ret < 0) {
+		dev_err(cs35l41->dev, "kstrtos32 failed (%d) val_str:%s\n",
+			ret, val_str);
+		goto exit;
+	}
+
+	dev_dbg(cs35l41->dev, "data_ctl_len:%u\n", data_ctl_len);
+
+	data_ctl_buf = kcalloc(1, data_ctl_len * sizeof(s32), GFP_KERNEL);
+	if (!data_ctl_buf) {
+		ret = -ENOMEM;
+		goto exit;
+	}
+
+	data_ctl_buf[0]	= cpu_to_be32(data_ctl_len);
+
+	/* i continues from end of previous loop */
+	for (j = 0, k = 1; i <= fw->size; i++) {
+		if (i == fw->size || (char)fw->data[i] == ',') {
+			/*
+			 * Reached end of parameter
+			 * delimited either by ',' or end of file
+			 * Parse number and write parameter
+			 */
+			val_str[j] = '\0';
+			ret = kstrtos32(val_str, 10, &val);
+			if (ret < 0) {
+				dev_err(cs35l41->dev,
+					"kstrtos32 failed (%d) val_str:%s\n",
+					ret, val_str);
+				goto exit;
+			}
+			data_ctl_buf[k] = cpu_to_be32(val);
+			j = 0;
+			k++;
+		} else if ((char)fw->data[i] == ' ') {
+			/* Skip white space */
+		} else {
+			/* fw->data[i] must be numerical digit */
+			if (j < CS35L41_BUFSIZE - 1) {
+				val_str[j] = fw->data[i];
+				j++;
+			} else {
+				dev_err(cs35l41->dev, "Invalid input\n");
+				ret = -EINVAL;
+				goto exit;
+			}
+		}
+	}
+
+	wm_adsp_write_ctl(&cs35l41->dsp, "CSPL_UPDATE_PARAMS_CONFIG",
+			  WMFW_ADSP2_YM, 0xcd,
+			  data_ctl_buf, data_ctl_len * sizeof(s32));
+
+	dev_dbg(cs35l41->dev,
+		"Wrote %u reg for CSPL_UPDATE_PARAMS_CONFIG\n", data_ctl_len);
+
+#ifdef DEBUG
+	wm_adsp_read_ctl(&cs35l41->dsp, "CSPL_UPDATE_PARAMS_CONFIG",
+			 WMFW_ADSP2_YM, 0xcd,
+			 data_ctl_buf, data_ctl_len * sizeof(s32));
+	dev_dbg(cs35l41->dev, "read CSPL_UPDATE_PARAMS_CONFIG:\n");
+	for (i = 0; i < data_ctl_len; i++)
+		dev_dbg(cs35l41->dev, "%u\n", be32_to_cpu(data_ctl_buf[i]));
+#endif
+
+	cmd_ctl = cpu_to_be32(CSPL_CMD_UPDATE_PARAM);
+	wm_adsp_write_ctl(&cs35l41->dsp, "CSPL_COMMAND",
+			  WMFW_ADSP2_XM, 0xcd, &cmd_ctl, sizeof(s32));
+
+	/* Verify CSPL COMMAND */
+	for (i = 0; i < 5; i++) {
+		wm_adsp_read_ctl(&cs35l41->dsp, "CSPL_STATE",
+				 WMFW_ADSP2_XM, 0xcd, &st_ctl,
+				 sizeof(s32));
+		if (be32_to_cpu(st_ctl) == CSPL_ST_RUNNING) {
+			dev_dbg(cs35l41->dev,
+				"CSPL STATE == RUNNING (%u attempt)\n", i);
+			fw_running = true;
+			break;
+		}
+
+		usleep_range(100, 200);
+	}
+
+	if (!fw_running) {
+		dev_err(cs35l41->dev, "CSPL_STATE (%d) is not running\n",
+			st_ctl);
+		ret = -1;
+		goto exit;
+	}
+exit:
+	kfree(data_ctl_buf);
+	release_firmware(fw);
+	return ret;
+}
+
+static int cs35l41_fast_switch_en_put(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	int ret = 0;
+
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+
+	if (!cs35l41->fast_switch_en && ucontrol->value.integer.value[0])
+		/*
+		 * Rising on fast switch enable
+		 * Perform fast use case switching
+		 */
+		ret = cs35l41_do_fast_switch(cs35l41);
+
+	cs35l41->fast_switch_en = ucontrol->value.integer.value[0];
+
+	return ret;
+}
+
+static int cs35l41_fast_switch_file_put(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+	struct soc_enum *soc_enum;
+	unsigned int i = ucontrol->value.enumerated.item[0];
+
+	soc_enum = (struct soc_enum *)kcontrol->private_value;
+
+	if (i >= soc_enum->items) {
+		dev_err(cs35l41->dev, "Invalid mixer input (%u)\n", i);
+		return -EINVAL;
+	}
+
+	cs35l41->fast_switch_file_idx = i;
+
+	return 0;
+}
+
+static int cs35l41_fast_switch_file_get(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.enumerated.item[0] = cs35l41->fast_switch_file_idx;
+
+	return 0;
+}
+
+static int cs35l41_gpi_global_en_get(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = cs35l41->gpi_global_en;
+
+	return 0;
+}
+
+static int cs35l41_gpi_global_en_put(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+
+	cs35l41->gpi_global_en = ucontrol->value.integer.value[0];
+
+	if (cs35l41->halo_booted && cs35l41->enabled)
+		regmap_write(cs35l41->regmap, CS35L41_DSP_VIRT1_MBOX_8,
+			     cs35l41->gpi_global_en);
+
+	return 0;
+}
+
 static const DECLARE_TLV_DB_RANGE(dig_vol_tlv,
 		0, 0, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 1),
-		1, 913, TLV_DB_MINMAX_ITEM(-10200, 1200));
+		1, CS35L41_MAX_PCM_VOL, TLV_DB_MINMAX_ITEM(-10200, 1200));
 static DECLARE_TLV_DB_SCALE(amp_gain_tlv, 0, 1, 1);
 
 static const struct snd_kcontrol_new dre_ctrl =
 	SOC_DAPM_SINGLE("Switch", CS35L41_PWR_CTRL3, 20, 1, 0);
 
+static const struct snd_kcontrol_new vbstmon_out_ctrl =
+	SOC_DAPM_SINGLE("Switch", SND_SOC_NOPM, 0, 1, 0);
+
 static const char * const cs35l41_pcm_sftramp_text[] =  {
-	"Off", ".5ms", "1ms", "2ms", "4ms", "8ms", "15ms", "30ms"
-};
+	"Off", ".5ms", "1ms", "2ms", "4ms", "8ms", "15ms", "30ms"};
 
 static SOC_ENUM_SINGLE_DECL(pcm_sft_ramp,
 			    CS35L41_AMP_DIG_VOL_CTRL, 0,
 			    cs35l41_pcm_sftramp_text);
 
-static int cs35l41_dsp_preload_ev(struct snd_soc_dapm_widget *w,
-				  struct snd_kcontrol *kcontrol, int event)
+static int cs35l41_reload_tuning_get(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
 {
-	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
-	struct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(component);
-	int ret;
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
 
-	switch (event) {
-	case SND_SOC_DAPM_PRE_PMU:
-		if (cs35l41->dsp.cs_dsp.booted)
-			return 0;
+	ucontrol->value.integer.value[0] = cs35l41->reload_tuning;
 
-		return wm_adsp_early_event(w, kcontrol, event);
-	case SND_SOC_DAPM_PRE_PMD:
-		if (cs35l41->dsp.preloaded)
-			return 0;
+	return 0;
+}
 
-		if (cs35l41->dsp.cs_dsp.running) {
-			ret = wm_adsp_event(w, kcontrol, event);
-			if (ret)
-				return ret;
-		}
+static int cs35l41_reload_tuning_put(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component =
+		snd_soc_kcontrol_component(kcontrol);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+
+	cs35l41->reload_tuning = ucontrol->value.integer.value[0];
+
+	return 0;
+}
 
-		return wm_adsp_early_event(w, kcontrol, event);
+static bool cs35l41_check_cspl_mbox_sts(enum cs35l41_cspl_mbox_cmd cmd,
+					   enum cs35l41_cspl_mbox_status sts)
+{
+	switch (cmd) {
+	case CSPL_MBOX_CMD_NONE:
+	case CSPL_MBOX_CMD_UNKNOWN_CMD:
+		return true;
+	case CSPL_MBOX_CMD_PAUSE:
+		return (sts == CSPL_MBOX_STS_PAUSED);
+	case CSPL_MBOX_CMD_RESUME:
+		return (sts == CSPL_MBOX_STS_RUNNING);
+	case CSPL_MBOX_CMD_REINIT:
+		return (sts == CSPL_MBOX_STS_RUNNING);
+	case CSPL_MBOX_CMD_STOP_PRE_REINIT:
+		return (sts == CSPL_MBOX_STS_RDY_FOR_REINIT);
 	default:
-		return 0;
+		return false;
 	}
 }
 
-static int cs35l41_dsp_audio_ev(struct snd_soc_dapm_widget *w,
-				struct snd_kcontrol *kcontrol, int event)
+static int cs35l41_set_cspl_mbox_cmd(struct cs35l41_private *cs35l41,
+				   enum cs35l41_cspl_mbox_cmd cmd)
 {
-	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
-	struct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(component);
-	unsigned int fw_status;
-	int ret;
+	int ret = 0;
+	unsigned int sts, i;
+	bool status_ok = false;
 
-	switch (event) {
-	case SND_SOC_DAPM_POST_PMU:
-		if (!cs35l41->dsp.cs_dsp.running)
-			return wm_adsp_event(w, kcontrol, event);
+	// Set mailbox cmd
+	regmap_write(cs35l41->regmap, CS35L41_DSP_VIRT1_MBOX_1, cmd);
 
-		ret = regmap_read(cs35l41->regmap, CS35L41_DSP_MBOX_2, &fw_status);
+	// Read mailbox status and verify it is appropriate for the given cmd
+	for (i = 0; i < 5; i++) {
+		usleep_range(1000, 1100);
+		ret = regmap_read(cs35l41->regmap, CS35L41_DSP_MBOX_2, &sts);
 		if (ret < 0) {
 			dev_err(cs35l41->dev,
-				"Failed to read firmware status: %d\n", ret);
-			return ret;
+				"%s: regmap_read failed (%d)\n",
+				__func__, ret);
+			continue;
 		}
 
-		switch (fw_status) {
-		case CSPL_MBOX_STS_RUNNING:
-		case CSPL_MBOX_STS_PAUSED:
+		if (!cs35l41_check_cspl_mbox_sts(cmd,
+			(enum cs35l41_cspl_mbox_status)sts)) {
+			dev_dbg(cs35l41->dev,
+				"%s: [%u] cmd %u returned invalid sts %u",
+				__func__, i, cmd, sts);
+		} else {
+			status_ok = true;
 			break;
-		default:
-			dev_err(cs35l41->dev, "Firmware status is invalid: %u\n",
-				fw_status);
-			return -EINVAL;
 		}
+	}
 
-		return cs35l41_set_cspl_mbox_cmd(cs35l41->dev, cs35l41->regmap,
-						 CSPL_MBOX_CMD_RESUME);
-	case SND_SOC_DAPM_PRE_PMD:
-		return cs35l41_set_cspl_mbox_cmd(cs35l41->dev, cs35l41->regmap,
-						 CSPL_MBOX_CMD_PAUSE);
-	default:
-		return 0;
+	if (!status_ok) {
+		dev_err(cs35l41->dev,
+			"Failed to set mailbox cmd %u (status %u)\n",
+			cmd, sts);
+		ret = -ENOMSG;
+	}
+
+	return ret;
+}
+
+static void cs35l41_abort_ramp(struct cs35l41_private *cs35l41)
+{
+	if (!work_busy(&cs35l41->vol_ctl.ramp_work))
+		return;
+	atomic_set(&cs35l41->vol_ctl.ramp_abort, 1);
+	cancel_work_sync(&cs35l41->vol_ctl.ramp_work);
+	flush_workqueue(cs35l41->vol_ctl.ramp_wq);
+	atomic_set(&cs35l41->vol_ctl.ramp_abort, 0);
+}
+
+static int cs35l41_put_output_dev(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+	struct soc_enum *soc_enum;
+	unsigned int i = ucontrol->value.enumerated.item[0];
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	soc_enum = (struct soc_enum *)kcontrol->private_value;
+
+	if (i >= soc_enum->items) {
+		dev_err(component->dev,
+			"Invalid mixer input (%u)\n", i);
+		return -EINVAL;
+	}
+
+	if (atomic_read(&cs35l41->vol_ctl.playback) &&
+	    cs35l41->vol_ctl.auto_ramp_timeout > 0 &&
+	    cs35l41->vol_ctl.output_dev == CS35L41_OUTPUT_DEV_RCV &&
+	    soc_enum->values[i] == CS35L41_OUTPUT_DEV_SPK) {
+		/*
+		 * While audio is playing,
+		 * auto volume ramp is enabled,
+		 * output device changes from RCV to SPK.
+		 * In this case, perform volume ramp.
+		 */
+		cs35l41_abort_ramp(cs35l41);
+		queue_work(cs35l41->vol_ctl.ramp_wq,
+			   &cs35l41->vol_ctl.ramp_work);
 	}
+
+	cs35l41->vol_ctl.output_dev = soc_enum->values[i];
+
+	return 0;
+}
+
+static int cs35l41_get_output_dev(struct snd_kcontrol *kcontrol,
+				  struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+	int ret = 0;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.enumerated.item[0] = cs35l41->vol_ctl.output_dev;
+
+	return ret;
 }
 
+static const struct snd_kcontrol_new amp_enable_ctrl =
+	SOC_DAPM_SINGLE("Switch", SND_SOC_NOPM, 0, 1, 0);
+
 static const char * const cs35l41_pcm_source_texts[] = {"ASP", "DSP"};
 static const unsigned int cs35l41_pcm_source_values[] = {0x08, 0x32};
 static SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_pcm_source_enum,
-				  CS35L41_DAC_PCM1_SRC,
-				  0, CS35L41_ASP_SOURCE_MASK,
-				  cs35l41_pcm_source_texts,
-				  cs35l41_pcm_source_values);
+				CS35L41_DAC_PCM1_SRC,
+				0, CS35L41_ASP_SOURCE_MASK,
+				cs35l41_pcm_source_texts,
+				cs35l41_pcm_source_values);
 
 static const struct snd_kcontrol_new pcm_source_mux =
 	SOC_DAPM_ENUM("PCM Source", cs35l41_pcm_source_enum);
 
-static const char * const cs35l41_tx_input_texts[] = {
-	"Zero", "ASPRX1", "ASPRX2", "VMON", "IMON",
-	"VPMON", "VBSTMON", "DSPTX1", "DSPTX2"
-};
-
-static const unsigned int cs35l41_tx_input_values[] = {
-	0x00, CS35L41_INPUT_SRC_ASPRX1, CS35L41_INPUT_SRC_ASPRX2,
-	CS35L41_INPUT_SRC_VMON, CS35L41_INPUT_SRC_IMON, CS35L41_INPUT_SRC_VPMON,
-	CS35L41_INPUT_SRC_VBSTMON, CS35L41_INPUT_DSP_TX1, CS35L41_INPUT_DSP_TX2
-};
+static const char * const cs35l41_tx_input_texts[] = {"Zero", "ASPRX1",
+							"ASPRX2", "VMON",
+							"IMON", "VPMON",
+							"VBSTMON",
+							"DSPTX1", "DSPTX2"};
+static const unsigned int cs35l41_tx_input_values[] = {0x00,
+						CS35L41_INPUT_SRC_ASPRX1,
+						CS35L41_INPUT_SRC_ASPRX2,
+						CS35L41_INPUT_SRC_VMON,
+						CS35L41_INPUT_SRC_IMON,
+						CS35L41_INPUT_SRC_VPMON,
+						CS35L41_INPUT_SRC_VBSTMON,
+						CS35L41_INPUT_DSP_TX1,
+						CS35L41_INPUT_DSP_TX2};
 
 static SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_asptx1_enum,
-				  CS35L41_ASP_TX1_SRC,
-				  0, CS35L41_ASP_SOURCE_MASK,
-				  cs35l41_tx_input_texts,
-				  cs35l41_tx_input_values);
+				CS35L41_ASP_TX1_SRC,
+				0, CS35L41_ASP_SOURCE_MASK,
+				cs35l41_tx_input_texts,
+				cs35l41_tx_input_values);
 
 static const struct snd_kcontrol_new asp_tx1_mux =
 	SOC_DAPM_ENUM("ASPTX1 SRC", cs35l41_asptx1_enum);
 
 static SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_asptx2_enum,
-				  CS35L41_ASP_TX2_SRC,
-				  0, CS35L41_ASP_SOURCE_MASK,
-				  cs35l41_tx_input_texts,
-				  cs35l41_tx_input_values);
+				CS35L41_ASP_TX2_SRC,
+				0, CS35L41_ASP_SOURCE_MASK,
+				cs35l41_tx_input_texts,
+				cs35l41_tx_input_values);
 
 static const struct snd_kcontrol_new asp_tx2_mux =
 	SOC_DAPM_ENUM("ASPTX2 SRC", cs35l41_asptx2_enum);
 
 static SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_asptx3_enum,
-				  CS35L41_ASP_TX3_SRC,
-				  0, CS35L41_ASP_SOURCE_MASK,
-				  cs35l41_tx_input_texts,
-				  cs35l41_tx_input_values);
+				CS35L41_ASP_TX3_SRC,
+				0, CS35L41_ASP_SOURCE_MASK,
+				cs35l41_tx_input_texts,
+				cs35l41_tx_input_values);
 
 static const struct snd_kcontrol_new asp_tx3_mux =
 	SOC_DAPM_ENUM("ASPTX3 SRC", cs35l41_asptx3_enum);
 
 static SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_asptx4_enum,
-				  CS35L41_ASP_TX4_SRC,
-				  0, CS35L41_ASP_SOURCE_MASK,
-				  cs35l41_tx_input_texts,
-				  cs35l41_tx_input_values);
+				CS35L41_ASP_TX4_SRC,
+				0, CS35L41_ASP_SOURCE_MASK,
+				cs35l41_tx_input_texts,
+				cs35l41_tx_input_values);
 
 static const struct snd_kcontrol_new asp_tx4_mux =
 	SOC_DAPM_ENUM("ASPTX4 SRC", cs35l41_asptx4_enum);
 
 static SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_dsprx1_enum,
-				  CS35L41_DSP1_RX1_SRC,
-				  0, CS35L41_ASP_SOURCE_MASK,
-				  cs35l41_tx_input_texts,
-				  cs35l41_tx_input_values);
+				CS35L41_DSP1_RX1_SRC,
+				0, CS35L41_ASP_SOURCE_MASK,
+				cs35l41_tx_input_texts,
+				cs35l41_tx_input_values);
 
 static const struct snd_kcontrol_new dsp_rx1_mux =
 	SOC_DAPM_ENUM("DSPRX1 SRC", cs35l41_dsprx1_enum);
 
 static SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_dsprx2_enum,
-				  CS35L41_DSP1_RX2_SRC,
-				  0, CS35L41_ASP_SOURCE_MASK,
-				  cs35l41_tx_input_texts,
-				  cs35l41_tx_input_values);
+				CS35L41_DSP1_RX2_SRC,
+				0, CS35L41_ASP_SOURCE_MASK,
+				cs35l41_tx_input_texts,
+				cs35l41_tx_input_values);
 
 static const struct snd_kcontrol_new dsp_rx2_mux =
 	SOC_DAPM_ENUM("DSPRX2 SRC", cs35l41_dsprx2_enum);
 
+static void cs35l41_set_vol(int vol, struct cs35l41_private *cs35l41)
+{
+	unsigned int val;
+	int ret;
+
+	mutex_lock(&cs35l41->vol_ctl.vol_mutex);
+
+	if (vol < 0 || vol > CS35L41_MAX_PCM_VOL) {
+		dev_err(cs35l41->dev,
+			"Invalid PCM VOLUME %d\n", vol);
+		goto exit;
+	}
+
+	if (vol < CS35L41_ZERO_PCM_VOL)
+		/* PCM Volume is attenuation */
+		val = (unsigned int)(vol + CS35L41_AMP_PCM_VOL_MUTE);
+	else
+		/* CS35L41_ZERO_PCM_VOL <= dig_vol <= CS35L41_MAX_PCM_VOL */
+		val = (unsigned int)(vol - CS35L41_ZERO_PCM_VOL);
+	ret = regmap_update_bits(cs35l41->regmap, CS35L41_AMP_DIG_VOL_CTRL,
+				 CS35L41_AMP_PCM_VOL_MASK,
+				 val << CS35L41_AMP_PCM_VOL_SHIFT);
+	if (ret < 0)
+		dev_err(cs35l41->dev,
+			"Failed to set PCM VOLUME %d\n", ret);
+
+exit:
+	mutex_unlock(&cs35l41->vol_ctl.vol_mutex);
+}
+
+static int cs35l41_vol_ramp0(struct cs35l41_private *cs35l41,
+			     long final_x, long init_y, long final_y)
+{
+	long curr_x = 0;
+	long curr_y = init_y;
+	long delta_x = final_x;
+	long delta_y = final_y - init_y;
+	long step_x, step_y;
+	int ret = 0;
+
+	if (final_x < 0 || final_y < 0 || init_y < 0) {
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	if (final_y <= init_y) {
+		dev_info(cs35l41->dev, "Vol ramp slope is not positive\n");
+		cs35l41_set_vol((int)init_y, cs35l41);
+		usleep_range(final_x, final_x + 1);
+		cs35l41_set_vol((int)final_y, cs35l41);
+		goto exit;
+	}
+
+	step_y = 1;	/* 1/8 dB, min IC supported step */
+	step_x = delta_x / delta_y;	/* in micro-seconds */
+	if (step_x == 0)
+		/* Take care of case where delta_x < delta_y */
+		step_x = 1;
+
+	dev_dbg(cs35l41->dev, "vol ramp delta x:%ld delta y:%ld step x:%ld\n",
+		delta_x, delta_y, step_x);
+	while (1) {
+		if (atomic_read(&cs35l41->vol_ctl.ramp_abort)) {
+			ret = -EINTR;
+			goto exit;
+		}
+		if (curr_x >= final_x) {
+			/* Delay is complete */
+			cs35l41_set_vol((int)final_y, cs35l41);
+			break;
+		}
+		if (curr_y == final_y) {
+			/* Volume ramp is complete */
+			usleep_range(final_x - curr_x, final_x - curr_x + 1);
+			break;
+		}
+		cs35l41_set_vol((int)curr_y, cs35l41);
+		curr_y += step_y;
+		curr_x += step_x;
+		usleep_range(step_x, step_x + 1);
+	}
+exit:
+	return ret;
+}
+
+static void cs35l41_vol_ramp(struct work_struct *wk)
+{
+	struct cs35l41_vol_ctl *vol_ctl;
+	struct cs35l41_private *cs35l41;
+	long final_x_knee, final_x_end;
+	long init_y_knee, init_y_end, final_y_end;
+	int ret = 0;
+
+	vol_ctl = container_of(wk, struct cs35l41_vol_ctl, ramp_work);
+	cs35l41 = container_of(vol_ctl, struct cs35l41_private, vol_ctl);
+	atomic_set(&cs35l41->vol_ctl.vol_ramp, 1);
+	/*
+	 * vol_ramp must be true at this point,
+	 * which guarantee ramp_init_att, ramp_knee_att,
+	 * ramp_knee_time, ramp_end_time cannot be changed
+	 */
+	final_x_knee = (long)(cs35l41->vol_ctl.ramp_knee_time) * 1000;	/* us */
+	final_x_end = (long)(cs35l41->vol_ctl.ramp_end_time) * 1000;
+	/* 1/8 dB minimum step */
+	init_y_knee = (long)(cs35l41->vol_ctl.dig_vol -
+			     cs35l41->vol_ctl.ramp_init_att * 8);
+	if (init_y_knee < 0)
+		/* Hit floor */
+		init_y_knee = 0;
+	init_y_end = (long)(cs35l41->vol_ctl.dig_vol -
+			    cs35l41->vol_ctl.ramp_knee_att * 8);
+	if (init_y_end < 0)
+		/* Hit floor */
+		init_y_end = 0;
+	final_y_end = (long)cs35l41->vol_ctl.dig_vol;
+	if (final_y_end < 0)
+		/* Hit floor */
+		final_y_end = 0;
+	ret = cs35l41_vol_ramp0(cs35l41, final_x_knee, init_y_knee, init_y_end);
+	if (ret == -EINTR) {
+		/* Abort ramp */
+		cs35l41_set_vol(cs35l41->vol_ctl.dig_vol, cs35l41);
+		goto exit;
+	}
+	ret = cs35l41_vol_ramp0(cs35l41, final_x_end, init_y_end, final_y_end);
+	if (ret == -EINTR) {
+		/* Abort ramp */
+		cs35l41_set_vol(cs35l41->vol_ctl.dig_vol, cs35l41);
+		goto exit;
+	}
+exit:
+	atomic_set(&cs35l41->vol_ctl.vol_ramp, 0);
+	/* Make manual ramp one-shot */
+	atomic_set(&cs35l41->vol_ctl.manual_ramp, 0);
+}
+
+static int cs35l41_get_vol(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = (long)cs35l41->vol_ctl.dig_vol;
+
+	return 0;
+}
+
+static int cs35l41_put_vol(struct snd_kcontrol *kcontrol,
+			   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+	int ret = 0;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	if (ucontrol->value.integer.value[0] < 0 ||
+	    ucontrol->value.integer.value[0] > CS35L41_MAX_PCM_VOL)
+		return -EINVAL;
+
+	if (atomic_read(&cs35l41->vol_ctl.vol_ramp) == 0) {
+		cs35l41->vol_ctl.dig_vol =
+			(int)ucontrol->value.integer.value[0];
+		cs35l41_set_vol(cs35l41->vol_ctl.dig_vol, cs35l41);
+	}
+
+	return ret;
+}
+
+static int cs35l41_get_ramp_status(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] =
+		(long)atomic_read(&cs35l41->vol_ctl.vol_ramp);
+
+	return 0;
+}
+
+static int cs35l41_put_ramp_status(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	dev_info(cs35l41->dev,
+		 "Volume ramp status cannot be set\n");
+	return 0;
+}
+
+static int cs35l41_get_manual_ramp(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] =
+		(long)atomic_read(&cs35l41->vol_ctl.manual_ramp);
+
+	return 0;
+}
+
+static int cs35l41_put_manual_ramp(struct snd_kcontrol *kcontrol,
+				   struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	if (ucontrol->value.integer.value[0] < 0 ||
+	    ucontrol->value.integer.value[0] > 1)
+		return -EINVAL;
+
+	if (atomic_read(&cs35l41->vol_ctl.manual_ramp) == 0 &&
+	    ucontrol->value.integer.value[0] == 1) {
+		/* Rising edge */
+		if (atomic_read(&cs35l41->vol_ctl.playback)) {
+			/* Stop existing ramp and start new ramp */
+			cs35l41_abort_ramp(cs35l41);
+			queue_work(cs35l41->vol_ctl.ramp_wq,
+				   &cs35l41->vol_ctl.ramp_work);
+		}
+		/*
+		 * In else case,
+		 * let DAPM event handle ramp on playback start.
+		 */
+	} else if (atomic_read(&cs35l41->vol_ctl.manual_ramp) == 1 &&
+		   ucontrol->value.integer.value[0] == 0) {
+		/* Falling edge */
+		if (atomic_read(&cs35l41->vol_ctl.playback))
+			/* Stop existing ramp */
+			cs35l41_abort_ramp(cs35l41);
+	}
+	atomic_set(&cs35l41->vol_ctl.manual_ramp,
+		   ucontrol->value.integer.value[0]);
+
+	return 0;
+}
+
+static int cs35l41_get_init_attenuation(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = (long)cs35l41->vol_ctl.ramp_init_att;
+	return 0;
+}
+
+static int cs35l41_put_init_attenuation(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	if (ucontrol->value.integer.value[0] < 0 ||
+	    ucontrol->value.integer.value[0] > CS35L41_MAX_VOL_ATT)
+		return -EINVAL;
+
+	if (atomic_read(&cs35l41->vol_ctl.vol_ramp) == 0)
+		cs35l41->vol_ctl.ramp_init_att =
+			(int)ucontrol->value.integer.value[0];
+	return 0;
+}
+
+static int cs35l41_get_knee_attenuation(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = (long)cs35l41->vol_ctl.ramp_knee_att;
+	return 0;
+}
+
+static int cs35l41_put_knee_attenuation(struct snd_kcontrol *kcontrol,
+					struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	if (ucontrol->value.integer.value[0] < 0 ||
+	    ucontrol->value.integer.value[0] > CS35L41_MAX_VOL_ATT)
+		return -EINVAL;
+
+	if (atomic_read(&cs35l41->vol_ctl.vol_ramp) == 0)
+		cs35l41->vol_ctl.ramp_knee_att =
+			(int)ucontrol->value.integer.value[0];
+	return 0;
+}
+
+static int cs35l41_get_ramp_end_time(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = (long)cs35l41->vol_ctl.ramp_end_time;
+	return 0;
+}
+
+static int cs35l41_put_ramp_end_time(struct snd_kcontrol *kcontrol,
+				     struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	if (ucontrol->value.integer.value[0] < 0 ||
+	    ucontrol->value.integer.value[0] > CS35L41_MAX_AUTO_RAMP_TIMEOUT)
+		return -EINVAL;
+
+	if (atomic_read(&cs35l41->vol_ctl.vol_ramp) == 0)
+		cs35l41->vol_ctl.ramp_end_time =
+			(unsigned int)ucontrol->value.integer.value[0];
+	return 0;
+}
+
+static int cs35l41_get_auto_ramp_timeout(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] =
+		(long)cs35l41->vol_ctl.auto_ramp_timeout;
+	return 0;
+}
+
+static int cs35l41_put_auto_ramp_timeout(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	if (ucontrol->value.integer.value[0] < 0 ||
+	    ucontrol->value.integer.value[0] > CS35L41_MAX_AUTO_RAMP_TIMEOUT)
+		return -EINVAL;
+
+	cs35l41->vol_ctl.auto_ramp_timeout =
+		(unsigned int)ucontrol->value.integer.value[0];
+
+	return 0;
+}
+
+static int cs35l41_get_ramp_knee_time(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private	*cs35l41;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] =
+		(long)cs35l41->vol_ctl.ramp_knee_time;
+	return 0;
+}
+
+static int cs35l41_put_ramp_knee_time(struct snd_kcontrol *kcontrol,
+				      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	if (ucontrol->value.integer.value[0] < 0 ||
+	    ucontrol->value.integer.value[0] > CS35L41_MAX_AUTO_RAMP_TIMEOUT)
+		return -EINVAL;
+
+	if (atomic_read(&cs35l41->vol_ctl.vol_ramp) == 0)
+		cs35l41->vol_ctl.ramp_knee_time =
+			(unsigned int)ucontrol->value.integer.value[0];
+	return 0;
+}
+
+static int cs35l41_get_port_blocked_status(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = cs35l41->speaker_port_blocked;
+
+	return 0;
+}
+
+static int cs35l41_get_open_short_status(struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component;
+	struct cs35l41_private *cs35l41;
+
+	component = snd_soc_kcontrol_component(kcontrol);
+	cs35l41 = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = cs35l41->speaker_open_short_status;
+
+	return 0;
+}
+
+static const char * const cs35l41_output_dev_text[] = {
+	"Speaker",
+	"Receiver",
+};
+
+/* Ensure SPK and RCV defined values match array index */
+static const unsigned int cs35l41_output_dev_val[] = {
+	CS35L41_OUTPUT_DEV_SPK,
+	CS35L41_OUTPUT_DEV_RCV,
+};
+
+static SOC_VALUE_ENUM_SINGLE_DECL(cs35l41_output_dev, SND_SOC_NOPM, 0, 0,
+				  cs35l41_output_dev_text,
+				  cs35l41_output_dev_val);
+
 static const struct snd_kcontrol_new cs35l41_aud_controls[] = {
-	SOC_SINGLE_SX_TLV("Digital PCM Volume", CS35L41_AMP_DIG_VOL_CTRL,
-			  3, 0x4CF, 0x391, dig_vol_tlv),
-	SOC_SINGLE_TLV("Analog PCM Volume", CS35L41_AMP_GAIN_CTRL, 5, 0x14, 0,
-		       amp_gain_tlv),
+	SOC_SINGLE_RANGE_EXT_TLV("Digital PCM Volume", SND_SOC_NOPM, 0, 0,
+				 CS35L41_MAX_PCM_VOL, 0, cs35l41_get_vol,
+				 cs35l41_put_vol, dig_vol_tlv),
+	SOC_SINGLE_TLV("AMP PCM Gain", CS35L41_AMP_GAIN_CTRL, 5, 0x14, 0,
+			amp_gain_tlv),
+	SOC_SINGLE_RANGE("ASPTX1 Slot Position", CS35L41_SP_FRAME_TX_SLOT, 0,
+			 0, 7, 0),
+	SOC_SINGLE_RANGE("ASPTX2 Slot Position", CS35L41_SP_FRAME_TX_SLOT, 8,
+			 0, 7, 0),
+	SOC_SINGLE_RANGE("ASPTX3 Slot Position", CS35L41_SP_FRAME_TX_SLOT, 16,
+			 0, 7, 0),
+	SOC_SINGLE_RANGE("ASPTX4 Slot Position", CS35L41_SP_FRAME_TX_SLOT, 24,
+			 0, 7, 0),
+	SOC_SINGLE_RANGE("ASPRX1 Slot Position", CS35L41_SP_FRAME_RX_SLOT, 0,
+			 0, 7, 0),
+	SOC_SINGLE_RANGE("ASPRX2 Slot Position", CS35L41_SP_FRAME_RX_SLOT, 8,
+			 0, 7, 0),
 	SOC_ENUM("PCM Soft Ramp", pcm_sft_ramp),
-	SOC_SINGLE("HW Noise Gate Enable", CS35L41_NG_CFG, 8, 63, 0),
-	SOC_SINGLE("HW Noise Gate Delay", CS35L41_NG_CFG, 4, 7, 0),
-	SOC_SINGLE("HW Noise Gate Threshold", CS35L41_NG_CFG, 0, 7, 0),
-	SOC_SINGLE("Aux Noise Gate CH1 Switch",
-		   CS35L41_MIXER_NGATE_CH1_CFG, 16, 1, 0),
-	SOC_SINGLE("Aux Noise Gate CH1 Entry Delay",
-		   CS35L41_MIXER_NGATE_CH1_CFG, 8, 15, 0),
-	SOC_SINGLE("Aux Noise Gate CH1 Threshold",
-		   CS35L41_MIXER_NGATE_CH1_CFG, 0, 7, 0),
-	SOC_SINGLE("Aux Noise Gate CH2 Entry Delay",
-		   CS35L41_MIXER_NGATE_CH2_CFG, 8, 15, 0),
-	SOC_SINGLE("Aux Noise Gate CH2 Switch",
-		   CS35L41_MIXER_NGATE_CH2_CFG, 16, 1, 0),
-	SOC_SINGLE("Aux Noise Gate CH2 Threshold",
-		   CS35L41_MIXER_NGATE_CH2_CFG, 0, 7, 0),
-	SOC_SINGLE("SCLK Force Switch", CS35L41_SP_FORMAT, CS35L41_SCLK_FRC_SHIFT, 1, 0),
-	SOC_SINGLE("LRCLK Force Switch", CS35L41_SP_FORMAT, CS35L41_LRCLK_FRC_SHIFT, 1, 0),
-	SOC_SINGLE("Invert Class D Switch", CS35L41_AMP_DIG_VOL_CTRL,
-		   CS35L41_AMP_INV_PCM_SHIFT, 1, 0),
-	SOC_SINGLE("Amp Gain ZC Switch", CS35L41_AMP_GAIN_CTRL,
-		   CS35L41_AMP_GAIN_ZC_SHIFT, 1, 0),
+	SOC_SINGLE_EXT("DSP Booted", SND_SOC_NOPM, 0, 1, 0,
+			cs35l41_halo_booted_get, cs35l41_halo_booted_put),
+	SOC_SINGLE_EXT("AMP Reset", SND_SOC_NOPM, 0, 1, 0,
+			cs35l41_amp_reset_get, cs35l41_amp_reset_put),
+	SOC_SINGLE_EXT("CCM Reset", CS35L41_DSP1_CCM_CORE_CTRL, 0, 1, 0,
+			cs35l41_ccm_reset_get, cs35l41_ccm_reset_put),
+	SOC_SINGLE_EXT("Force Interrupt", SND_SOC_NOPM, 0, 1, 0,
+			cs35l41_force_int_get, cs35l41_force_int_put),
+	SOC_SINGLE_EXT("Hibernate Force Wake", SND_SOC_NOPM, 0, 1, 0,
+			cs35l41_hibernate_force_wake_get,
+			cs35l41_hibernate_force_wake_put),
+	SOC_SINGLE_EXT("Fast Use Case Switch Enable", SND_SOC_NOPM, 0, 1, 0,
+		    cs35l41_fast_switch_en_get, cs35l41_fast_switch_en_put),
+	SOC_SINGLE_EXT("Firmware Reload Tuning", SND_SOC_NOPM, 0, 1, 0,
+			cs35l41_reload_tuning_get, cs35l41_reload_tuning_put),
+	SOC_SINGLE_EXT("GLOBAL_EN from GPIO Control", SND_SOC_NOPM, 0, 1, 0,
+			cs35l41_gpi_global_en_get, cs35l41_gpi_global_en_put),
+	SOC_SINGLE("Boost Converter Enable", CS35L41_PWR_CTRL2, 4, 3, 0),
+	SOC_SINGLE("Boost Class-H Tracking Enable",
+					CS35L41_BSTCVRT_VCTRL2, 0, 1, 0),
+	SOC_SINGLE("Boost Target Voltage", CS35L41_BSTCVRT_VCTRL1, 0, 0xAA, 0),
 	WM_ADSP2_PRELOAD_SWITCH("DSP1", 1),
 	WM_ADSP_FW_CONTROL("DSP1", 0),
+	SOC_SINGLE_BOOL_EXT("Safety Volume Ramp Status", 0,
+			    cs35l41_get_ramp_status, cs35l41_put_ramp_status),
+	SOC_SINGLE_BOOL_EXT("Manual Ramp Control", 0,
+			    cs35l41_get_manual_ramp, cs35l41_put_manual_ramp),
+	SOC_SINGLE_EXT("Initial Ramp Volume Attenuation",
+		       SND_SOC_NOPM, 0, CS35L41_MAX_VOL_ATT, 0,
+		       cs35l41_get_init_attenuation,
+		       cs35l41_put_init_attenuation),
+	SOC_SINGLE_EXT("Knee Ramp Volume Attenuation",
+		       SND_SOC_NOPM, 0, CS35L41_MAX_VOL_ATT, 0,
+		       cs35l41_get_knee_attenuation,
+		       cs35l41_put_knee_attenuation),
+	SOC_SINGLE_EXT("Ramp Knee Time", SND_SOC_NOPM, 0,
+		       CS35L41_MAX_AUTO_RAMP_TIMEOUT, 0,
+		       cs35l41_get_ramp_knee_time, cs35l41_put_ramp_knee_time),
+	SOC_SINGLE_EXT("Ramp End Time", SND_SOC_NOPM, 0,
+		       CS35L41_MAX_AUTO_RAMP_TIMEOUT, 0,
+		       cs35l41_get_ramp_end_time, cs35l41_put_ramp_end_time),
+	SOC_SINGLE_EXT("Auto Ramp Safety Timeout", SND_SOC_NOPM, 0,
+		       CS35L41_MAX_AUTO_RAMP_TIMEOUT, 0,
+		       cs35l41_get_auto_ramp_timeout,
+		       cs35l41_put_auto_ramp_timeout),
+	SOC_VALUE_ENUM_EXT("Audio Output Device", cs35l41_output_dev,
+			   cs35l41_get_output_dev, cs35l41_put_output_dev),
+	SOC_SINGLE_BOOL_EXT("Speaker Port Blocked Status", 0,
+			    cs35l41_get_port_blocked_status, NULL),
+	SOC_SINGLE_EXT("Speaker Open / Short Status", SND_SOC_NOPM, 0,
+		       SPK_STATUS_SHORT_CIRCUIT, 0,
+		       cs35l41_get_open_short_status, NULL),
 };
 
+static const struct cs35l41_otp_map_element_t *cs35l41_find_otp_map(u32 otp_id)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(cs35l41_otp_map_map); i++) {
+		if (cs35l41_otp_map_map[i].id == otp_id)
+			return &cs35l41_otp_map_map[i];
+	}
+
+	return NULL;
+}
+
+static int cs35l41_otp_unpack(void *data)
+{
+	struct cs35l41_private *cs35l41 = data;
+	u32 *otp_mem = NULL;
+	int i;
+	int bit_offset, word_offset;
+	unsigned int bit_sum = 8;
+	u32 otp_val, otp_id_reg;
+	const struct cs35l41_otp_map_element_t *otp_map_match = NULL;
+	const struct cs35l41_otp_packed_element_t *otp_map = NULL;
+	int ret;
+
+	otp_mem = kmalloc_array(32, sizeof(*otp_mem), GFP_KERNEL);
+	if (!otp_mem)
+		return -ENOMEM;
+
+	ret = regmap_read(cs35l41->regmap, CS35L41_OTPID, &otp_id_reg);
+	if (ret < 0) {
+		dev_err(cs35l41->dev, "Read OTP ID failed\n");
+		ret = -EINVAL;
+		goto err_otp_unpack;
+	}
+
+	otp_map_match = cs35l41_find_otp_map(otp_id_reg);
+
+	if (otp_map_match == NULL) {
+		dev_err(cs35l41->dev, "OTP Map matching ID %d not found\n",
+				otp_id_reg);
+		ret = -EINVAL;
+		goto err_otp_unpack;
+	}
+
+	ret = regmap_bulk_read(cs35l41->regmap, CS35L41_OTP_MEM0, otp_mem,
+						CS35L41_OTP_SIZE_WORDS);
+	if (ret < 0) {
+		dev_err(cs35l41->dev, "Read OTP Mem failed\n");
+		ret = -EINVAL;
+		goto err_otp_unpack;
+	}
+
+	otp_map = otp_map_match->map;
+
+	bit_offset = otp_map_match->bit_offset;
+	word_offset = otp_map_match->word_offset;
+
+	ret = regmap_write(cs35l41->regmap, CS35L41_TEST_KEY_CTL, 0x00000055);
+	if (ret < 0) {
+		dev_err(cs35l41->dev, "Write Unlock key failed 1/2\n");
+		ret = -EINVAL;
+		goto err_otp_unpack;
+	}
+	ret = regmap_write(cs35l41->regmap, CS35L41_TEST_KEY_CTL, 0x000000AA);
+	if (ret < 0) {
+		dev_err(cs35l41->dev, "Write Unlock key failed 2/2\n");
+		ret = -EINVAL;
+		goto err_otp_unpack;
+	}
+
+	for (i = 0; i < otp_map_match->num_elements; i++) {
+		dev_dbg(cs35l41->dev,
+			   "bitoffset= %d, word_offset=%d, bit_sum mod 32=%d\n",
+					 bit_offset, word_offset, bit_sum % 32);
+		if (bit_offset + otp_map[i].size - 1 >= 32) {
+			otp_val = (otp_mem[word_offset] &
+					GENMASK(31, bit_offset)) >>
+					bit_offset;
+			otp_val |= (otp_mem[++word_offset] &
+					GENMASK(bit_offset +
+						otp_map[i].size - 33, 0)) <<
+					(32 - bit_offset);
+			bit_offset += otp_map[i].size - 32;
+		} else {
+
+			otp_val = (otp_mem[word_offset] &
+				GENMASK(bit_offset + otp_map[i].size - 1,
+					bit_offset)) >>	bit_offset;
+			bit_offset += otp_map[i].size;
+		}
+		bit_sum += otp_map[i].size;
+
+		if (bit_offset == 32) {
+			bit_offset = 0;
+			word_offset++;
+		}
+
+		if (otp_map[i].reg != 0) {
+			ret = regmap_update_bits(cs35l41->regmap,
+						otp_map[i].reg,
+						GENMASK(otp_map[i].shift +
+							otp_map[i].size - 1,
+						otp_map[i].shift),
+						otp_val << otp_map[i].shift);
+			if (ret < 0) {
+				dev_err(cs35l41->dev, "Write OTP val failed\n");
+				ret = -EINVAL;
+				goto err_otp_unpack;
+			}
+		}
+	}
+
+	ret = regmap_write(cs35l41->regmap, CS35L41_TEST_KEY_CTL, 0x000000CC);
+	if (ret < 0) {
+		dev_err(cs35l41->dev, "Write Lock key failed 1/2\n");
+		ret = -EINVAL;
+		goto err_otp_unpack;
+	}
+	ret = regmap_write(cs35l41->regmap, CS35L41_TEST_KEY_CTL, 0x00000033);
+	if (ret < 0) {
+		dev_err(cs35l41->dev, "Write Lock key failed 2/2\n");
+		ret = -EINVAL;
+		goto err_otp_unpack;
+	}
+	ret = 0;
+
+err_otp_unpack:
+	kfree(otp_mem);
+	return ret;
+}
+
+/* This is currently called in INTERRUPT CONTEXT. Be careful */
+static int cs35l41_handle_dsp_event(struct cs35l41_private *cs35l41,
+				    char cmd, unsigned int data)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case EVENT_PORT_BLOCKED:
+		cs35l41->speaker_port_blocked = data;
+		break;
+	case EVENT_SPEAKER_OPEN_SHORT_STATUS:
+		cs35l41->speaker_open_short_status = data;
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
 static irqreturn_t cs35l41_irq(int irq, void *data)
 {
 	struct cs35l41_private *cs35l41 = data;
-	unsigned int status[4] = { 0, 0, 0, 0 };
-	unsigned int masks[4] = { 0, 0, 0, 0 };
-	int ret = IRQ_NONE;
+	unsigned int status[4] = {0, 0, 0, 0};
+	unsigned int masks[4] = {0, 0, 0, 0};
 	unsigned int i;
-
-	pm_runtime_get_sync(cs35l41->dev);
+	unsigned int mbox_3_val, mbox_3_cmd, mbox_3_data;
+	int ret;
 
 	for (i = 0; i < ARRAY_SIZE(status); i++) {
 		regmap_read(cs35l41->regmap,
@@ -377,12 +1755,25 @@
 
 	/* Check to see if unmasked bits are active */
 	if (!(status[0] & ~masks[0]) && !(status[1] & ~masks[1]) &&
-	    !(status[2] & ~masks[2]) && !(status[3] & ~masks[3]))
-		goto done;
+		!(status[2] & ~masks[2]) && !(status[3] & ~masks[3]))
+		return IRQ_NONE;
 
 	if (status[3] & CS35L41_OTP_BOOT_DONE) {
 		regmap_update_bits(cs35l41->regmap, CS35L41_IRQ1_MASK4,
-				   CS35L41_OTP_BOOT_DONE, CS35L41_OTP_BOOT_DONE);
+				CS35L41_OTP_BOOT_DONE, CS35L41_OTP_BOOT_DONE);
+	}
+
+	if (status[2] & CS35L41_PLL_LOCK) {
+		regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS3,
+			     CS35L41_PLL_LOCK);
+		if (cs35l41->pdata.shared_boost == SHARED_BOOST_PASSIVE) {
+			/* GPIO2 as open drain interrupt, GPIO1 as SYNC */
+			regmap_write(cs35l41->regmap, CS35L41_GPIO_PAD_CONTROL,
+				     0x02020000);
+			regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL3,
+					   CS35L41_SYNC_EN_MASK,
+					   CS35L41_SYNC_EN_MASK);
+		}
 	}
 
 	/*
@@ -391,170 +1782,326 @@
 	 * speaker out of Safe-Mode.
 	 */
 	if (status[0] & CS35L41_AMP_SHORT_ERR) {
-		dev_crit_ratelimited(cs35l41->dev, "Amp short error\n");
+		dev_crit(cs35l41->dev, "Amp short error\n");
 		regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS1,
-			     CS35L41_AMP_SHORT_ERR);
+					CS35L41_AMP_SHORT_ERR);
 		regmap_write(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN, 0);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-				   CS35L41_AMP_SHORT_ERR_RLS,
-				   CS35L41_AMP_SHORT_ERR_RLS);
+					CS35L41_AMP_SHORT_ERR_RLS,
+					CS35L41_AMP_SHORT_ERR_RLS);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-				   CS35L41_AMP_SHORT_ERR_RLS, 0);
-		ret = IRQ_HANDLED;
+					CS35L41_AMP_SHORT_ERR_RLS, 0);
 	}
 
 	if (status[0] & CS35L41_TEMP_WARN) {
-		dev_crit_ratelimited(cs35l41->dev, "Over temperature warning\n");
+		dev_crit(cs35l41->dev, "Over temperature warning\n");
 		regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS1,
-			     CS35L41_TEMP_WARN);
+					CS35L41_TEMP_WARN);
 		regmap_write(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN, 0);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-				   CS35L41_TEMP_WARN_ERR_RLS,
-				   CS35L41_TEMP_WARN_ERR_RLS);
+					CS35L41_TEMP_WARN_ERR_RLS,
+					CS35L41_TEMP_WARN_ERR_RLS);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-				   CS35L41_TEMP_WARN_ERR_RLS, 0);
-		ret = IRQ_HANDLED;
+					CS35L41_TEMP_WARN_ERR_RLS, 0);
 	}
 
 	if (status[0] & CS35L41_TEMP_ERR) {
-		dev_crit_ratelimited(cs35l41->dev, "Over temperature error\n");
+		dev_crit(cs35l41->dev, "Over temperature error\n");
 		regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS1,
-			     CS35L41_TEMP_ERR);
+					CS35L41_TEMP_ERR);
 		regmap_write(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN, 0);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-				   CS35L41_TEMP_ERR_RLS,
-				   CS35L41_TEMP_ERR_RLS);
+					CS35L41_TEMP_ERR_RLS,
+					CS35L41_TEMP_ERR_RLS);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-				   CS35L41_TEMP_ERR_RLS, 0);
-		ret = IRQ_HANDLED;
+					CS35L41_TEMP_ERR_RLS, 0);
 	}
 
 	if (status[0] & CS35L41_BST_OVP_ERR) {
-		dev_crit_ratelimited(cs35l41->dev, "VBST Over Voltage error\n");
+		dev_crit(cs35l41->dev, "VBST Over Voltage error\n");
 		regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL2,
-				   CS35L41_BST_EN_MASK, 0);
+					CS35L41_BST_EN_MASK, 0);
 		regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS1,
-			     CS35L41_BST_OVP_ERR);
+					CS35L41_BST_OVP_ERR);
 		regmap_write(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN, 0);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-				   CS35L41_BST_OVP_ERR_RLS,
-				   CS35L41_BST_OVP_ERR_RLS);
+					CS35L41_BST_OVP_ERR_RLS,
+					CS35L41_BST_OVP_ERR_RLS);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-				   CS35L41_BST_OVP_ERR_RLS, 0);
+					CS35L41_BST_OVP_ERR_RLS, 0);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL2,
-				   CS35L41_BST_EN_MASK,
-				   CS35L41_BST_EN_DEFAULT << CS35L41_BST_EN_SHIFT);
-		ret = IRQ_HANDLED;
+					CS35L41_BST_EN_MASK,
+					CS35L41_BST_EN_DEFAULT <<
+					CS35L41_BST_EN_SHIFT);
 	}
 
 	if (status[0] & CS35L41_BST_DCM_UVP_ERR) {
-		dev_crit_ratelimited(cs35l41->dev, "DCM VBST Under Voltage Error\n");
+		dev_crit(cs35l41->dev, "DCM VBST Under Voltage Error\n");
 		regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL2,
-				   CS35L41_BST_EN_MASK, 0);
+					CS35L41_BST_EN_MASK, 0);
 		regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS1,
-			     CS35L41_BST_DCM_UVP_ERR);
+					CS35L41_BST_DCM_UVP_ERR);
 		regmap_write(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN, 0);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-				   CS35L41_BST_UVP_ERR_RLS,
-				   CS35L41_BST_UVP_ERR_RLS);
+					CS35L41_BST_UVP_ERR_RLS,
+					CS35L41_BST_UVP_ERR_RLS);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-				   CS35L41_BST_UVP_ERR_RLS, 0);
+					CS35L41_BST_UVP_ERR_RLS, 0);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL2,
-				   CS35L41_BST_EN_MASK,
-				   CS35L41_BST_EN_DEFAULT << CS35L41_BST_EN_SHIFT);
-		ret = IRQ_HANDLED;
+					CS35L41_BST_EN_MASK,
+					CS35L41_BST_EN_DEFAULT <<
+					CS35L41_BST_EN_SHIFT);
 	}
 
 	if (status[0] & CS35L41_BST_SHORT_ERR) {
-		dev_crit_ratelimited(cs35l41->dev, "LBST error: powering off!\n");
+		dev_crit(cs35l41->dev, "LBST error: powering off!\n");
 		regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL2,
-				   CS35L41_BST_EN_MASK, 0);
+					CS35L41_BST_EN_MASK, 0);
 		regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS1,
-			     CS35L41_BST_SHORT_ERR);
+					CS35L41_BST_SHORT_ERR);
 		regmap_write(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN, 0);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-				   CS35L41_BST_SHORT_ERR_RLS,
-				   CS35L41_BST_SHORT_ERR_RLS);
+					CS35L41_BST_SHORT_ERR_RLS,
+					CS35L41_BST_SHORT_ERR_RLS);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PROTECT_REL_ERR_IGN,
-				   CS35L41_BST_SHORT_ERR_RLS, 0);
+					CS35L41_BST_SHORT_ERR_RLS, 0);
 		regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL2,
-				   CS35L41_BST_EN_MASK,
-				   CS35L41_BST_EN_DEFAULT << CS35L41_BST_EN_SHIFT);
-		ret = IRQ_HANDLED;
+					CS35L41_BST_EN_MASK,
+					CS35L41_BST_EN_DEFAULT <<
+					CS35L41_BST_EN_SHIFT);
 	}
 
-done:
-	pm_runtime_mark_last_busy(cs35l41->dev);
-	pm_runtime_put_autosuspend(cs35l41->dev);
+	if (status[1] & CS35L41_INT2_VIRT2_MBOX_WR) {
+		regmap_read(cs35l41->regmap,
+			    CS35L41_DSP_VIRT2_MBOX_3,
+			    &mbox_3_val);
+		mbox_3_cmd = mbox_3_val & CS35L41_MBOX3_CMD_MASK;
+		mbox_3_data = (mbox_3_val & CS35L41_MBOX3_DATA_MASK) >>
+			      CS35L41_MBOX3_DATA_SHIFT;
 
-	return ret;
+		ret = cs35l41_handle_dsp_event(cs35l41, mbox_3_cmd,
+					       mbox_3_data);
+
+		regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS2,
+			     CS35L41_INT2_VIRT2_MBOX_WR);
+	}
+
+	return IRQ_HANDLED;
 }
 
 static const struct reg_sequence cs35l41_pup_patch[] = {
-	{ CS35L41_TEST_KEY_CTL, 0x00000055 },
-	{ CS35L41_TEST_KEY_CTL, 0x000000AA },
-	{ 0x00002084, 0x002F1AA0 },
-	{ CS35L41_TEST_KEY_CTL, 0x000000CC },
-	{ CS35L41_TEST_KEY_CTL, 0x00000033 },
+	{0x00000040, 0x00000055},
+	{0x00000040, 0x000000AA},
+	{0x00002084, 0x002F1AA0},
+	{0x00000040, 0x000000CC},
+	{0x00000040, 0x00000033},
 };
 
 static const struct reg_sequence cs35l41_pdn_patch[] = {
-	{ CS35L41_TEST_KEY_CTL, 0x00000055 },
-	{ CS35L41_TEST_KEY_CTL, 0x000000AA },
-	{ 0x00002084, 0x002F1AA3 },
-	{ CS35L41_TEST_KEY_CTL, 0x000000CC },
-	{ CS35L41_TEST_KEY_CTL, 0x00000033 },
+	{0x00000040, 0x00000055},
+	{0x00000040, 0x000000AA},
+	{0x00002084, 0x002F1AA3},
+	{0x00000040, 0x000000CC},
+	{0x00000040, 0x00000033},
 };
 
-static int cs35l41_main_amp_event(struct snd_soc_dapm_widget *w,
-				  struct snd_kcontrol *kcontrol, int event)
+static void cs35l41_hibernate_work(struct work_struct *work)
 {
-	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
-	struct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(component);
-	unsigned int val;
+	struct delayed_work *dwork = to_delayed_work(work);
+	struct cs35l41_private *cs35l41 =
+		container_of(dwork, struct cs35l41_private, hb_work);
+
+	mutex_lock(&cs35l41->hb_lock);
+	cs35l41_enter_hibernate(cs35l41);
+	mutex_unlock(&cs35l41->hb_lock);
+}
+
+static int cs35l41_hibernate(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_component *component =
+		snd_soc_dapm_to_component(w->dapm);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
 	int ret = 0;
 
+	if (!cs35l41->dsp.running ||
+	     cs35l41->amp_hibernate == CS35L41_HIBERNATE_INCOMPATIBLE ||
+	     cs35l41->hibernate_force_wake)
+		return 0;
+
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
+		cancel_delayed_work(&cs35l41->hb_work);
+		mutex_lock(&cs35l41->hb_lock);
+		ret = cs35l41_exit_hibernate(cs35l41);
+		mutex_unlock(&cs35l41->hb_lock);
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		queue_delayed_work(cs35l41->wq, &cs35l41->hb_work,
+					msecs_to_jiffies(2000));
+		break;
+	default:
+		dev_err(cs35l41->dev, "Invalid event = 0x%x\n", event);
+		ret = -EINVAL;
+	}
+	return ret;
+}
+
+static bool cs35l41_need_auto_vol_ramp(struct cs35l41_private *cs35l41)
+{
+	bool ramp = false;
+	ktime_t curr_timestamp;
+	s64 dev_timeout = (s64)cs35l41->vol_ctl.auto_ramp_timeout * 1000000;
+	s64 elapsed_time;
+
+	if (cs35l41->vol_ctl.prev_active_dev == CS35L41_OUTPUT_DEV_RCV &&
+	    cs35l41->vol_ctl.output_dev == CS35L41_OUTPUT_DEV_SPK) {
+		if (cs35l41->vol_ctl.auto_ramp_timeout == 0) {
+			/* Never ramp */
+		} else if (cs35l41->vol_ctl.auto_ramp_timeout ==
+			   CS35L41_MAX_AUTO_RAMP_TIMEOUT) {
+			/* Always ramp */
+			ramp = true;
+		} else {
+			/*
+			 * Guaranteed:
+			 * 0 < auto_ramp_timeout < CS35L41_MAX_AUTO_RAMP_TIMEOUT
+			 */
+			curr_timestamp = ktime_get();
+			elapsed_time = ktime_to_ns(curr_timestamp) -
+				ktime_to_ns(cs35l41->vol_ctl.dev_timestamp);
+			if (elapsed_time < dev_timeout)
+				ramp = true;
+			dev_dbg(cs35l41->dev,
+				"elapsed_time:%lld dev_timeout:%lld\n",
+				elapsed_time, dev_timeout);
+		}
+	}
+
+	return ramp;
+}
+
+static int cs35l41_main_amp_event(struct snd_soc_dapm_widget *w,
+		struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_component *component =
+		snd_soc_dapm_to_component(w->dapm);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+	enum cs35l41_cspl_mbox_cmd mboxcmd = CSPL_MBOX_CMD_NONE;
+	int ret = 0;
+	int i;
+	bool pdn;
+	unsigned int val;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
 		regmap_multi_reg_write_bypassed(cs35l41->regmap,
-						cs35l41_pup_patch,
-						ARRAY_SIZE(cs35l41_pup_patch));
+					cs35l41_pup_patch,
+					ARRAY_SIZE(cs35l41_pup_patch));
 
-		cs35l41_global_enable(cs35l41->regmap, cs35l41->hw_cfg.bst_type, 1);
+		if (cs35l41->halo_booted)
+			/*
+			 * Set GPIO-controlled GLOBAL_EN by firmware
+			 * according to mixer setting
+			 */
+			regmap_write(cs35l41->regmap, CS35L41_DSP_VIRT1_MBOX_8,
+				     cs35l41->gpi_global_en);
+
+		regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL1,
+				CS35L41_GLOBAL_EN_MASK,
+				1 << CS35L41_GLOBAL_EN_SHIFT);
+
+		usleep_range(1000, 1100);
+
+		atomic_set(&cs35l41->vol_ctl.playback, 1);
+		if (atomic_read(&cs35l41->vol_ctl.manual_ramp) ||
+		    cs35l41_need_auto_vol_ramp(cs35l41))
+			/* Enable volume ramp */
+			queue_work(cs35l41->vol_ctl.ramp_wq,
+				   &cs35l41->vol_ctl.ramp_work);
 		break;
 	case SND_SOC_DAPM_POST_PMD:
-		cs35l41_global_enable(cs35l41->regmap, cs35l41->hw_cfg.bst_type, 0);
+		if (cs35l41->dsp.running) {
+			if (cs35l41->reload_tuning) {
+				mboxcmd = CSPL_MBOX_CMD_STOP_PRE_REINIT;
+				/*
+				 * Reset reload_tuning, so driver does not
+				 * continuously reload tuning file
+				 */
+				cs35l41->reload_tuning = false;
+			} else {
+				mboxcmd = CSPL_MBOX_CMD_PAUSE;
+			}
+
+			ret = cs35l41_set_cspl_mbox_cmd(cs35l41, mboxcmd);
+
+			/* Disable GPIO-controlled GLOBAL_EN by firmware */
+			regmap_write(cs35l41->regmap,
+				     CS35L41_DSP_VIRT1_MBOX_8, 0);
+		}
 
-		ret = regmap_read_poll_timeout(cs35l41->regmap, CS35L41_IRQ1_STATUS1,
-					       val, val &  CS35L41_PDN_DONE_MASK,
-					       1000, 100000);
-		if (ret)
-			dev_warn(cs35l41->dev, "PDN failed: %d\n", ret);
+		regmap_read(cs35l41->regmap, CS35L41_PWR_CTRL1, &val);
+		if (val & CS35L41_GLOBAL_EN_MASK) {
+			regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL1,
+					CS35L41_GLOBAL_EN_MASK, 0);
+
+			pdn = false;
+			for (i = 0; i < 100; i++) {
+				regmap_read(cs35l41->regmap,
+					CS35L41_IRQ1_STATUS1,
+					&val);
+				if (val & CS35L41_PDN_DONE_MASK) {
+					pdn = true;
+					break;
+				}
+				usleep_range(1000, 1100);
+			}
 
-		regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS1,
-			     CS35L41_PDN_DONE_MASK);
+			if (!pdn)
+				dev_warn(cs35l41->dev, "PDN failed\n");
+
+			regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS1,
+					CS35L41_PDN_DONE_MASK);
+		}
 
 		regmap_multi_reg_write_bypassed(cs35l41->regmap,
-						cs35l41_pdn_patch,
-						ARRAY_SIZE(cs35l41_pdn_patch));
+					cs35l41_pdn_patch,
+					ARRAY_SIZE(cs35l41_pdn_patch));
+		if (cs35l41->pdata.shared_boost == SHARED_BOOST_PASSIVE) {
+			regmap_update_bits(cs35l41->regmap, CS35L41_PWR_CTRL3,
+					   CS35L41_SYNC_EN_MASK, 0);
+			/* GPIO2 as open drain interrupt, GPIO1 as hi-z input */
+			regmap_write(cs35l41->regmap, CS35L41_GPIO_PAD_CONTROL,
+				     0x02000000);
+		}
+		atomic_set(&cs35l41->vol_ctl.playback, 0);
+		cs35l41_abort_ramp(cs35l41);
+		cs35l41->vol_ctl.prev_active_dev = cs35l41->vol_ctl.output_dev;
+		if (cs35l41->vol_ctl.output_dev == CS35L41_OUTPUT_DEV_RCV &&
+		    cs35l41->vol_ctl.auto_ramp_timeout > 0 &&
+		    cs35l41->vol_ctl.auto_ramp_timeout <
+		    CS35L41_MAX_AUTO_RAMP_TIMEOUT)
+			/* Auto Receiver Timeout is used */
+			cs35l41->vol_ctl.dev_timestamp = ktime_get();
+		cs35l41->enabled = false;
 		break;
 	default:
 		dev_err(cs35l41->dev, "Invalid event = 0x%x\n", event);
 		ret = -EINVAL;
 	}
-
 	return ret;
 }
 
 static const struct snd_soc_dapm_widget cs35l41_dapm_widgets[] = {
+
 	SND_SOC_DAPM_SPK("DSP1 Preload", NULL),
-	SND_SOC_DAPM_SUPPLY_S("DSP1 Preloader", 100, SND_SOC_NOPM, 0, 0,
-			      cs35l41_dsp_preload_ev,
-			      SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_SUPPLY_S("DSP1 Preloader", 100,
+				SND_SOC_NOPM, 0, 0, cs35l41_dsp_power_ev,
+				SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD),
 	SND_SOC_DAPM_OUT_DRV_E("DSP1", SND_SOC_NOPM, 0, 0, NULL, 0,
-			       cs35l41_dsp_audio_ev,
-			       SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
-
+				cs35l41_dsp_load_ev, SND_SOC_DAPM_POST_PMU),
 	SND_SOC_DAPM_OUTPUT("SPK"),
 
 	SND_SOC_DAPM_AIF_IN("ASPRX1", NULL, 0, CS35L41_SP_ENABLES, 16, 0),
@@ -564,29 +2111,24 @@
 	SND_SOC_DAPM_AIF_OUT("ASPTX3", NULL, 0, CS35L41_SP_ENABLES, 2, 0),
 	SND_SOC_DAPM_AIF_OUT("ASPTX4", NULL, 0, CS35L41_SP_ENABLES, 3, 0),
 
-	SND_SOC_DAPM_SIGGEN("VSENSE"),
-	SND_SOC_DAPM_SIGGEN("ISENSE"),
-	SND_SOC_DAPM_SIGGEN("VP"),
-	SND_SOC_DAPM_SIGGEN("VBST"),
-	SND_SOC_DAPM_SIGGEN("TEMP"),
-
-	SND_SOC_DAPM_SUPPLY("VMON", CS35L41_PWR_CTRL2, 12, 0, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("IMON", CS35L41_PWR_CTRL2, 13, 0, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("VPMON", CS35L41_PWR_CTRL2, 8, 0, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("VBSTMON", CS35L41_PWR_CTRL2, 9, 0, NULL, 0),
-	SND_SOC_DAPM_SUPPLY("TEMPMON", CS35L41_PWR_CTRL2, 10, 0, NULL, 0),
-
-	SND_SOC_DAPM_ADC("VMON ADC", NULL, SND_SOC_NOPM, 0, 0),
-	SND_SOC_DAPM_ADC("IMON ADC", NULL, SND_SOC_NOPM, 0, 0),
-	SND_SOC_DAPM_ADC("VPMON ADC", NULL, SND_SOC_NOPM, 0, 0),
-	SND_SOC_DAPM_ADC("VBSTMON ADC", NULL, SND_SOC_NOPM, 0, 0),
-	SND_SOC_DAPM_ADC("TEMPMON ADC", NULL, SND_SOC_NOPM, 0, 0),
-
+	SND_SOC_DAPM_ADC("VMON ADC", NULL, CS35L41_PWR_CTRL2, 12, 0),
+	SND_SOC_DAPM_ADC("IMON ADC", NULL, CS35L41_PWR_CTRL2, 13, 0),
+	SND_SOC_DAPM_ADC("VPMON ADC", NULL, CS35L41_PWR_CTRL2, 8, 0),
+	SND_SOC_DAPM_ADC("VBSTMON ADC", NULL, CS35L41_PWR_CTRL2, 9, 0),
+	SND_SOC_DAPM_ADC("TEMPMON ADC", NULL, CS35L41_PWR_CTRL2, 10, 0),
 	SND_SOC_DAPM_ADC("CLASS H", NULL, CS35L41_PWR_CTRL3, 4, 0),
 
 	SND_SOC_DAPM_OUT_DRV_E("Main AMP", CS35L41_PWR_CTRL2, 0, 0, NULL, 0,
-			       cs35l41_main_amp_event,
-			       SND_SOC_DAPM_POST_PMD |	SND_SOC_DAPM_PRE_PMU),
+				cs35l41_main_amp_event,
+				SND_SOC_DAPM_POST_PMD |	SND_SOC_DAPM_POST_PMU),
+	SND_SOC_DAPM_SUPPLY("Hibernate",  SND_SOC_NOPM, 0, 0,
+			    cs35l41_hibernate,
+			    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_INPUT("VP"),
+	SND_SOC_DAPM_INPUT("VBST"),
+	SND_SOC_DAPM_INPUT("ISENSE"),
+	SND_SOC_DAPM_INPUT("VSENSE"),
+	SND_SOC_DAPM_INPUT("TEMP"),
 
 	SND_SOC_DAPM_MUX("ASP TX1 Source", SND_SOC_NOPM, 0, 0, &asp_tx1_mux),
 	SND_SOC_DAPM_MUX("ASP TX2 Source", SND_SOC_NOPM, 0, 0, &asp_tx2_mux),
@@ -596,15 +2138,34 @@
 	SND_SOC_DAPM_MUX("DSP RX2 Source", SND_SOC_NOPM, 0, 0, &dsp_rx2_mux),
 	SND_SOC_DAPM_MUX("PCM Source", SND_SOC_NOPM, 0, 0, &pcm_source_mux),
 	SND_SOC_DAPM_SWITCH("DRE", SND_SOC_NOPM, 0, 0, &dre_ctrl),
+	SND_SOC_DAPM_SWITCH("VBSTMON Output", SND_SOC_NOPM, 0, 0,
+						&vbstmon_out_ctrl),
+	SND_SOC_DAPM_SWITCH("AMP Enable", SND_SOC_NOPM, 0, 1, &amp_enable_ctrl),
 };
 
 static const struct snd_soc_dapm_route cs35l41_audio_map[] = {
+
+	{ "DSP1", NULL, "DSP1 Preloader" },
+	{ "DSP1 Preload", NULL, "DSP1 Preloader" },
+
+	{"DSP RX1 Source", "VMON", "VMON ADC"},
+	{"DSP RX1 Source", "IMON", "IMON ADC"},
+	{"DSP RX1 Source", "VPMON", "VPMON ADC"},
+	{"DSP RX1 Source", "DSPTX1", "DSP1"},
+	{"DSP RX1 Source", "DSPTX2", "DSP1"},
 	{"DSP RX1 Source", "ASPRX1", "ASPRX1"},
 	{"DSP RX1 Source", "ASPRX2", "ASPRX2"},
+	{"DSP RX1 Source", "Zero", "ASPRX1"},
+	{"DSP1", NULL, "DSP RX1 Source"},
+
+	{"DSP RX2 Source", "VMON", "VMON ADC"},
+	{"DSP RX2 Source", "IMON", "IMON ADC"},
+	{"DSP RX2 Source", "VPMON", "VPMON ADC"},
+	{"DSP RX2 Source", "DSPTX1", "DSP1"},
+	{"DSP RX2 Source", "DSPTX2", "DSP1"},
 	{"DSP RX2 Source", "ASPRX1", "ASPRX1"},
 	{"DSP RX2 Source", "ASPRX2", "ASPRX2"},
-
-	{"DSP1", NULL, "DSP RX1 Source"},
+	{"DSP RX2 Source", "Zero", "ASPRX1"},
 	{"DSP1", NULL, "DSP RX2 Source"},
 
 	{"ASP TX1 Source", "VMON", "VMON ADC"},
@@ -648,95 +2209,132 @@
 	{"AMP Capture", NULL, "ASPTX3"},
 	{"AMP Capture", NULL, "ASPTX4"},
 
-	{"DSP1", NULL, "VMON"},
-	{"DSP1", NULL, "IMON"},
-	{"DSP1", NULL, "VPMON"},
-	{"DSP1", NULL, "VBSTMON"},
-	{"DSP1", NULL, "TEMPMON"},
-
-	{"VMON ADC", NULL, "VMON"},
-	{"IMON ADC", NULL, "IMON"},
-	{"VPMON ADC", NULL, "VPMON"},
-	{"VBSTMON ADC", NULL, "VBSTMON"},
-	{"TEMPMON ADC", NULL, "TEMPMON"},
-
-	{"VMON ADC", NULL, "VSENSE"},
-	{"IMON ADC", NULL, "ISENSE"},
-	{"VPMON ADC", NULL, "VP"},
-	{"VBSTMON ADC", NULL, "VBST"},
-	{"TEMPMON ADC", NULL, "TEMP"},
-
-	{"DSP1 Preload", NULL, "DSP1 Preloader"},
-	{"DSP1", NULL, "DSP1 Preloader"},
-
-	{"ASPRX1", NULL, "AMP Playback"},
-	{"ASPRX2", NULL, "AMP Playback"},
+	{"VMON ADC", NULL, "ASPRX1"},
+	{"IMON ADC", NULL, "ASPRX1"},
+	{"VPMON ADC", NULL, "ASPRX1"},
+	{"TEMPMON ADC", NULL, "ASPRX1"},
+	{"VBSTMON ADC", NULL, "ASPRX1"},
+
+	{"VBSTMON Output", "Switch", "VBST"},
+	{"CLASS H", NULL, "VBSTMON Output"},
+	{"VBSTMON ADC", NULL, "VBSTMON Output"},
+
+	{"DSP1", NULL, "IMON ADC"},
+	{"DSP1", NULL, "VMON ADC"},
+	{"DSP1", NULL, "VBSTMON ADC"},
+	{"DSP1", NULL, "VPMON ADC"},
+	{"DSP1", NULL, "TEMPMON ADC"},
+
+	{"AMP Enable", "Switch", "AMP Playback"},
+	{"ASPRX1", NULL, "AMP Enable"},
+	{"ASPRX2", NULL, "AMP Enable"},
 	{"DRE", "Switch", "CLASS H"},
 	{"Main AMP", NULL, "CLASS H"},
 	{"Main AMP", NULL, "DRE"},
 	{"SPK", NULL, "Main AMP"},
+	{"SPK", NULL, "Hibernate"},
 
 	{"PCM Source", "ASP", "ASPRX1"},
 	{"PCM Source", "DSP", "DSP1"},
 	{"CLASS H", NULL, "PCM Source"},
-};
-
-static int cs35l41_set_channel_map(struct snd_soc_dai *dai, unsigned int tx_n,
-				   unsigned int *tx_slot, unsigned int rx_n, unsigned int *rx_slot)
-{
-	struct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(dai->component);
 
-	return cs35l41_set_channels(cs35l41->dev, cs35l41->regmap, tx_n, tx_slot, rx_n, rx_slot);
-}
-
-static int cs35l41_set_dai_fmt(struct snd_soc_dai *dai, unsigned int fmt)
-{
-	struct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(dai->component);
-	unsigned int daifmt = 0;
+};
 
-	switch (fmt & SND_SOC_DAIFMT_CLOCK_PROVIDER_MASK) {
-	case SND_SOC_DAIFMT_CBP_CFP:
-		daifmt |= CS35L41_SCLK_MSTR_MASK | CS35L41_LRCLK_MSTR_MASK;
+static const struct wm_adsp_region cs35l41_dsp1_regions[] = {
+	{ .type = WMFW_HALO_PM_PACKED,	.base = CS35L41_DSP1_PMEM_0 },
+	{ .type = WMFW_HALO_XM_PACKED,	.base = CS35L41_DSP1_XMEM_PACK_0 },
+	{ .type = WMFW_HALO_YM_PACKED,	.base = CS35L41_DSP1_YMEM_PACK_0 },
+	{. type = WMFW_ADSP2_XM,	.base = CS35L41_DSP1_XMEM_UNPACK24_0},
+	{. type = WMFW_ADSP2_YM,	.base = CS35L41_DSP1_YMEM_UNPACK24_0},
+};
+
+static int cs35l41_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	struct cs35l41_private *cs35l41 =
+			snd_soc_component_get_drvdata(codec_dai->component);
+	unsigned int asp_fmt, lrclk_fmt, sclk_fmt, clock_mode;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		clock_mode = 1;
 		break;
-	case SND_SOC_DAIFMT_CBC_CFC:
+	case SND_SOC_DAIFMT_CBS_CFS:
+		clock_mode = 0;
 		break;
 	default:
-		dev_warn(cs35l41->dev, "Mixed provider/consumer mode unsupported\n");
+		dev_warn(cs35l41->dev,
+			"%s: Mixed master mode unsupported\n", __func__);
 		return -EINVAL;
 	}
 
 	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
 	case SND_SOC_DAIFMT_DSP_A:
+		asp_fmt = 0;
+		cs35l41->i2s_mode = false;
 		break;
 	case SND_SOC_DAIFMT_I2S:
-		daifmt |= 2 << CS35L41_ASP_FMT_SHIFT;
+		asp_fmt = 2;
+		cs35l41->i2s_mode = true;
 		break;
 	default:
-		dev_warn(cs35l41->dev, "Invalid or unsupported DAI format\n");
+		dev_warn(cs35l41->dev,
+			"%s: Invalid or unsupported DAI format\n", __func__);
 		return -EINVAL;
 	}
 
 	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
 	case SND_SOC_DAIFMT_NB_IF:
-		daifmt |= CS35L41_LRCLK_INV_MASK;
+		lrclk_fmt = 1;
+		sclk_fmt = 0;
 		break;
 	case SND_SOC_DAIFMT_IB_NF:
-		daifmt |= CS35L41_SCLK_INV_MASK;
+		lrclk_fmt = 0;
+		sclk_fmt = 1;
 		break;
 	case SND_SOC_DAIFMT_IB_IF:
-		daifmt |= CS35L41_LRCLK_INV_MASK | CS35L41_SCLK_INV_MASK;
+		lrclk_fmt = 1;
+		sclk_fmt = 1;
 		break;
 	case SND_SOC_DAIFMT_NB_NF:
+		lrclk_fmt = 0;
+		sclk_fmt = 0;
 		break;
 	default:
-		dev_warn(cs35l41->dev, "Invalid DAI clock INV\n");
+		dev_warn(cs35l41->dev,
+			"%s: Invalid DAI clock INV\n", __func__);
 		return -EINVAL;
 	}
 
-	return regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
-				  CS35L41_SCLK_MSTR_MASK | CS35L41_LRCLK_MSTR_MASK |
-				  CS35L41_ASP_FMT_MASK | CS35L41_LRCLK_INV_MASK |
-				  CS35L41_SCLK_INV_MASK, daifmt);
+	cs35l41->reset_cache.clock_mode = clock_mode;
+	cs35l41->reset_cache.asp_fmt = asp_fmt;
+	cs35l41->reset_cache.lrclk_fmt = lrclk_fmt;
+	cs35l41->reset_cache.sclk_fmt = sclk_fmt;
+	/* Amp is in hibernation. Cached values will be applied at wakeup. */
+	if (cs35l41->amp_hibernate == CS35L41_HIBERNATE_STANDBY)
+		return 0;
+
+	regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
+					CS35L41_ASP_FMT_MASK,
+					asp_fmt << CS35L41_ASP_FMT_SHIFT);
+
+	regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
+				CS35L41_SCLK_MSTR_MASK,
+				clock_mode << CS35L41_SCLK_MSTR_SHIFT);
+	regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
+				CS35L41_LRCLK_MSTR_MASK,
+				clock_mode << CS35L41_LRCLK_MSTR_SHIFT);
+
+	cs35l41->lrclk_fmt = lrclk_fmt;
+	cs35l41->sclk_fmt = sclk_fmt;
+
+	regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
+				CS35L41_LRCLK_INV_MASK,
+				lrclk_fmt << CS35L41_LRCLK_INV_SHIFT);
+	regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
+				CS35L41_SCLK_INV_MASK,
+				sclk_fmt << CS35L41_SCLK_INV_SHIFT);
+
+	return 0;
 }
 
 struct cs35l41_global_fs_config {
@@ -764,10 +2362,11 @@
 				 struct snd_pcm_hw_params *params,
 				 struct snd_soc_dai *dai)
 {
-	struct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(dai->component);
-	unsigned int rate = params_rate(params);
-	u8 asp_wl;
+	struct cs35l41_private *cs35l41 =
+			snd_soc_component_get_drvdata(dai->component);
 	int i;
+	unsigned int rate = params_rate(params);
+	u8 asp_width, asp_wl;
 
 	for (i = 0; i < ARRAY_SIZE(cs35l41_fs_rates); i++) {
 		if (rate == cs35l41_fs_rates[i].rate)
@@ -775,31 +2374,43 @@
 	}
 
 	if (i >= ARRAY_SIZE(cs35l41_fs_rates)) {
-		dev_err(cs35l41->dev, "Unsupported rate: %u\n", rate);
+		dev_err(cs35l41->dev, "%s: Unsupported rate: %u\n",
+						__func__, rate);
 		return -EINVAL;
 	}
 
 	asp_wl = params_width(params);
+	asp_width = params_physical_width(params);
+
+
+	cs35l41->reset_cache.asp_wl = asp_wl;
+	cs35l41->reset_cache.asp_width = asp_width;
+	if (i < ARRAY_SIZE(cs35l41_fs_rates))
+		cs35l41->reset_cache.fs_cfg = cs35l41_fs_rates[i].fs_cfg;
+
+	/* Amp is in hibernation. Cached values will be applied at wakeup. */
+	if (cs35l41->amp_hibernate == CS35L41_HIBERNATE_STANDBY)
+		return 0;
 
 	if (i < ARRAY_SIZE(cs35l41_fs_rates))
 		regmap_update_bits(cs35l41->regmap, CS35L41_GLOBAL_CLK_CTRL,
-				   CS35L41_GLOBAL_FS_MASK,
-				   cs35l41_fs_rates[i].fs_cfg << CS35L41_GLOBAL_FS_SHIFT);
+			CS35L41_GLOBAL_FS_MASK,
+			cs35l41_fs_rates[i].fs_cfg << CS35L41_GLOBAL_FS_SHIFT);
 
 	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
 		regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
-				   CS35L41_ASP_WIDTH_RX_MASK,
-				   asp_wl << CS35L41_ASP_WIDTH_RX_SHIFT);
+				CS35L41_ASP_WIDTH_RX_MASK,
+				asp_width << CS35L41_ASP_WIDTH_RX_SHIFT);
 		regmap_update_bits(cs35l41->regmap, CS35L41_SP_RX_WL,
-				   CS35L41_ASP_RX_WL_MASK,
-				   asp_wl << CS35L41_ASP_RX_WL_SHIFT);
+				CS35L41_ASP_RX_WL_MASK,
+				asp_wl << CS35L41_ASP_RX_WL_SHIFT);
 	} else {
 		regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
-				   CS35L41_ASP_WIDTH_TX_MASK,
-				   asp_wl << CS35L41_ASP_WIDTH_TX_SHIFT);
+				CS35L41_ASP_WIDTH_TX_MASK,
+				asp_width << CS35L41_ASP_WIDTH_TX_SHIFT);
 		regmap_update_bits(cs35l41->regmap, CS35L41_SP_TX_WL,
-				   CS35L41_ASP_TX_WL_MASK,
-				   asp_wl << CS35L41_ASP_TX_WL_SHIFT);
+				CS35L41_ASP_TX_WL_MASK,
+				asp_wl << CS35L41_ASP_TX_WL_SHIFT);
 	}
 
 	return 0;
@@ -832,83 +2443,98 @@
 {
 	if (substream->runtime)
 		return snd_pcm_hw_constraint_list(substream->runtime, 0,
-						  SNDRV_PCM_HW_PARAM_RATE,
-						  &cs35l41_constraints);
+				SNDRV_PCM_HW_PARAM_RATE, &cs35l41_constraints);
 	return 0;
 }
 
 static int cs35l41_component_set_sysclk(struct snd_soc_component *component,
-					int clk_id, int source,
-					unsigned int freq, int dir)
+				int clk_id, int source, unsigned int freq,
+				int dir)
 {
-	struct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(component);
-	int extclk_cfg, clksrc;
+	struct cs35l41_private *cs35l41 =
+				       snd_soc_component_get_drvdata(component);
+
+	cs35l41->extclk_freq = freq;
 
 	switch (clk_id) {
-	case CS35L41_CLKID_SCLK:
-		clksrc = CS35L41_PLLSRC_SCLK;
+	case 0:
+		cs35l41->clksrc = CS35L41_PLLSRC_SCLK;
 		break;
-	case CS35L41_CLKID_LRCLK:
-		clksrc = CS35L41_PLLSRC_LRCLK;
+	case 1:
+		cs35l41->clksrc = CS35L41_PLLSRC_LRCLK;
 		break;
-	case CS35L41_CLKID_MCLK:
-		clksrc = CS35L41_PLLSRC_MCLK;
+	case 2:
+		cs35l41->clksrc = CS35L41_PLLSRC_PDMCLK;
+		break;
+	case 3:
+		cs35l41->clksrc = CS35L41_PLLSRC_SELF;
+		break;
+	case 4:
+		cs35l41->clksrc = CS35L41_PLLSRC_MCLK;
 		break;
 	default:
 		dev_err(cs35l41->dev, "Invalid CLK Config\n");
 		return -EINVAL;
 	}
 
-	extclk_cfg = cs35l41_get_clk_config(freq);
+	cs35l41->extclk_cfg = cs35l41_get_clk_config(freq);
 
-	if (extclk_cfg < 0) {
+	if (cs35l41->extclk_cfg < 0) {
 		dev_err(cs35l41->dev, "Invalid CLK Config: %d, freq: %u\n",
-			extclk_cfg, freq);
+			cs35l41->extclk_cfg, freq);
 		return -EINVAL;
 	}
 
+	cs35l41->reset_cache.extclk_cfg = true;
+	/* Amp is in hibernation. Clock config will be restored at wakeup. */
+	if (cs35l41->amp_hibernate == CS35L41_HIBERNATE_STANDBY)
+		return 0;
+
 	regmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,
-			   CS35L41_PLL_OPENLOOP_MASK,
-			   1 << CS35L41_PLL_OPENLOOP_SHIFT);
+			CS35L41_PLL_OPENLOOP_MASK,
+			1 << CS35L41_PLL_OPENLOOP_SHIFT);
 	regmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,
-			   CS35L41_REFCLK_FREQ_MASK,
-			   extclk_cfg << CS35L41_REFCLK_FREQ_SHIFT);
+			CS35L41_REFCLK_FREQ_MASK,
+			cs35l41->extclk_cfg << CS35L41_REFCLK_FREQ_SHIFT);
 	regmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,
-			   CS35L41_PLL_CLK_EN_MASK,
-			   0 << CS35L41_PLL_CLK_EN_SHIFT);
+			CS35L41_PLL_CLK_EN_MASK,
+			0 << CS35L41_PLL_CLK_EN_SHIFT);
 	regmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,
-			   CS35L41_PLL_CLK_SEL_MASK, clksrc);
+			CS35L41_PLL_CLK_SEL_MASK, cs35l41->clksrc);
 	regmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,
-			   CS35L41_PLL_OPENLOOP_MASK,
-			   0 << CS35L41_PLL_OPENLOOP_SHIFT);
+			CS35L41_PLL_OPENLOOP_MASK,
+			0 << CS35L41_PLL_OPENLOOP_SHIFT);
 	regmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,
-			   CS35L41_PLL_CLK_EN_MASK,
-			   1 << CS35L41_PLL_CLK_EN_SHIFT);
+			CS35L41_PLL_CLK_EN_MASK,
+			1 << CS35L41_PLL_CLK_EN_SHIFT);
 
 	return 0;
 }
 
 static int cs35l41_dai_set_sysclk(struct snd_soc_dai *dai,
-				  int clk_id, unsigned int freq, int dir)
+					int clk_id, unsigned int freq, int dir)
 {
-	struct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(dai->component);
+	struct cs35l41_private *cs35l41 =
+				  snd_soc_component_get_drvdata(dai->component);
+	int fsIndex;
 	unsigned int fs1_val;
 	unsigned int fs2_val;
 	unsigned int val;
-	int fsindex;
 
-	fsindex = cs35l41_get_fs_mon_config_index(freq);
-	if (fsindex < 0) {
-		dev_err(cs35l41->dev, "Invalid CLK Config freq: %u\n", freq);
-		return -EINVAL;
-	}
+	/* Need the SCLK Frequency regardless of sysclk source */
+	cs35l41->sclk = freq;
 
 	dev_dbg(cs35l41->dev, "Set DAI sysclk %d\n", freq);
-
-	if (freq <= 6144000) {
+	if (cs35l41->sclk <= 6144000) {
 		/* Use the lookup table */
-		fs1_val = cs35l41_fs_mon[fsindex].fs1;
-		fs2_val = cs35l41_fs_mon[fsindex].fs2;
+		fsIndex = cs35l41_get_fs_mon_config_index(freq);
+		if (fsIndex < 0) {
+			dev_err(cs35l41->dev, "Invalid CLK Config freq: %u\n", freq);
+			return -EINVAL;
+		}
+
+		fs1_val = cs35l41_fs_mon[fsIndex].fs1;
+		fs2_val = cs35l41_fs_mon[fsIndex].fs2;
 	} else {
 		/* Use hard-coded values */
 		fs1_val = 0x10;
@@ -922,62 +2548,404 @@
 	return 0;
 }
 
-static int cs35l41_set_pdata(struct cs35l41_private *cs35l41)
+static int cs35l41_boost_config(struct cs35l41_private *cs35l41,
+		int boost_ind, int boost_cap, int boost_ipk)
 {
-	struct cs35l41_hw_cfg *hw_cfg = &cs35l41->hw_cfg;
 	int ret;
-
-	if (!hw_cfg->valid)
+	unsigned char bst_lbst_val, bst_cbst_range, bst_ipk_scaled;
+	struct regmap *regmap = cs35l41->regmap;
+	struct device *dev = cs35l41->dev;
+
+	switch (boost_ind) {
+	case 1000:	/* 1.0 uH */
+		bst_lbst_val = 0;
+		break;
+	case 1200:	/* 1.2 uH */
+		bst_lbst_val = 1;
+		break;
+	case 1500:	/* 1.5 uH */
+		bst_lbst_val = 2;
+		break;
+	case 2200:	/* 2.2 uH */
+		bst_lbst_val = 3;
+		break;
+	default:
+		dev_err(dev, "Invalid boost inductor value: %d nH\n",
+				boost_ind);
 		return -EINVAL;
+	}
 
-	if (hw_cfg->bst_type == CS35L41_EXT_BOOST_NO_VSPK_SWITCH)
-		return -EINVAL;
+	switch (boost_cap) {
+	case 0 ... 19:
+		bst_cbst_range = 0;
+		break;
+	case 20 ... 50:
+		bst_cbst_range = 1;
+		break;
+	case 51 ... 100:
+		bst_cbst_range = 2;
+		break;
+	case 101 ... 200:
+		bst_cbst_range = 3;
+		break;
+	default:	/* 201 uF and greater */
+		bst_cbst_range = 4;
+	}
 
-	/* Required */
-	ret = cs35l41_init_boost(cs35l41->dev, cs35l41->regmap, hw_cfg);
-	if (ret)
+	ret = regmap_update_bits(regmap, CS35L41_BSTCVRT_COEFF,
+			CS35L41_BST_K1_MASK,
+			cs35l41_bst_k1_table[bst_lbst_val][bst_cbst_range]
+				<< CS35L41_BST_K1_SHIFT);
+	if (ret) {
+		dev_err(dev, "Failed to write boost K1 coefficient\n");
 		return ret;
+	}
 
-	/* Optional */
-	if (hw_cfg->dout_hiz <= CS35L41_ASP_DOUT_HIZ_MASK && hw_cfg->dout_hiz >= 0)
-		regmap_update_bits(cs35l41->regmap, CS35L41_SP_HIZ_CTRL, CS35L41_ASP_DOUT_HIZ_MASK,
-				   hw_cfg->dout_hiz);
+	ret = regmap_update_bits(regmap, CS35L41_BSTCVRT_COEFF,
+			CS35L41_BST_K2_MASK,
+			cs35l41_bst_k2_table[bst_lbst_val][bst_cbst_range]
+				<< CS35L41_BST_K2_SHIFT);
+	if (ret) {
+		dev_err(dev, "Failed to write boost K2 coefficient\n");
+		return ret;
+	}
+
+	ret = regmap_update_bits(regmap, CS35L41_BSTCVRT_SLOPE_LBST,
+			CS35L41_BST_SLOPE_MASK,
+			cs35l41_bst_slope_table[bst_lbst_val]
+				<< CS35L41_BST_SLOPE_SHIFT);
+	if (ret) {
+		dev_err(dev, "Failed to write boost slope coefficient\n");
+		return ret;
+	}
+
+	ret = regmap_update_bits(regmap, CS35L41_BSTCVRT_SLOPE_LBST,
+			CS35L41_BST_LBST_VAL_MASK,
+			bst_lbst_val << CS35L41_BST_LBST_VAL_SHIFT);
+	if (ret) {
+		dev_err(dev, "Failed to write boost inductor value\n");
+		return ret;
+	}
+
+	if ((boost_ipk < 1600) || (boost_ipk > 4500)) {
+		dev_err(dev, "Invalid boost inductor peak current: %d mA\n",
+				boost_ipk);
+		return -EINVAL;
+	}
+	bst_ipk_scaled = ((boost_ipk - 1600) / 50) + 0x10;
+
+	ret = regmap_update_bits(regmap, CS35L41_BSTCVRT_PEAK_CUR,
+			CS35L41_BST_IPK_MASK,
+			bst_ipk_scaled << CS35L41_BST_IPK_SHIFT);
+	if (ret) {
+		dev_err(dev, "Failed to write boost inductor peak current\n");
+		return ret;
+	}
 
 	return 0;
 }
 
-static const struct snd_soc_dapm_route cs35l41_ext_bst_routes[] = {
-	{"Main AMP", NULL, "VSPK"},
+static const struct reg_sequence cs35l41_active_seq[] = {
+	/* SYNC_BST_CTL_RX_EN = 1; SYNC_BST_CTL_TX_EN = 1*/
+	{CS35L41_MDSYNC_EN,		0x00003200},
+	/* BST_CTL_SEL = MDSYNC */
+	{CS35L41_BSTCVRT_VCTRL2,	0x00000002},
+	/* WKFET_AMP_EN = 1; SYNC_EN = 1; CLASSH_EN= 1 */
+	{CS35L41_PWR_CTRL3,		0x01000110},
+};
+
+static const struct reg_sequence cs35l41_passive_seq[] = {
+	/* GPIO2 as open drain interrupt, GPIO1 as hi-z input */
+	{CS35L41_GPIO_PAD_CONTROL,	0x02000000},
+	/* SYNC_BST_CTL_RX_EN = 0; SYNC_BST_CTL_TX_EN = 1 */
+	{CS35L41_MDSYNC_EN,		0x00001200},
+	/* BST_EN = 0 */
+	{CS35L41_PWR_CTRL2,		0x00003300},
+	/* BST_CTL_SEL = CLASSH */
+	{CS35L41_BSTCVRT_VCTRL2,	0x00000001},
+	/* WKFET_AMP_EN = 1; SYNC_EN = 0; CLASSH_EN= 1 */
+	{CS35L41_PWR_CTRL3,		0x01000010},
 };
 
-static const struct snd_soc_dapm_widget cs35l41_ext_bst_widget[] = {
-	SND_SOC_DAPM_SUPPLY("VSPK", CS35L41_GPIO1_CTRL1, CS35L41_GPIO_LVL_SHIFT, 0, NULL, 0),
-};
-
-static int cs35l41_component_probe(struct snd_soc_component *component)
+static int cs35l41_set_pdata(struct cs35l41_private *cs35l41)
 {
-	struct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(component);
-	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+	struct cs35l41_classh_cfg *classh = &cs35l41->pdata.classh_config;
 	int ret;
 
-	if (cs35l41->hw_cfg.bst_type == CS35L41_EXT_BOOST) {
-		ret = snd_soc_dapm_new_controls(dapm, cs35l41_ext_bst_widget,
-						ARRAY_SIZE(cs35l41_ext_bst_widget));
-		if (ret)
+	/* Set Platform Data */
+	/* Required */
+	if (cs35l41->pdata.bst_ipk &&
+			cs35l41->pdata.bst_ind && cs35l41->pdata.bst_cap) {
+		ret = cs35l41_boost_config(cs35l41, cs35l41->pdata.bst_ind,
+					cs35l41->pdata.bst_cap,
+					cs35l41->pdata.bst_ipk);
+		if (ret) {
+			dev_err(cs35l41->dev, "Error in Boost DT config\n");
 			return ret;
+		}
+	} else {
+		dev_err(cs35l41->dev, "Incomplete Boost component DT config\n");
+		return -EINVAL;
+	}
 
-		ret = snd_soc_dapm_add_routes(dapm, cs35l41_ext_bst_routes,
-					      ARRAY_SIZE(cs35l41_ext_bst_routes));
-		if (ret)
-			return ret;
+	/* Optional */
+	if (cs35l41->pdata.sclk_frc)
+		regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
+				CS35L41_SCLK_FRC_MASK,
+				cs35l41->pdata.sclk_frc <<
+				CS35L41_SCLK_FRC_SHIFT);
+
+	if (cs35l41->pdata.lrclk_frc)
+		regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
+				CS35L41_LRCLK_FRC_MASK,
+				cs35l41->pdata.lrclk_frc <<
+				CS35L41_LRCLK_FRC_SHIFT);
+
+	if (cs35l41->pdata.amp_gain_zc)
+		regmap_update_bits(cs35l41->regmap, CS35L41_AMP_GAIN_CTRL,
+				CS35L41_AMP_GAIN_ZC_MASK,
+				cs35l41->pdata.amp_gain_zc <<
+				CS35L41_AMP_GAIN_ZC_SHIFT);
+
+	if (cs35l41->pdata.bst_vctrl)
+		regmap_update_bits(cs35l41->regmap, CS35L41_BSTCVRT_VCTRL1,
+				CS35L41_BST_CTL_MASK, cs35l41->pdata.bst_vctrl);
+
+	if (cs35l41->pdata.temp_warn_thld)
+		regmap_update_bits(cs35l41->regmap, CS35L41_DTEMP_WARN_THLD,
+				CS35L41_TEMP_THLD_MASK,
+				cs35l41->pdata.temp_warn_thld);
+
+	if (cs35l41->pdata.dout_hiz <= CS35L41_ASP_DOUT_HIZ_MASK &&
+	    cs35l41->pdata.dout_hiz >= 0)
+		regmap_update_bits(cs35l41->regmap, CS35L41_SP_HIZ_CTRL,
+				CS35L41_ASP_DOUT_HIZ_MASK,
+				cs35l41->pdata.dout_hiz);
+
+	if (cs35l41->pdata.invert_pcm)
+		regmap_update_bits(cs35l41->regmap, CS35L41_AMP_DIG_VOL_CTRL,
+				CS35L41_AMP_INV_PCM_MASK,
+				cs35l41->pdata.invert_pcm <<
+				CS35L41_AMP_INV_PCM_SHIFT);
+
+	if (cs35l41->pdata.dsp_ng_enable) {
+		regmap_update_bits(cs35l41->regmap,
+				CS35L41_MIXER_NGATE_CH1_CFG,
+				CS35L41_DSP_NG_ENABLE_MASK,
+				CS35L41_DSP_NG_ENABLE_MASK);
+		regmap_update_bits(cs35l41->regmap,
+				CS35L41_MIXER_NGATE_CH2_CFG,
+				CS35L41_DSP_NG_ENABLE_MASK,
+				CS35L41_DSP_NG_ENABLE_MASK);
+
+		if (cs35l41->pdata.dsp_ng_pcm_thld) {
+			regmap_update_bits(cs35l41->regmap,
+				CS35L41_MIXER_NGATE_CH1_CFG,
+				CS35L41_DSP_NG_THLD_MASK,
+				cs35l41->pdata.dsp_ng_pcm_thld);
+			regmap_update_bits(cs35l41->regmap,
+				CS35L41_MIXER_NGATE_CH2_CFG,
+				CS35L41_DSP_NG_THLD_MASK,
+				cs35l41->pdata.dsp_ng_pcm_thld);
+		}
+
+		if (cs35l41->pdata.dsp_ng_delay) {
+			regmap_update_bits(cs35l41->regmap,
+				CS35L41_MIXER_NGATE_CH1_CFG,
+				CS35L41_DSP_NG_DELAY_MASK,
+				cs35l41->pdata.dsp_ng_delay <<
+				CS35L41_DSP_NG_DELAY_SHIFT);
+			regmap_update_bits(cs35l41->regmap,
+				CS35L41_MIXER_NGATE_CH2_CFG,
+				CS35L41_DSP_NG_DELAY_MASK,
+				cs35l41->pdata.dsp_ng_delay <<
+				CS35L41_DSP_NG_DELAY_SHIFT);
+		}
+	}
+
+	if (cs35l41->pdata.hw_ng_sel)
+		regmap_update_bits(cs35l41->regmap,
+				CS35L41_NG_CFG,
+				CS35L41_HW_NG_SEL_MASK,
+				cs35l41->pdata.hw_ng_sel <<
+				CS35L41_HW_NG_SEL_SHIFT);
+
+	if (cs35l41->pdata.hw_ng_thld)
+		regmap_update_bits(cs35l41->regmap,
+				CS35L41_NG_CFG,
+				CS35L41_HW_NG_THLD_MASK,
+				cs35l41->pdata.hw_ng_thld <<
+				CS35L41_HW_NG_THLD_SHIFT);
+
+	if (cs35l41->pdata.hw_ng_delay)
+		regmap_update_bits(cs35l41->regmap,
+				CS35L41_NG_CFG,
+				CS35L41_HW_NG_DLY_MASK,
+				cs35l41->pdata.hw_ng_delay <<
+				CS35L41_HW_NG_DLY_SHIFT);
+
+	if (classh->classh_algo_enable) {
+		if (classh->classh_bst_override)
+			regmap_update_bits(cs35l41->regmap,
+					CS35L41_BSTCVRT_VCTRL2,
+					CS35L41_BST_CTL_SEL_MASK,
+					CS35L41_BST_CTL_SEL_REG);
+		if (classh->classh_bst_max_limit)
+			regmap_update_bits(cs35l41->regmap,
+					CS35L41_BSTCVRT_VCTRL2,
+					CS35L41_BST_LIM_MASK,
+					classh->classh_bst_max_limit <<
+					CS35L41_BST_LIM_SHIFT);
+		if (classh->classh_mem_depth)
+			regmap_update_bits(cs35l41->regmap,
+					CS35L41_CLASSH_CFG,
+					CS35L41_CH_MEM_DEPTH_MASK,
+					classh->classh_mem_depth <<
+					CS35L41_CH_MEM_DEPTH_SHIFT);
+		if (classh->classh_headroom)
+			regmap_update_bits(cs35l41->regmap,
+					CS35L41_CLASSH_CFG,
+					CS35L41_CH_HDRM_CTL_MASK,
+					classh->classh_headroom <<
+					CS35L41_CH_HDRM_CTL_SHIFT);
+		if (classh->classh_release_rate)
+			regmap_update_bits(cs35l41->regmap,
+					CS35L41_CLASSH_CFG,
+					CS35L41_CH_REL_RATE_MASK,
+					classh->classh_release_rate <<
+					CS35L41_CH_REL_RATE_SHIFT);
+		if (classh->classh_wk_fet_delay)
+			regmap_update_bits(cs35l41->regmap,
+					CS35L41_WKFET_CFG,
+					CS35L41_CH_WKFET_DLY_MASK,
+					classh->classh_wk_fet_delay <<
+					CS35L41_CH_WKFET_DLY_SHIFT);
+		if (classh->classh_wk_fet_thld)
+			regmap_update_bits(cs35l41->regmap,
+					CS35L41_WKFET_CFG,
+					CS35L41_CH_WKFET_THLD_MASK,
+					classh->classh_wk_fet_thld <<
+					CS35L41_CH_WKFET_THLD_SHIFT);
+	}
+
+	if (cs35l41->pdata.shared_boost == SHARED_BOOST_ACTIVE) {
+		ret = regmap_multi_reg_write(cs35l41->regmap,
+					     cs35l41_active_seq,
+					     ARRAY_SIZE(cs35l41_active_seq));
+		if (ret < 0)
+			dev_err(cs35l41->dev,
+				"Active shared boost seq failed %d\n", ret);
+	}
+
+	if (cs35l41->pdata.shared_boost == SHARED_BOOST_PASSIVE) {
+		ret = regmap_multi_reg_write(cs35l41->regmap,
+					     cs35l41_passive_seq,
+					     ARRAY_SIZE(cs35l41_passive_seq));
+		if (ret < 0)
+			dev_err(cs35l41->dev,
+				"Passive shared boost seq failed %d\n", ret);
+	}
+
+	return 0;
+}
+
+static int cs35l41_component_probe(struct snd_soc_component *component)
+{
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
+	struct snd_kcontrol_new *kcontrol;
+	int ret = 0;
+
+	component->regmap = cs35l41->regmap;
+
+	cs35l41_set_pdata(cs35l41);
+
+	wm_adsp2_component_probe(&cs35l41->dsp, component);
+
+	/* Add run-time mixer control for fast use case switch */
+	if (cs35l41->fast_switch_enum.items) {
+		kcontrol = kzalloc(sizeof(*kcontrol), GFP_KERNEL);
+		if (!kcontrol) {
+			ret = -ENOMEM;
+			goto exit;
+		}
+
+		kcontrol->name = "Fast Use Case Delta File";
+		kcontrol->iface = SNDRV_CTL_ELEM_IFACE_MIXER;
+		kcontrol->info = snd_soc_info_enum_double;
+		kcontrol->get = cs35l41_fast_switch_file_get;
+		kcontrol->put = cs35l41_fast_switch_file_put;
+		kcontrol->private_value =
+				  (unsigned long)&cs35l41->fast_switch_enum;
+		ret = snd_soc_add_component_controls(component, kcontrol, 1);
+		if (ret < 0)
+			dev_err(cs35l41->dev,
+			       "snd_soc_add_codec_controls failed (%d)\n", ret);
+		kfree(kcontrol);
 	}
 
-	return wm_adsp2_component_probe(&cs35l41->dsp, component);
+	/* Move to the extended standby state */
+	regmap_multi_reg_write_bypassed(cs35l41->regmap,
+				cs35l41_pdn_patch,
+				ARRAY_SIZE(cs35l41_pdn_patch));
+exit:
+	return ret;
+}
+
+static int cs35l41_irq_gpio_config(struct cs35l41_private *cs35l41)
+{
+	struct cs35l41_irq_cfg *irq_gpio_cfg1 = &cs35l41->pdata.irq_config1;
+	struct cs35l41_irq_cfg *irq_gpio_cfg2 = &cs35l41->pdata.irq_config2;
+	int irq_pol = IRQF_TRIGGER_NONE;
+
+	if (irq_gpio_cfg1->irq_pol_inv)
+		regmap_update_bits(cs35l41->regmap,
+					CS35L41_GPIO1_CTRL1,
+					CS35L41_GPIO_POL_MASK,
+					CS35L41_GPIO_POL_MASK);
+	if (irq_gpio_cfg1->irq_out_en)
+		regmap_update_bits(cs35l41->regmap,
+					CS35L41_GPIO1_CTRL1,
+					CS35L41_GPIO_DIR_MASK,
+					0);
+	if (irq_gpio_cfg1->irq_src_sel)
+		regmap_update_bits(cs35l41->regmap,
+					CS35L41_GPIO_PAD_CONTROL,
+					CS35L41_GPIO1_CTRL_MASK,
+					irq_gpio_cfg1->irq_src_sel <<
+					CS35L41_GPIO1_CTRL_SHIFT);
+
+	if (irq_gpio_cfg2->irq_pol_inv)
+		regmap_update_bits(cs35l41->regmap,
+					CS35L41_GPIO2_CTRL1,
+					CS35L41_GPIO_POL_MASK,
+					CS35L41_GPIO_POL_MASK);
+	if (irq_gpio_cfg2->irq_out_en)
+		regmap_update_bits(cs35l41->regmap,
+					CS35L41_GPIO2_CTRL1,
+					CS35L41_GPIO_DIR_MASK,
+					0);
+	if (irq_gpio_cfg2->irq_src_sel)
+		regmap_update_bits(cs35l41->regmap,
+					CS35L41_GPIO_PAD_CONTROL,
+					CS35L41_GPIO2_CTRL_MASK,
+					irq_gpio_cfg2->irq_src_sel <<
+					CS35L41_GPIO2_CTRL_SHIFT);
+
+	if (irq_gpio_cfg2->irq_src_sel ==
+			(CS35L41_GPIO_CTRL_ACTV_LO | CS35L41_VALID_PDATA))
+		irq_pol = IRQF_TRIGGER_LOW;
+	else if (irq_gpio_cfg2->irq_src_sel ==
+			(CS35L41_GPIO_CTRL_ACTV_HI | CS35L41_VALID_PDATA))
+		irq_pol = IRQF_TRIGGER_HIGH;
+
+	return irq_pol;
 }
 
 static void cs35l41_component_remove(struct snd_soc_component *component)
 {
-	struct cs35l41_private *cs35l41 = snd_soc_component_get_drvdata(component);
+	struct cs35l41_private *cs35l41 =
+		snd_soc_component_get_drvdata(component);
 
 	wm_adsp2_component_remove(&cs35l41->dsp, component);
 }
@@ -987,7 +2955,6 @@
 	.set_fmt = cs35l41_set_dai_fmt,
 	.hw_params = cs35l41_pcm_hw_params,
 	.set_sysclk = cs35l41_dai_set_sysclk,
-	.set_channel_map = cs35l41_set_channel_map,
 };
 
 static struct snd_soc_dai_driver cs35l41_dai[] = {
@@ -1004,7 +2971,7 @@
 		.capture = {
 			.stream_name = "AMP Capture",
 			.channels_min = 1,
-			.channels_max = 4,
+			.channels_max = 8,
 			.rates = SNDRV_PCM_RATE_KNOT,
 			.formats = CS35L41_TX_FORMATS,
 		},
@@ -1014,7 +2981,6 @@
 };
 
 static const struct snd_soc_component_driver soc_component_dev_cs35l41 = {
-	.name = "cs35l41-codec",
 	.probe = cs35l41_component_probe,
 	.remove = cs35l41_component_remove,
 
@@ -1026,112 +2992,325 @@
 	.controls = cs35l41_aud_controls,
 	.num_controls = ARRAY_SIZE(cs35l41_aud_controls),
 	.set_sysclk = cs35l41_component_set_sysclk,
-
-	.endianness = 1,
 };
 
-static int cs35l41_handle_pdata(struct device *dev, struct cs35l41_hw_cfg *hw_cfg)
+
+
+static int cs35l41_handle_pdata(struct device *dev,
+				  struct cs35l41_platform_data *pdata,
+				  struct cs35l41_private *cs35l41)
 {
-	struct cs35l41_gpio_cfg *gpio1 = &hw_cfg->gpio1;
-	struct cs35l41_gpio_cfg *gpio2 = &hw_cfg->gpio2;
+	struct device_node *np = dev->of_node;
 	unsigned int val;
 	int ret;
+	size_t	num_fast_switch;
+	struct cs35l41_classh_cfg *classh_config = &pdata->classh_config;
+	struct cs35l41_irq_cfg *irq_gpio1_config = &pdata->irq_config1;
+	struct cs35l41_irq_cfg *irq_gpio2_config = &pdata->irq_config2;
+	unsigned int i;
 
-	ret = device_property_read_u32(dev, "cirrus,boost-type", &val);
-	if (ret >= 0)
-		hw_cfg->bst_type = val;
+	if (np) {
+		cs35l41->dt_name = devm_kstrdup_const(cs35l41->dev, np->name,
+					      GFP_KERNEL);
+
+		ret = of_property_count_strings(np, "cirrus,fast-switch");
+		if (ret < 0) {
+			/*
+			 * Device tree does not provide file name.
+			 * Use default value
+			 */
+			num_fast_switch = ARRAY_SIZE(cs35l41_fast_switch_text);
+			cs35l41->fast_switch_enum.items	=
+				ARRAY_SIZE(cs35l41_fast_switch_text);
+			cs35l41->fast_switch_enum.texts	= cs35l41_fast_switch_text;
+			cs35l41->fast_switch_names = cs35l41_fast_switch_text;
+		} else {
+			/* Device tree provides file name */
+			num_fast_switch = (size_t)ret;
+			dev_info(dev, "num_fast_switch:%zu\n", num_fast_switch);
+			cs35l41->fast_switch_names =
+				devm_kmalloc(dev, num_fast_switch * sizeof(char *),
+					     GFP_KERNEL);
+			if (!cs35l41->fast_switch_names)
+				return -ENOMEM;
+			of_property_read_string_array(np, "cirrus,fast-switch",
+						      cs35l41->fast_switch_names,
+						      num_fast_switch);
+			for (i = 0; i < num_fast_switch; i++) {
+				dev_info(dev, "%d:%s\n", i,
+					 cs35l41->fast_switch_names[i]);
+			}
+			cs35l41->fast_switch_enum.items	= num_fast_switch;
+			cs35l41->fast_switch_enum.texts	= cs35l41->fast_switch_names;
+		}
+		cs35l41->fast_switch_enum.reg = SND_SOC_NOPM;
+		cs35l41->fast_switch_enum.shift_l = 0;
+		cs35l41->fast_switch_enum.shift_r = 0;
+		cs35l41->fast_switch_enum.mask = roundup_pow_of_two(num_fast_switch) - 1;
+	} else {
+		cs35l41->dt_name = "cs35l41";
+		cs35l41->fast_switch_enum.items	= 0;
+	}
+
+	pdata->sclk_frc = device_property_read_bool(dev,
+					"cirrus,sclk-force-output");
+	pdata->lrclk_frc = device_property_read_bool(dev,
+					"cirrus,lrclk-force-output");
+	pdata->amp_gain_zc = device_property_read_bool(dev,
+					"cirrus,amp-gain-zc");
+
+	pdata->invert_pcm = device_property_read_bool(dev,
+					"cirrus,invert-pcm");
+	pdata->shared_boost = SHARED_BOOST_DISABLED;
+	if (device_property_read_bool(dev, "cirrus,shared-boost-active"))
+		pdata->shared_boost = SHARED_BOOST_ACTIVE;
+	if (device_property_read_bool(dev, "cirrus,shared-boost-passive"))
+		pdata->shared_boost = SHARED_BOOST_PASSIVE;
+
+	pdata->fwname_use_revid = device_property_read_bool(dev,
+					"cirrus,fwname-use-revid");
+
+	if (device_property_read_u32(dev, "cirrus,temp-warn_threshold", &val) >= 0)
+		pdata->temp_warn_thld = val | CS35L41_VALID_PDATA;
+
+	ret = device_property_read_u32(dev, "cirrus,boost-ctl-millivolt", &val);
+	if (ret >= 0) {
+		if (val < 2550 || val > 11000) {
+			dev_err(dev,
+				"Invalid Boost Voltage %u mV\n", val);
+			return -EINVAL;
+		}
+		pdata->bst_vctrl = ((val - 2550) / 100) + 1;
+	}
 
 	ret = device_property_read_u32(dev, "cirrus,boost-peak-milliamp", &val);
 	if (ret >= 0)
-		hw_cfg->bst_ipk = val;
-	else
-		hw_cfg->bst_ipk = -1;
+		pdata->bst_ipk = val;
 
 	ret = device_property_read_u32(dev, "cirrus,boost-ind-nanohenry", &val);
 	if (ret >= 0)
-		hw_cfg->bst_ind = val;
-	else
-		hw_cfg->bst_ind = -1;
+		pdata->bst_ind = val;
 
 	ret = device_property_read_u32(dev, "cirrus,boost-cap-microfarad", &val);
 	if (ret >= 0)
-		hw_cfg->bst_cap = val;
-	else
-		hw_cfg->bst_cap = -1;
+		pdata->bst_cap = val;
 
 	ret = device_property_read_u32(dev, "cirrus,asp-sdout-hiz", &val);
 	if (ret >= 0)
-		hw_cfg->dout_hiz = val;
+		pdata->dout_hiz = val;
 	else
-		hw_cfg->dout_hiz = -1;
+		pdata->dout_hiz = -1;
+
+	pdata->dsp_ng_enable = device_property_read_bool(dev,
+					"cirrus,dsp-noise-gate-enable");
+	if (device_property_read_u32(dev,
+				"cirrus,dsp-noise-gate-threshold", &val) >= 0)
+		pdata->dsp_ng_pcm_thld = val | CS35L41_VALID_PDATA;
+	if (device_property_read_u32(dev, "cirrus,dsp-noise-gate-delay", &val) >= 0)
+		pdata->dsp_ng_delay = val | CS35L41_VALID_PDATA;
+
+	if (device_property_read_u32(dev, "cirrus,hw-noise-gate-select", &val) >= 0)
+		pdata->hw_ng_sel = val | CS35L41_VALID_PDATA;
+	if (device_property_read_u32(dev,
+				"cirrus,hw-noise-gate-threshold", &val) >= 0)
+		pdata->hw_ng_thld = val | CS35L41_VALID_PDATA;
+	if (device_property_read_u32(dev, "cirrus,hw-noise-gate-delay", &val) >= 0)
+		pdata->hw_ng_delay = val | CS35L41_VALID_PDATA;
+
+	classh_config->classh_algo_enable =
+				device_property_read_bool(dev, "cirrus,classh-internal-algo");
+
+	if (classh_config->classh_algo_enable) {
+		classh_config->classh_bst_override =
+			device_property_read_bool(dev,
+				"cirrus,classh-bst-override");
+
+		ret = device_property_read_u32(dev,
+					   "cirrus,classh-bst-max-limit",
+					   &val);
+		if (ret >= 0) {
+			val |= CS35L41_VALID_PDATA;
+			classh_config->classh_bst_max_limit = val;
+		}
+
+		ret = device_property_read_u32(dev, "cirrus,classh-mem-depth",
+					   &val);
+		if (ret >= 0) {
+			val |= CS35L41_VALID_PDATA;
+			classh_config->classh_mem_depth = val;
+		}
+
+		ret = device_property_read_u32(dev,
+					"cirrus,classh-release-rate", &val);
+		if (ret >= 0)
+			classh_config->classh_release_rate = val;
+
+		ret = device_property_read_u32(dev, "cirrus,classh-headroom",
+					   &val);
+		if (ret >= 0) {
+			val |= CS35L41_VALID_PDATA;
+			classh_config->classh_headroom = val;
+		}
+
+		ret = device_property_read_u32(dev,
+					"cirrus,classh-wk-fet-delay", &val);
+		if (ret >= 0) {
+			val |= CS35L41_VALID_PDATA;
+			classh_config->classh_wk_fet_delay = val;
+		}
+
+		ret = device_property_read_u32(dev,
+					"cirrus,classh-wk-fet-thld", &val);
+		if (ret >= 0)
+			classh_config->classh_wk_fet_thld = val;
+	}
 
 	/* GPIO1 Pin Config */
-	gpio1->pol_inv = device_property_read_bool(dev, "cirrus,gpio1-polarity-invert");
-	gpio1->out_en = device_property_read_bool(dev, "cirrus,gpio1-output-enable");
-	ret = device_property_read_u32(dev, "cirrus,gpio1-src-select", &val);
+	irq_gpio1_config->irq_pol_inv = device_property_read_bool(dev,
+					"cirrus,gpio1-polarity-invert");
+	irq_gpio1_config->irq_out_en = device_property_read_bool(dev,
+					"cirrus,gpio1-output-enable");
+	ret = device_property_read_u32(dev, "cirrus,gpio1-src-select",
+				&val);
 	if (ret >= 0) {
-		gpio1->func = val;
-		gpio1->valid = true;
+		val |= CS35L41_VALID_PDATA;
+		irq_gpio1_config->irq_src_sel = val;
 	}
 
 	/* GPIO2 Pin Config */
-	gpio2->pol_inv = device_property_read_bool(dev, "cirrus,gpio2-polarity-invert");
-	gpio2->out_en = device_property_read_bool(dev, "cirrus,gpio2-output-enable");
-	ret = device_property_read_u32(dev, "cirrus,gpio2-src-select", &val);
+	irq_gpio2_config->irq_pol_inv = device_property_read_bool(dev,
+					"cirrus,gpio2-polarity-invert");
+	irq_gpio2_config->irq_out_en = device_property_read_bool(dev,
+					"cirrus,gpio2-output-enable");
+	ret = device_property_read_u32(dev, "cirrus,gpio2-src-select",
+				&val);
 	if (ret >= 0) {
-		gpio2->func = val;
-		gpio2->valid = true;
+		val |= CS35L41_VALID_PDATA;
+		irq_gpio2_config->irq_src_sel = val;
 	}
 
-	hw_cfg->valid = true;
+	pdata->hibernate_enable = device_property_read_bool(dev,
+					"cirrus,hibernate-enable");
 
 	return 0;
 }
 
+static const struct reg_sequence cs35l41_reva0_errata_patch[] = {
+	{0x00000040,			0x00005555},
+	{0x00000040,			0x0000AAAA},
+	{0x00003854,			0x05180240},
+	{CS35L41_VIMON_SPKMON_RESYNC,	0x00000000},
+	{0x00004310,			0x00000000},
+	{CS35L41_VPVBST_FS_SEL,		0x00000000},
+	{CS35L41_OTP_TRIM_30,		0x9091A1C8},
+	{0x00003014,			0x0200EE0E},
+	{CS35L41_BSTCVRT_DCM_CTRL,	0x00000051},
+	{0x00000054,			0x00000004},
+	{CS35L41_IRQ1_DB3,		0x00000000},
+	{CS35L41_IRQ2_DB3,		0x00000000},
+	{CS35L41_DSP1_YM_ACCEL_PL0_PRI,	0x00000000},
+	{CS35L41_DSP1_XM_ACCEL_PL0_PRI,	0x00000000},
+	{0x00000040,			0x0000CCCC},
+	{0x00000040,			0x00003333},
+};
+
+static const struct reg_sequence cs35l41_revb0_errata_patch[] = {
+	{0x00000040,			0x00005555},
+	{0x00000040,			0x0000AAAA},
+	{CS35L41_VIMON_SPKMON_RESYNC,	0x00000000},
+	{0x00004310,			0x00000000},
+	{CS35L41_VPVBST_FS_SEL,		0x00000000},
+	{CS35L41_BSTCVRT_DCM_CTRL,	0x00000051},
+	{CS35L41_DSP1_YM_ACCEL_PL0_PRI,	0x00000000},
+	{CS35L41_DSP1_XM_ACCEL_PL0_PRI,	0x00000000},
+	{0x00000040,			0x0000CCCC},
+	{0x00000040,			0x00003333},
+};
+
+static const struct reg_sequence cs35l41_revb2_errata_patch[] = {
+	{0x00000040,			0x00005555},
+	{0x00000040,			0x0000AAAA},
+	{CS35L41_VIMON_SPKMON_RESYNC,	0x00000000},
+	{0x00004310,			0x00000000},
+	{CS35L41_VPVBST_FS_SEL,		0x00000000},
+	{CS35L41_BSTCVRT_DCM_CTRL,	0x00000051},
+	{CS35L41_DSP1_YM_ACCEL_PL0_PRI,	0x00000000},
+	{CS35L41_DSP1_XM_ACCEL_PL0_PRI,	0x00000000},
+	{0x00000040,			0x0000CCCC},
+	{0x00000040,			0x00003333},
+};
+
+static const struct reg_sequence cs35l41_fs_errata_patch[] = {
+	{0x02B80080,			0x00000001},
+	{0x02B80088,			0x00000001},
+	{0x02B80090,			0x00000001},
+	{0x02B80098,			0x00000001},
+	{0x02B800A0,			0x00000001},
+	{0x02B800A8,			0x00000001},
+	{0x02B800B0,			0x00000001},
+	{0x02B800B8,			0x00000001},
+	{0x02B80280,			0x00000001},
+	{0x02B80288,			0x00000001},
+	{0x02B80290,			0x00000001},
+	{0x02B80298,			0x00000001},
+	{0x02B802A0,			0x00000001},
+	{0x02B802A8,			0x00000001},
+	{0x02B802B0,			0x00000001},
+	{0x02B802B8,			0x00000001},
+};
+
 static int cs35l41_dsp_init(struct cs35l41_private *cs35l41)
 {
 	struct wm_adsp *dsp;
 	int ret;
 
 	dsp = &cs35l41->dsp;
-	dsp->part = "cs35l41";
+	dsp->num = 1;
+	dsp->type = WMFW_HALO;
+	dsp->rev = 0;
 	dsp->fw = 9; /* 9 is WM_ADSP_FW_SPK_PROT in wm_adsp.c */
-	dsp->toggle_preload = true;
-
-	cs35l41_configure_cs_dsp(cs35l41->dev, cs35l41->regmap, &dsp->cs_dsp);
-
-	ret = cs35l41_write_fs_errata(cs35l41->dev, cs35l41->regmap);
-	if (ret < 0)
-		return ret;
+	dsp->dev = cs35l41->dev;
+	dsp->regmap = cs35l41->regmap;
+	dsp->base = CS35L41_DSP1_CTRL_BASE;
+	dsp->base_sysinfo = CS35L41_DSP1_SYS_ID;
+	dsp->mem = cs35l41_dsp1_regions;
+	dsp->num_mems = ARRAY_SIZE(cs35l41_dsp1_regions);
+	dsp->lock_regions = 0xFFFFFFFF;
+
+	regmap_multi_reg_write(cs35l41->regmap,
+			cs35l41_fs_errata_patch,
+			ARRAY_SIZE(cs35l41_fs_errata_patch));
 
 	ret = wm_halo_init(dsp);
-	if (ret) {
-		dev_err(cs35l41->dev, "wm_halo_init failed: %d\n", ret);
+	if (ret != 0) {
+		dev_err(cs35l41->dev, "wm_halo_init failed\n");
 		return ret;
 	}
 
+	cs35l41->halo_booted = false;
+
 	ret = regmap_write(cs35l41->regmap, CS35L41_DSP1_RX5_SRC,
-			   CS35L41_INPUT_SRC_VPMON);
+					CS35L41_INPUT_SRC_VPMON);
 	if (ret < 0) {
-		dev_err(cs35l41->dev, "Write INPUT_SRC_VPMON failed: %d\n", ret);
+		dev_err(cs35l41->dev, "Write INPUT_SRC_VPMON failed\n");
 		goto err_dsp;
 	}
 	ret = regmap_write(cs35l41->regmap, CS35L41_DSP1_RX6_SRC,
-			   CS35L41_INPUT_SRC_CLASSH);
+					CS35L41_INPUT_SRC_CLASSH);
 	if (ret < 0) {
-		dev_err(cs35l41->dev, "Write INPUT_SRC_CLASSH failed: %d\n", ret);
+		dev_err(cs35l41->dev, "Write INPUT_SRC_CLASSH failed\n");
 		goto err_dsp;
 	}
 	ret = regmap_write(cs35l41->regmap, CS35L41_DSP1_RX7_SRC,
-			   CS35L41_INPUT_SRC_TEMPMON);
+					CS35L41_INPUT_SRC_TEMPMON);
 	if (ret < 0) {
-		dev_err(cs35l41->dev, "Write INPUT_SRC_TEMPMON failed: %d\n", ret);
+		dev_err(cs35l41->dev, "Write INPUT_SRC_TEMPMON failed\n");
 		goto err_dsp;
 	}
 	ret = regmap_write(cs35l41->regmap, CS35L41_DSP1_RX8_SRC,
-			   CS35L41_INPUT_SRC_RSVD);
+					CS35L41_INPUT_SRC_RSVD);
 	if (ret < 0) {
-		dev_err(cs35l41->dev, "Write INPUT_SRC_RSVD failed: %d\n", ret);
+		dev_err(cs35l41->dev, "Write INPUT_SRC_RSVD failed\n");
 		goto err_dsp;
 	}
 
@@ -1139,67 +3318,394 @@
 
 err_dsp:
 	wm_adsp2_remove(dsp);
+	return ret;
+}
 
+
+static int cs35l41_enter_hibernate(struct cs35l41_private *cs35l41)
+{
+	int i;
+
+	dev_dbg(cs35l41->dev, "%s: hibernate state %d\n",
+		__func__, cs35l41->amp_hibernate);
+
+	if (cs35l41->amp_hibernate == CS35L41_HIBERNATE_STANDBY)
+		return 0;
+
+	/* read all ctl regs */
+	for (i = 0; i < CS35L41_CTRL_CACHE_SIZE; i++)
+		regmap_read(cs35l41->regmap, cs35l41_ctl_cache_regs[i],
+			    &cs35l41->ctl_cache[i]);
+
+	/* Disable interrupts */
+	regmap_write(cs35l41->regmap, CS35L41_IRQ1_MASK1, 0xFFFFFFFF);
+	if (cs35l41->pdata.shared_boost == SHARED_BOOST_PASSIVE)
+		regmap_write(cs35l41->regmap, CS35L41_IRQ1_MASK3,
+			     CS35L41_INT3_MASK_DEFAULT);
+	disable_irq(cs35l41->irq);
+
+	/* Reset DSP sticky bit */
+	regmap_write(cs35l41->regmap, CS35L41_IRQ2_STATUS2,
+			1 << CS35L41_CSPL_MBOX_CMD_DRV_SHIFT);
+
+	/* Reset AP sticky bit */
+	regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS2,
+			1 << CS35L41_CSPL_MBOX_CMD_FW_SHIFT);
+
+	regmap_write(cs35l41->regmap, CS35L41_WAKESRC_CTL, 0x0088);
+	regmap_write(cs35l41->regmap, CS35L41_WAKESRC_CTL, 0x0188);
+
+	regmap_write(cs35l41->regmap, CS35L41_CSPL_MBOX_CMD_DRV,
+			CSPL_MBOX_CMD_HIBERNATE);
+
+	regcache_cache_only(cs35l41->regmap, true);
+
+	cs35l41->amp_hibernate = CS35L41_HIBERNATE_STANDBY;
+	return 0;
+}
+
+static int cs35l41_wait_for_pwrmgt_sts(struct cs35l41_private *cs35l41)
+{
+	int i, ret = 0;
+	unsigned int wrpend_sts = 0x2;
+
+	for (i = 0; (i < 10) && (wrpend_sts & 0x2); i++)
+		ret = regmap_read(cs35l41->regmap, CS35L41_PWRMGT_STS,
+				  &wrpend_sts);
 	return ret;
 }
 
-static int cs35l41_acpi_get_name(struct cs35l41_private *cs35l41)
+static int cs35l41_exit_hibernate(struct cs35l41_private *cs35l41)
 {
-	acpi_handle handle = ACPI_HANDLE(cs35l41->dev);
-	const char *sub;
+	int timeout = 20, ret;
+	unsigned int status;
+	int retries = 5, i;
+	u32 *p_trim_data;
+
+	dev_dbg(cs35l41->dev, "%s: hibernate state %d\n",
+		__func__, cs35l41->amp_hibernate);
 
-	/* If there is no ACPI_HANDLE, there is no ACPI for this system, return 0 */
-	if (!handle)
+	if (cs35l41->amp_hibernate != CS35L41_HIBERNATE_STANDBY)
 		return 0;
 
-	sub = acpi_get_subsystem_id(handle);
-	if (IS_ERR(sub)) {
-		/* If bad ACPI, return 0 and fallback to legacy firmware path, otherwise fail */
-		if (PTR_ERR(sub) == -ENODATA)
-			return 0;
-		else
-			return PTR_ERR(sub);
+	/* update any regs that changed while in cache-only mode */
+	for (i = 0; i < CS35L41_CTRL_CACHE_SIZE; i++)
+		regmap_read(cs35l41->regmap, cs35l41_ctl_cache_regs[i],
+			    &cs35l41->ctl_cache[i]);
+
+	regcache_cache_only(cs35l41->regmap, false);
+
+	do {
+		do {
+			ret = regmap_write(cs35l41->regmap,
+					   CS35L41_CSPL_MBOX_CMD_DRV,
+					   CSPL_MBOX_CMD_OUT_OF_HIBERNATE);
+			if (ret < 0)
+				dev_dbg(cs35l41->dev,
+					"%s: wakeup write fail\n", __func__);
+
+			usleep_range(100, 200);
+
+			ret = regmap_read(cs35l41->regmap,
+					  CS35L41_CSPL_MBOX_STS, &status);
+			if (ret < 0)
+				dev_err(cs35l41->dev,
+					"%s: mbox status read fail\n",
+					__func__);
+
+		} while (status != CSPL_MBOX_STS_PAUSED && --timeout > 0);
+
+		if (timeout != 0) {
+			dev_dbg(cs35l41->dev, "wake success at cycle %d\n",
+				timeout);
+			break;
+		}
+
+		dev_err(cs35l41->dev, "hibernate wake failed\n");
+
+		cs35l41_wait_for_pwrmgt_sts(cs35l41);
+		regmap_write(cs35l41->regmap, CS35L41_WAKESRC_CTL, 0x0088);
+
+		cs35l41_wait_for_pwrmgt_sts(cs35l41);
+		regmap_write(cs35l41->regmap, CS35L41_WAKESRC_CTL, 0x0188);
+
+		cs35l41_wait_for_pwrmgt_sts(cs35l41);
+		regmap_write(cs35l41->regmap, CS35L41_PWRMGT_CTL, 0x3);
+
+		timeout = 10;
+
+	} while (--retries > 0);
+
+	/* Reset DSP sticky bit */
+	regmap_write(cs35l41->regmap, CS35L41_IRQ2_STATUS2,
+			1 << CS35L41_CSPL_MBOX_CMD_DRV_SHIFT);
+
+	/* Reset AP sticky bit */
+	regmap_write(cs35l41->regmap, CS35L41_IRQ1_STATUS2,
+			1 << CS35L41_CSPL_MBOX_CMD_FW_SHIFT);
+
+	cs35l41->amp_hibernate = CS35L41_HIBERNATE_AWAKE;
+
+	/* invalidate all cached values which have now been reset */
+	regcache_drop_region(cs35l41->regmap, CS35L41_DEVID,
+					CS35L41_MIXER_NGATE_CH2_CFG);
+
+	/* sync all control regs to cache value */
+	for (i = 0; i < CS35L41_CTRL_CACHE_SIZE; i++)
+		regmap_write(cs35l41->regmap,
+				cs35l41_ctl_cache_regs[i],
+				cs35l41->ctl_cache[i]);
+
+	regmap_write(cs35l41->regmap, CS35L41_TEST_KEY_CTL, 0x00000055);
+	regmap_write(cs35l41->regmap, CS35L41_TEST_KEY_CTL, 0x000000AA);
+
+	/* trim with cache values */
+	p_trim_data = cs35l41->trim_cache;
+	for (i = 0; i < CS35L41_TRIM_CACHE_REGIONS; i++) {
+		regmap_raw_write(cs35l41->regmap,
+				cs35l41_trim_cache_regs[i].reg,
+				p_trim_data, cs35l41_trim_cache_regs[i].size *
+				sizeof(u32));
+		p_trim_data += cs35l41_trim_cache_regs[i].size;
+	}
+
+	regmap_write(cs35l41->regmap, CS35L41_TEST_KEY_CTL, 0x000000CC);
+	regmap_write(cs35l41->regmap, CS35L41_TEST_KEY_CTL, 0x00000033);
+
+	retries = 5;
+
+	do {
+		dev_dbg(cs35l41->dev, "cs35l41_restore attempt %d\n",
+		 6 - retries);
+		ret = cs35l41_restore(cs35l41);
+		usleep_range(4000, 5000);
+	} while (ret < 0 && --retries > 0);
+
+	if (retries <= 0)
+		dev_err(cs35l41->dev, "Failed to exit from hibernate\n");
+	else
+		dev_dbg(cs35l41->dev, "cs35l41 restored in %d attempts\n",
+			6 - retries);
+
+	enable_irq(cs35l41->irq);
+
+	return ret;
+}
+
+/* Restore amp state after hibernate */
+static int cs35l41_restore(struct cs35l41_private *cs35l41)
+{
+	int ret;
+	u32 regid, reg_revid, mtl_revid, chipid_match;
+
+	ret = regmap_read(cs35l41->regmap, CS35L41_DEVID, &regid);
+	if (ret < 0) {
+		dev_err(cs35l41->dev, "%s: Get Device ID fail\n", __func__);
+		return -ENODEV;
+	}
+
+	ret = regmap_read(cs35l41->regmap, CS35L41_REVID, &reg_revid);
+	if (ret < 0) {
+		dev_err(cs35l41->dev, "Get Revision ID failed\n");
+		return -ENODEV;
 	}
 
-	cs35l41->dsp.system_name = sub;
-	dev_dbg(cs35l41->dev, "Subsystem ID: %s\n", cs35l41->dsp.system_name);
+	mtl_revid = reg_revid & CS35L41_MTLREVID_MASK;
+	chipid_match = (mtl_revid % 2) ? CS35L41R_CHIP_ID : CS35L41_CHIP_ID;
+	if (regid != chipid_match) {
+		dev_err(cs35l41->dev, "CS35L41 Device ID (%X). Expected ID %X\n",
+			regid, chipid_match);
+		return -ENODEV;
+	}
+
+	cs35l41_irq_gpio_config(cs35l41);
+
+	regmap_write(cs35l41->regmap, CS35L41_IRQ1_MASK1,
+		CS35L41_INT1_MASK_DEFAULT);
+	if (cs35l41->pdata.shared_boost == SHARED_BOOST_PASSIVE)
+		regmap_write(cs35l41->regmap, CS35L41_IRQ1_MASK3,
+			     CS35L41_INT3_UNMASK_PLL_LOCK);
+
+	regmap_write(cs35l41->regmap,
+		     CS35L41_DSP1_RX5_SRC, CS35L41_INPUT_SRC_VPMON);
+	regmap_write(cs35l41->regmap,
+		     CS35L41_DSP1_RX6_SRC, CS35L41_INPUT_SRC_CLASSH);
+	regmap_write(cs35l41->regmap,
+		     CS35L41_DSP1_RX7_SRC, CS35L41_INPUT_SRC_TEMPMON);
+	regmap_write(cs35l41->regmap,
+		     CS35L41_DSP1_RX8_SRC, CS35L41_INPUT_SRC_RSVD);
+
+	switch (reg_revid) {
+	case CS35L41_REVID_A0:
+		ret = regmap_multi_reg_write(cs35l41->regmap,
+				cs35l41_reva0_errata_patch,
+				ARRAY_SIZE(cs35l41_reva0_errata_patch));
+		if (ret < 0) {
+			dev_err(cs35l41->dev,
+				"Failed to apply A0 errata patch %d\n", ret);
+		}
+		break;
+	case CS35L41_REVID_B0:
+		ret = regmap_multi_reg_write(cs35l41->regmap,
+				cs35l41_revb0_errata_patch,
+				ARRAY_SIZE(cs35l41_revb0_errata_patch));
+		if (ret < 0) {
+			dev_err(cs35l41->dev,
+				"Failed to apply B0 errata patch %d\n", ret);
+		}
+		break;
+	case CS35L41_REVID_B2:
+		ret = regmap_multi_reg_write(cs35l41->regmap,
+				cs35l41_revb2_errata_patch,
+				ARRAY_SIZE(cs35l41_revb2_errata_patch));
+		if (ret < 0) {
+			dev_err(cs35l41->dev,
+				"Failed to apply B2 errata patch %d\n", ret);
+		}
+		break;
+	}
+
+	dev_dbg(cs35l41->dev, "Restored CS35L41 (%x), Revision: %02X\n",
+		regid, reg_revid);
+
+	cs35l41_set_pdata(cs35l41);
+
+	if (cs35l41->reset_cache.extclk_cfg) {
+	/* These values are already cached in cs35l41_private struct */
+		if (cs35l41->clksrc == CS35L41_PLLSRC_SCLK)
+			regmap_update_bits(cs35l41->regmap,
+					   CS35L41_SP_RATE_CTRL, 0x3F,
+					   cs35l41->extclk_cfg);
+
+		regmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,
+				CS35L41_PLL_OPENLOOP_MASK,
+				1 << CS35L41_PLL_OPENLOOP_SHIFT);
+		regmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,
+				CS35L41_REFCLK_FREQ_MASK,
+				cs35l41->extclk_cfg <<
+				CS35L41_REFCLK_FREQ_SHIFT);
+		regmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,
+				CS35L41_PLL_CLK_EN_MASK,
+				0 << CS35L41_PLL_CLK_EN_SHIFT);
+		regmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,
+				CS35L41_PLL_CLK_SEL_MASK, cs35l41->clksrc);
+		regmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,
+				CS35L41_PLL_OPENLOOP_MASK,
+				0 << CS35L41_PLL_OPENLOOP_SHIFT);
+		regmap_update_bits(cs35l41->regmap, CS35L41_PLL_CLK_CTRL,
+				CS35L41_PLL_CLK_EN_MASK,
+				1 << CS35L41_PLL_CLK_EN_SHIFT);
+	}
+
+	if (cs35l41->reset_cache.asp_width >= 0) {
+		regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
+				CS35L41_ASP_WIDTH_RX_MASK,
+				cs35l41->reset_cache.asp_width <<
+					CS35L41_ASP_WIDTH_RX_SHIFT);
+		regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
+				CS35L41_ASP_WIDTH_TX_MASK,
+				cs35l41->reset_cache.asp_width <<
+					CS35L41_ASP_WIDTH_TX_SHIFT);
+	}
+
+	if (cs35l41->reset_cache.asp_wl >= 0) {
+		regmap_update_bits(cs35l41->regmap, CS35L41_SP_RX_WL,
+				CS35L41_ASP_RX_WL_MASK,
+				cs35l41->reset_cache.asp_wl <<
+					CS35L41_ASP_RX_WL_SHIFT);
+		regmap_update_bits(cs35l41->regmap, CS35L41_SP_TX_WL,
+				CS35L41_ASP_TX_WL_MASK,
+				cs35l41->reset_cache.asp_wl <<
+					CS35L41_ASP_TX_WL_SHIFT);
+	}
+
+	if (cs35l41->reset_cache.asp_fmt >= 0)
+		regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
+			CS35L41_ASP_FMT_MASK,
+			cs35l41->reset_cache.asp_fmt << CS35L41_ASP_FMT_SHIFT);
+
+	if (cs35l41->reset_cache.lrclk_fmt >= 0)
+		regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
+				CS35L41_LRCLK_INV_MASK,
+				cs35l41->reset_cache.lrclk_fmt <<
+				CS35L41_LRCLK_INV_SHIFT);
+
+	if (cs35l41->reset_cache.sclk_fmt >= 0)
+		regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
+				CS35L41_SCLK_INV_MASK,
+				cs35l41->reset_cache.sclk_fmt <<
+				CS35L41_SCLK_INV_SHIFT);
+
+	if (cs35l41->reset_cache.clock_mode >= 0) {
+		regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
+			CS35L41_SCLK_MSTR_MASK,
+			cs35l41->reset_cache.clock_mode <<
+			CS35L41_SCLK_MSTR_SHIFT);
+		regmap_update_bits(cs35l41->regmap, CS35L41_SP_FORMAT,
+			CS35L41_LRCLK_MSTR_MASK,
+			cs35l41->reset_cache.clock_mode <<
+			CS35L41_LRCLK_MSTR_SHIFT);
+	}
+
+	if (cs35l41->reset_cache.fs_cfg >= 0)
+		regmap_update_bits(cs35l41->regmap, CS35L41_GLOBAL_CLK_CTRL,
+			CS35L41_GLOBAL_FS_MASK,
+			cs35l41->reset_cache.fs_cfg << CS35L41_GLOBAL_FS_SHIFT);
 
 	return 0;
 }
 
-int cs35l41_probe(struct cs35l41_private *cs35l41, const struct cs35l41_hw_cfg *hw_cfg)
+int cs35l41_probe(struct cs35l41_private *cs35l41,
+				struct cs35l41_platform_data *pdata)
 {
+	int ret;
 	u32 regid, reg_revid, i, mtl_revid, int_status, chipid_match;
+	int timeout = 100;
 	int irq_pol = 0;
-	int ret;
+	u32 *p_trim_data;
 
-	if (hw_cfg) {
-		cs35l41->hw_cfg = *hw_cfg;
-	} else {
-		ret = cs35l41_handle_pdata(cs35l41->dev, &cs35l41->hw_cfg);
-		if (ret != 0)
-			return ret;
-	}
+	cs35l41->fast_switch_en = false;
+	cs35l41->fast_switch_file_idx = 0;
+	cs35l41->reload_tuning = false;
+	cs35l41->speaker_open_short_status = SPK_STATUS_ALL_CLEAR;
+	cs35l41->gpi_global_en = 0;
+	cs35l41->enabled = false;
 
-	for (i = 0; i < CS35L41_NUM_SUPPLIES; i++)
+	for (i = 0; i < ARRAY_SIZE(cs35l41_supplies); i++)
 		cs35l41->supplies[i].supply = cs35l41_supplies[i];
 
-	ret = devm_regulator_bulk_get(cs35l41->dev, CS35L41_NUM_SUPPLIES,
-				      cs35l41->supplies);
+	cs35l41->num_supplies = ARRAY_SIZE(cs35l41_supplies);
+
+	ret = devm_regulator_bulk_get(cs35l41->dev, cs35l41->num_supplies,
+					cs35l41->supplies);
 	if (ret != 0) {
-		dev_err(cs35l41->dev, "Failed to request core supplies: %d\n", ret);
+		dev_err(cs35l41->dev,
+			"Failed to request core supplies: %d\n",
+			ret);
 		return ret;
 	}
 
-	ret = regulator_bulk_enable(CS35L41_NUM_SUPPLIES, cs35l41->supplies);
+	if (pdata) {
+		cs35l41->pdata = *pdata;
+	} else {
+		ret = cs35l41_handle_pdata(cs35l41->dev, &cs35l41->pdata,
+					     cs35l41);
+		if (ret != 0) {
+			ret = -ENODEV;
+			goto err;
+		}
+	}
+
+	ret = regulator_bulk_enable(cs35l41->num_supplies, cs35l41->supplies);
 	if (ret != 0) {
-		dev_err(cs35l41->dev, "Failed to enable core supplies: %d\n", ret);
+		dev_err(cs35l41->dev,
+			"Failed to enable core supplies: %d\n", ret);
 		return ret;
 	}
 
 	/* returning NULL can be an option if in stereo mode */
 	cs35l41->reset_gpio = devm_gpiod_get_optional(cs35l41->dev, "reset",
-						      GPIOD_OUT_LOW);
+							GPIOD_OUT_LOW);
 	if (IS_ERR(cs35l41->reset_gpio)) {
 		ret = PTR_ERR(cs35l41->reset_gpio);
 		cs35l41->reset_gpio = NULL;
@@ -1220,14 +3726,17 @@
 
 	usleep_range(2000, 2100);
 
-	ret = regmap_read_poll_timeout(cs35l41->regmap, CS35L41_IRQ1_STATUS4,
-				       int_status, int_status & CS35L41_OTP_BOOT_DONE,
-				       1000, 100000);
-	if (ret) {
-		dev_err(cs35l41->dev,
-			"Failed waiting for OTP_BOOT_DONE: %d\n", ret);
-		goto err;
-	}
+	do {
+		if (timeout == 0) {
+			dev_err(cs35l41->dev,
+				"Timeout waiting for OTP_BOOT_DONE\n");
+			ret = -EBUSY;
+			goto err;
+		}
+		usleep_range(1000, 1100);
+		regmap_read(cs35l41->regmap, CS35L41_IRQ1_STATUS4, &int_status);
+		timeout--;
+	} while (!(int_status & CS35L41_OTP_BOOT_DONE));
 
 	regmap_read(cs35l41->regmap, CS35L41_IRQ1_STATUS3, &int_status);
 	if (int_status & CS35L41_OTP_BOOT_ERR) {
@@ -1238,13 +3747,13 @@
 
 	ret = regmap_read(cs35l41->regmap, CS35L41_DEVID, &regid);
 	if (ret < 0) {
-		dev_err(cs35l41->dev, "Get Device ID failed: %d\n", ret);
+		dev_err(cs35l41->dev, "Get Device ID failed\n");
 		goto err;
 	}
 
 	ret = regmap_read(cs35l41->regmap, CS35L41_REVID, &reg_revid);
 	if (ret < 0) {
-		dev_err(cs35l41->dev, "Get Revision ID failed: %d\n", ret);
+		dev_err(cs35l41->dev, "Get Revision ID failed\n");
 		goto err;
 	}
 
@@ -1261,195 +3770,190 @@
 		goto err;
 	}
 
-	cs35l41_test_key_unlock(cs35l41->dev, cs35l41->regmap);
+	irq_pol = cs35l41_irq_gpio_config(cs35l41);
 
-	ret = cs35l41_register_errata_patch(cs35l41->dev, cs35l41->regmap, reg_revid);
-	if (ret)
-		goto err;
+	mutex_init(&cs35l41->vol_ctl.vol_mutex);
+	cs35l41->vol_ctl.dig_vol = 0;
+	cs35l41->vol_ctl.ramp_init_att = 0;
+	cs35l41->vol_ctl.ramp_knee_att = 0;
+	cs35l41->vol_ctl.ramp_knee_time = 0;
+	cs35l41->vol_ctl.ramp_end_time = 0;
+	atomic_set(&cs35l41->vol_ctl.playback, 0);
+	atomic_set(&cs35l41->vol_ctl.vol_ramp, 0);
+	atomic_set(&cs35l41->vol_ctl.manual_ramp, 0);
+	atomic_set(&cs35l41->vol_ctl.ramp_abort, 0);
+	cs35l41->vol_ctl.auto_ramp_timeout = 0;
+	cs35l41->vol_ctl.output_dev = CS35L41_OUTPUT_DEV_SPK;
+	cs35l41->vol_ctl.prev_active_dev = CS35L41_OUTPUT_DEV_SPK;
+	cs35l41->vol_ctl.ramp_wq =
+		create_singlethread_workqueue("cs35l41_ramp");
+	INIT_WORK(&cs35l41->vol_ctl.ramp_work, cs35l41_vol_ramp);
+
+	ret = devm_request_threaded_irq(cs35l41->dev, cs35l41->irq, NULL,
+			cs35l41_irq, IRQF_ONESHOT | IRQF_SHARED | irq_pol,
+			"cs35l41", cs35l41);
 
-	ret = cs35l41_otp_unpack(cs35l41->dev, cs35l41->regmap);
-	if (ret < 0) {
-		dev_err(cs35l41->dev, "OTP Unpack failed: %d\n", ret);
+	/* CS35L41 needs INT for PDN_DONE */
+	if (ret != 0) {
+		dev_err(cs35l41->dev, "Failed to request IRQ: %d\n", ret);
+		ret = -ENODEV;
 		goto err;
 	}
 
-	cs35l41_test_key_lock(cs35l41->dev, cs35l41->regmap);
-
-	irq_pol = cs35l41_gpio_config(cs35l41->regmap, &cs35l41->hw_cfg);
-
 	/* Set interrupt masks for critical errors */
 	regmap_write(cs35l41->regmap, CS35L41_IRQ1_MASK1,
-		     CS35L41_INT1_MASK_DEFAULT);
+			CS35L41_INT1_MASK_DEFAULT);
+	if (cs35l41->pdata.shared_boost == SHARED_BOOST_PASSIVE)
+		regmap_write(cs35l41->regmap, CS35L41_IRQ1_MASK3,
+			     CS35L41_INT3_UNMASK_PLL_LOCK);
+
+	mutex_init(&cs35l41->force_int_lock);
+
+	if (!cs35l41->pdata.fwname_use_revid)
+		cs35l41->dsp.part = cs35l41->dt_name;
+
+	switch (reg_revid) {
+	case CS35L41_REVID_A0:
+		cs35l41->amp_hibernate = CS35L41_HIBERNATE_INCOMPATIBLE;
+		if (cs35l41->pdata.fwname_use_revid)
+			cs35l41->dsp.part = devm_kasprintf(cs35l41->dev,
+				GFP_KERNEL,
+				"%s-%s",
+				cs35l41->dt_name, "revA");
+		ret = regmap_multi_reg_write(cs35l41->regmap,
+				cs35l41_reva0_errata_patch,
+				ARRAY_SIZE(cs35l41_reva0_errata_patch));
+		if (ret < 0) {
+			dev_err(cs35l41->dev,
+				"Failed to apply A0 errata patch %d\n", ret);
+			goto err;
+		}
+		break;
+	case CS35L41_REVID_B0:
+		cs35l41->amp_hibernate = CS35L41_HIBERNATE_INCOMPATIBLE;
+		if (cs35l41->pdata.fwname_use_revid)
+			cs35l41->dsp.part = devm_kasprintf(cs35l41->dev,
+				GFP_KERNEL,
+				"%s-%s",
+				cs35l41->dt_name, "revB0");
+		ret = regmap_multi_reg_write(cs35l41->regmap,
+				cs35l41_revb0_errata_patch,
+				ARRAY_SIZE(cs35l41_revb0_errata_patch));
+		if (ret < 0) {
+			dev_err(cs35l41->dev,
+				"Failed to apply B0 errata patch %d\n", ret);
+			goto err;
+		}
+		break;
+	case CS35L41_REVID_B2:
+		if (cs35l41->pdata.fwname_use_revid)
+			cs35l41->dsp.part = devm_kasprintf(cs35l41->dev,
+				GFP_KERNEL,
+				"%s-%s",
+				cs35l41->dt_name, "revB2");
+		ret = regmap_multi_reg_write(cs35l41->regmap,
+				cs35l41_revb2_errata_patch,
+				ARRAY_SIZE(cs35l41_revb2_errata_patch));
+		if (ret < 0) {
+			dev_err(cs35l41->dev,
+				"Failed to apply B2 errata patch %d\n", ret);
+			goto err;
+		}
 
-	ret = devm_request_threaded_irq(cs35l41->dev, cs35l41->irq, NULL, cs35l41_irq,
-					IRQF_ONESHOT | IRQF_SHARED | irq_pol,
-					"cs35l41", cs35l41);
-	if (ret != 0) {
-		dev_err(cs35l41->dev, "Failed to request IRQ: %d\n", ret);
-		goto err;
+		if (cs35l41->pdata.hibernate_enable)
+			cs35l41->amp_hibernate = CS35L41_HIBERNATE_NOT_LOADED;
+		else
+			cs35l41->amp_hibernate = CS35L41_HIBERNATE_INCOMPATIBLE;
+
+		cs35l41->reset_cache.extclk_cfg = false;
+		cs35l41->reset_cache.asp_wl = -1;
+		cs35l41->reset_cache.asp_width = -1;
+		cs35l41->reset_cache.asp_fmt = -1;
+		cs35l41->reset_cache.sclk_fmt = -1;
+		cs35l41->reset_cache.clock_mode = -1;
+		cs35l41->reset_cache.lrclk_fmt = -1;
+		cs35l41->reset_cache.fs_cfg = -1;
+		break;
 	}
 
-	ret = cs35l41_set_pdata(cs35l41);
+	ret = cs35l41_otp_unpack(cs35l41);
 	if (ret < 0) {
-		dev_err(cs35l41->dev, "Set pdata failed: %d\n", ret);
-		goto err;
+		dev_err(cs35l41->dev, "OTP Unpack failed\n");
+		goto err_otp;
 	}
 
-	ret = cs35l41_acpi_get_name(cs35l41);
-	if (ret < 0)
-		goto err;
+	/* read all trim regs */
+	p_trim_data = cs35l41->trim_cache;
+	for (i = 0; i < CS35L41_TRIM_CACHE_REGIONS; i++) {
+		regmap_raw_read(cs35l41->regmap,
+				cs35l41_trim_cache_regs[i].reg,
+				p_trim_data, cs35l41_trim_cache_regs[i].size *
+				sizeof(u32));
+		p_trim_data += cs35l41_trim_cache_regs[i].size;
+	}
 
-	ret = cs35l41_dsp_init(cs35l41);
-	if (ret < 0)
-		goto err;
+	ret = regmap_write(cs35l41->regmap, CS35L41_DSP1_CCM_CORE_CTRL, 0);
+	if (ret < 0) {
+		dev_err(cs35l41->dev, "Write CCM_CORE_CTRL failed\n");
+		goto err_otp;
+	}
 
-	pm_runtime_set_autosuspend_delay(cs35l41->dev, 3000);
-	pm_runtime_use_autosuspend(cs35l41->dev);
-	pm_runtime_mark_last_busy(cs35l41->dev);
-	pm_runtime_set_active(cs35l41->dev);
-	pm_runtime_get_noresume(cs35l41->dev);
-	pm_runtime_enable(cs35l41->dev);
-
-	ret = devm_snd_soc_register_component(cs35l41->dev,
-					      &soc_component_dev_cs35l41,
-					      cs35l41_dai, ARRAY_SIZE(cs35l41_dai));
+	ret = cs35l41_dsp_init(cs35l41);
 	if (ret < 0) {
-		dev_err(cs35l41->dev, "Register codec failed: %d\n", ret);
-		goto err_pm;
+		dev_err(cs35l41->dev, "%s: dsp_init failed\n",
+			__func__);
+		goto err_otp;
 	}
 
-	pm_runtime_put_autosuspend(cs35l41->dev);
+	ret = snd_soc_register_component(cs35l41->dev,
+					&soc_component_dev_cs35l41,
+					cs35l41_dai, ARRAY_SIZE(cs35l41_dai));
+	if (ret < 0) {
+		dev_err(cs35l41->dev, "%s: Register codec failed\n", __func__);
+		goto err_dsp;
+	}
 
 	dev_info(cs35l41->dev, "Cirrus Logic CS35L41 (%x), Revision: %02X\n",
-		 regid, reg_revid);
-
-	return 0;
+			regid, reg_revid);
 
-err_pm:
-	pm_runtime_disable(cs35l41->dev);
-	pm_runtime_put_noidle(cs35l41->dev);
+	cs35l41->wq = create_singlethread_workqueue("cs35l41");
+	if (cs35l41->wq == NULL) {
+		ret = -ENOMEM;
+		goto err_codec;
+	}
 
+	INIT_DELAYED_WORK(&cs35l41->hb_work, cs35l41_hibernate_work);
+	mutex_init(&cs35l41->hb_lock);
+	return 0;
+err_codec:
+	snd_soc_unregister_component(cs35l41->dev);
+err_dsp:
 	wm_adsp2_remove(&cs35l41->dsp);
+err_otp:
+	destroy_workqueue(cs35l41->vol_ctl.ramp_wq);
+	mutex_destroy(&cs35l41->force_int_lock);
+	mutex_destroy(&cs35l41->vol_ctl.vol_mutex);
 err:
-	cs35l41_safe_reset(cs35l41->regmap, cs35l41->hw_cfg.bst_type);
-	regulator_bulk_disable(CS35L41_NUM_SUPPLIES, cs35l41->supplies);
-	gpiod_set_value_cansleep(cs35l41->reset_gpio, 0);
-
+	regulator_bulk_disable(cs35l41->num_supplies, cs35l41->supplies);
 	return ret;
 }
-EXPORT_SYMBOL_GPL(cs35l41_probe);
 
 void cs35l41_remove(struct cs35l41_private *cs35l41)
 {
-	pm_runtime_get_sync(cs35l41->dev);
-	pm_runtime_disable(cs35l41->dev);
-
+	destroy_workqueue(cs35l41->wq);
+	mutex_destroy(&cs35l41->hb_lock);
+	destroy_workqueue(cs35l41->vol_ctl.ramp_wq);
+	mutex_destroy(&cs35l41->vol_ctl.vol_mutex);
 	regmap_write(cs35l41->regmap, CS35L41_IRQ1_MASK1, 0xFFFFFFFF);
-	kfree(cs35l41->dsp.system_name);
+	if (cs35l41->pdata.shared_boost == SHARED_BOOST_PASSIVE)
+		regmap_write(cs35l41->regmap, CS35L41_IRQ1_MASK3,
+			     CS35L41_INT3_MASK_DEFAULT);
+	mutex_destroy(&cs35l41->force_int_lock);
 	wm_adsp2_remove(&cs35l41->dsp);
-	cs35l41_safe_reset(cs35l41->regmap, cs35l41->hw_cfg.bst_type);
-
-	pm_runtime_put_noidle(cs35l41->dev);
-
-	regulator_bulk_disable(CS35L41_NUM_SUPPLIES, cs35l41->supplies);
-	gpiod_set_value_cansleep(cs35l41->reset_gpio, 0);
-}
-EXPORT_SYMBOL_GPL(cs35l41_remove);
-
-static int __maybe_unused cs35l41_runtime_suspend(struct device *dev)
-{
-	struct cs35l41_private *cs35l41 = dev_get_drvdata(dev);
-
-	dev_dbg(cs35l41->dev, "Runtime suspend\n");
-
-	if (!cs35l41->dsp.preloaded || !cs35l41->dsp.cs_dsp.running)
-		return 0;
-
-	cs35l41_enter_hibernate(dev, cs35l41->regmap, cs35l41->hw_cfg.bst_type);
-
-	regcache_cache_only(cs35l41->regmap, true);
-	regcache_mark_dirty(cs35l41->regmap);
-
-	return 0;
-}
-
-static int __maybe_unused cs35l41_runtime_resume(struct device *dev)
-{
-	struct cs35l41_private *cs35l41 = dev_get_drvdata(dev);
-	int ret;
-
-	dev_dbg(cs35l41->dev, "Runtime resume\n");
-
-	if (!cs35l41->dsp.preloaded || !cs35l41->dsp.cs_dsp.running)
-		return 0;
-
-	regcache_cache_only(cs35l41->regmap, false);
-
-	ret = cs35l41_exit_hibernate(cs35l41->dev, cs35l41->regmap);
-	if (ret)
-		return ret;
-
-	/* Test key needs to be unlocked to allow the OTP settings to re-apply */
-	cs35l41_test_key_unlock(cs35l41->dev, cs35l41->regmap);
-	ret = regcache_sync(cs35l41->regmap);
-	cs35l41_test_key_lock(cs35l41->dev, cs35l41->regmap);
-	if (ret) {
-		dev_err(cs35l41->dev, "Failed to restore register cache: %d\n", ret);
-		return ret;
-	}
-	cs35l41_init_boost(cs35l41->dev, cs35l41->regmap, &cs35l41->hw_cfg);
-
-	return 0;
-}
-
-static int __maybe_unused cs35l41_sys_suspend(struct device *dev)
-{
-	struct cs35l41_private *cs35l41 = dev_get_drvdata(dev);
-
-	dev_dbg(cs35l41->dev, "System suspend, disabling IRQ\n");
-	disable_irq(cs35l41->irq);
-
+	regulator_bulk_disable(cs35l41->num_supplies, cs35l41->supplies);
+	snd_soc_unregister_component(cs35l41->dev);
-	return 0;
 }
 
-static int __maybe_unused cs35l41_sys_suspend_noirq(struct device *dev)
-{
-	struct cs35l41_private *cs35l41 = dev_get_drvdata(dev);
-
-	dev_dbg(cs35l41->dev, "Late system suspend, reenabling IRQ\n");
-	enable_irq(cs35l41->irq);
-
-	return 0;
-}
-
-static int __maybe_unused cs35l41_sys_resume_noirq(struct device *dev)
-{
-	struct cs35l41_private *cs35l41 = dev_get_drvdata(dev);
-
-	dev_dbg(cs35l41->dev, "Early system resume, disabling IRQ\n");
-	disable_irq(cs35l41->irq);
-
-	return 0;
-}
-
-static int __maybe_unused cs35l41_sys_resume(struct device *dev)
-{
-	struct cs35l41_private *cs35l41 = dev_get_drvdata(dev);
-
-	dev_dbg(cs35l41->dev, "System resume, reenabling IRQ\n");
-	enable_irq(cs35l41->irq);
-
-	return 0;
-}
-
-const struct dev_pm_ops cs35l41_pm_ops = {
-	SET_RUNTIME_PM_OPS(cs35l41_runtime_suspend, cs35l41_runtime_resume, NULL)
-
-	SET_SYSTEM_SLEEP_PM_OPS(cs35l41_sys_suspend, cs35l41_sys_resume)
-	SET_NOIRQ_SYSTEM_SLEEP_PM_OPS(cs35l41_sys_suspend_noirq, cs35l41_sys_resume_noirq)
-};
-EXPORT_SYMBOL_GPL(cs35l41_pm_ops);
-
 MODULE_DESCRIPTION("ASoC CS35L41 driver");
 MODULE_AUTHOR("David Rhodes, Cirrus Logic Inc, <david.rhodes@cirrus.com>");
 MODULE_LICENSE("GPL");
diff -ruN a/sound/soc/codecs/cs35l41_dsp_events.h b/sound/soc/codecs/cs35l41_dsp_events.h
--- a/sound/soc/codecs/cs35l41_dsp_events.h	1970-01-01 01:00:00.000000000 +0100
+++ b/sound/soc/codecs/cs35l41_dsp_events.h	2022-07-08 01:12:12.000000000 +0200
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/*
+ * cs35l41_dsp_events.h -- DSP-generated event definitions for CS35L41
+ *
+ * Copyright (c) 2018-2020 Cirrus Logic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __CS35L41_DSP_EVENTS_H
+#define __CS35L41_DSP_EVENTS_H
+
+// Event definitions
+#define EVENT_PORT_BLOCKED 0x65
+#define EVENT_SPEAKER_OPEN_SHORT_STATUS 0x66
+
+// Data definitions
+#define SPK_STATUS_ALL_CLEAR     (1 << 0)
+#define SPK_STATUS_OPEN_CIRCUIT  (1 << 1)
+#define SPK_STATUS_SHORT_CIRCUIT (1 << 2)
+
+#endif /* __CS35L41_DSP_EVENTS_H */
diff -ruN a/sound/soc/codecs/cs35l41.h b/sound/soc/codecs/cs35l41.h
--- a/sound/soc/codecs/cs35l41.h	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/codecs/cs35l41.h	2022-07-08 01:12:12.000000000 +0200
@@ -1,41 +1,852 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/*
  * cs35l41.h -- CS35L41 ALSA SoC audio driver
  *
- * Copyright 2017-2021 Cirrus Logic, Inc.
+ * Copyright 2017-2020 Cirrus Logic, Inc.
+ *
+ * Author: Brian Austin <brian.austin@cirrus.com>
+ *         David Rhodes <david.rhodes@cirrus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
  *
- * Author: David Rhodes <david.rhodes@cirrus.com>
  */
 
 #ifndef __CS35L41_H__
 #define __CS35L41_H__
 
-#include <linux/gpio/consumer.h>
-#include <linux/regulator/consumer.h>
-#include <linux/firmware.h>
-#include <sound/core.h>
-#include <sound/cs35l41.h>
+#include <linux/regmap.h>
+
+#define CS35L41_FIRSTREG		0x00000000
+#define CS35L41_LASTREG			0x03804FE8
+#define CS35L41_DEVID			0x00000000
+#define CS35L41_REVID			0x00000004
+#define CS35L41_FABID			0x00000008
+#define CS35L41_RELID			0x0000000C
+#define CS35L41_OTPID			0x00000010
+#define CS35L41_SFT_RESET		0x00000020
+#define CS35L41_TEST_KEY_CTL		0x00000040
+#define CS35L41_USER_KEY_CTL		0x00000044
+#define CS35L41_OTP_MEM0		0x00000400
+#define CS35L41_OTP_MEM31		0x0000047C
+#define CS35L41_OTP_CTRL0		0x00000500
+#define CS35L41_OTP_CTRL1		0x00000504
+#define CS35L41_OTP_CTRL3		0x00000508
+#define CS35L41_OTP_CTRL4		0x0000050C
+#define CS35L41_OTP_CTRL5		0x00000510
+#define CS35L41_OTP_CTRL6		0x00000514
+#define CS35L41_OTP_CTRL7		0x00000518
+#define CS35L41_OTP_CTRL8		0x0000051C
+#define CS35L41_PWR_CTRL1		0x00002014
+#define CS35L41_PWR_CTRL2		0x00002018
+#define CS35L41_PWR_CTRL3		0x0000201C
+#define CS35L41_CTRL_OVRRIDE		0x00002020
+#define CS35L41_AMP_OUT_MUTE		0x00002024
+#define CS35L41_PROTECT_REL_ERR_IGN	0x00002034
+#define CS35L41_GPIO_PAD_CONTROL	0x0000242C
+#define CS35L41_JTAG_CONTROL		0x00002438
+#define CS35L41_PWRMGT_CTL		0x00002900
+#define CS35L41_WAKESRC_CTL		0x00002904
+#define CS35L41_PWRMGT_STS		0x00002908
+#define CS35L41_PLL_CLK_CTRL		0x00002C04
+#define CS35L41_DSP_CLK_CTRL		0x00002C08
+#define CS35L41_GLOBAL_CLK_CTRL		0x00002C0C
+#define CS35L41_DATA_FS_SEL		0x00002C10
+#define CS35L41_TST_FS_MON0		0x00002D10
+#define CS35L41_MDSYNC_EN		0x00003400
+#define CS35L41_MDSYNC_TX_ID		0x00003408
+#define CS35L41_MDSYNC_PWR_CTRL		0x0000340C
+#define CS35L41_MDSYNC_DATA_TX		0x00003410
+#define CS35L41_MDSYNC_TX_STATUS	0x00003414
+#define CS35L41_MDSYNC_DATA_RX		0x0000341C
+#define CS35L41_MDSYNC_RX_STATUS	0x00003420
+#define CS35L41_MDSYNC_ERR_STATUS	0x00003424
+#define CS35L41_MDSYNC_SYNC_PTE2	0x00003528
+#define CS35L41_MDSYNC_SYNC_PTE3	0x0000352C
+#define CS35L41_MDSYNC_SYNC_MSM_STATUS	0x0000353C
+#define CS35L41_BSTCVRT_VCTRL1		0x00003800
+#define CS35L41_BSTCVRT_VCTRL2		0x00003804
+#define CS35L41_BSTCVRT_PEAK_CUR	0x00003808
+#define CS35L41_BSTCVRT_SFT_RAMP	0x0000380C
+#define CS35L41_BSTCVRT_COEFF		0x00003810
+#define CS35L41_BSTCVRT_SLOPE_LBST	0x00003814
+#define CS35L41_BSTCVRT_SW_FREQ		0x00003818
+#define CS35L41_BSTCVRT_DCM_CTRL	0x0000381C
+#define CS35L41_BSTCVRT_DCM_MODE_FORCE	0x00003820
+#define CS35L41_BSTCVRT_OVERVOLT_CTRL	0x00003830
+#define CS35L41_VI_VOL_POL		0x00004000
+#define CS35L41_VIMON_SPKMON_RESYNC	0x00004100
+#define CS35L41_DTEMP_WARN_THLD		0x00004220
+#define CS35L41_DTEMP_CFG		0x00004224
+#define CS35L41_DTEMP_EN		0x00004308
+#define CS35L41_VPVBST_FS_SEL		0x00004400
+#define CS35L41_SP_ENABLES		0x00004800
+#define CS35L41_SP_RATE_CTRL		0x00004804
+#define CS35L41_SP_FORMAT		0x00004808
+#define CS35L41_SP_HIZ_CTRL		0x0000480C
+#define CS35L41_SP_FRAME_TX_SLOT	0x00004810
+#define CS35L41_SP_FRAME_RX_SLOT	0x00004820
+#define CS35L41_SP_TX_WL		0x00004830
+#define CS35L41_SP_RX_WL		0x00004840
+#define CS35L41_ASP_CONTROL4		0x00004854
+#define CS35L41_DAC_PCM1_SRC		0x00004C00
+#define CS35L41_ASP_TX1_SRC		0x00004C20
+#define CS35L41_ASP_TX2_SRC		0x00004C24
+#define CS35L41_ASP_TX3_SRC		0x00004C28
+#define CS35L41_ASP_TX4_SRC		0x00004C2C
+#define CS35L41_DSP1_RX1_SRC		0x00004C40
+#define CS35L41_DSP1_RX2_SRC		0x00004C44
+#define CS35L41_DSP1_RX3_SRC		0x00004C48
+#define CS35L41_DSP1_RX4_SRC		0x00004C4C
+#define CS35L41_DSP1_RX5_SRC		0x00004C50
+#define CS35L41_DSP1_RX6_SRC		0x00004C54
+#define CS35L41_DSP1_RX7_SRC		0x00004C58
+#define CS35L41_DSP1_RX8_SRC		0x00004C5C
+#define CS35L41_NGATE1_SRC		0x00004C60
+#define CS35L41_NGATE2_SRC		0x00004C64
+#define CS35L41_AMP_DIG_VOL_CTRL	0x00006000
+#define CS35L41_VPBR_CFG		0x00006404
+#define CS35L41_VBBR_CFG		0x00006408
+#define CS35L41_VPBR_STATUS		0x0000640C
+#define CS35L41_VBBR_STATUS		0x00006410
+#define CS35L41_OVERTEMP_CFG		0x00006414
+#define CS35L41_AMP_ERR_VOL		0x00006418
+#define CS35L41_VOL_STATUS_TO_DSP	0x00006450
+#define CS35L41_CLASSH_CFG		0x00006800
+#define CS35L41_WKFET_CFG		0x00006804
+#define CS35L41_NG_CFG			0x00006808
+#define CS35L41_AMP_GAIN_CTRL		0x00006C04
+#define CS35L41_DAC_MSM_CFG		0x00007400
+#define CS35L41_IRQ1_CFG		0x00010000
+#define CS35L41_IRQ1_STATUS		0x00010004
+#define CS35L41_IRQ1_STATUS1		0x00010010
+#define CS35L41_IRQ1_STATUS2		0x00010014
+#define CS35L41_IRQ1_STATUS3		0x00010018
+#define CS35L41_IRQ1_STATUS4		0x0001001C
+#define CS35L41_IRQ1_RAW_STATUS1	0x00010090
+#define CS35L41_IRQ1_RAW_STATUS2	0x00010094
+#define CS35L41_IRQ1_RAW_STATUS3	0x00010098
+#define CS35L41_IRQ1_RAW_STATUS4	0x0001009C
+#define CS35L41_IRQ1_MASK1		0x00010110
+#define CS35L41_IRQ1_MASK2		0x00010114
+#define CS35L41_IRQ1_MASK3		0x00010118
+#define CS35L41_IRQ1_MASK4		0x0001011C
+#define CS35L41_IRQ1_FRC1		0x00010190
+#define CS35L41_IRQ1_FRC2		0x00010194
+#define CS35L41_IRQ1_FRC3		0x00010198
+#define CS35L41_IRQ1_FRC4		0x0001019C
+#define CS35L41_IRQ1_EDGE1		0x00010210
+#define CS35L41_IRQ1_EDGE4		0x0001021C
+#define CS35L41_IRQ1_POL1		0x00010290
+#define CS35L41_IRQ1_POL2		0x00010294
+#define CS35L41_IRQ1_POL3		0x00010298
+#define CS35L41_IRQ1_POL4		0x0001029C
+#define CS35L41_IRQ1_DB3		0x00010318
+#define CS35L41_IRQ2_CFG		0x00010800
+#define CS35L41_IRQ2_STATUS		0x00010804
+#define CS35L41_IRQ2_STATUS1		0x00010810
+#define CS35L41_IRQ2_STATUS2		0x00010814
+#define CS35L41_IRQ2_STATUS3		0x00010818
+#define CS35L41_IRQ2_STATUS4		0x0001081C
+#define CS35L41_IRQ2_RAW_STATUS1	0x00010890
+#define CS35L41_IRQ2_RAW_STATUS2	0x00010894
+#define CS35L41_IRQ2_RAW_STATUS3	0x00010898
+#define CS35L41_IRQ2_RAW_STATUS4	0x0001089C
+#define CS35L41_IRQ2_MASK1		0x00010910
+#define CS35L41_IRQ2_MASK2		0x00010914
+#define CS35L41_IRQ2_MASK3		0x00010918
+#define CS35L41_IRQ2_MASK4		0x0001091C
+#define CS35L41_IRQ2_FRC1		0x00010990
+#define CS35L41_IRQ2_FRC2		0x00010994
+#define CS35L41_IRQ2_FRC3		0x00010998
+#define CS35L41_IRQ2_FRC4		0x0001099C
+#define CS35L41_IRQ2_EDGE1		0x00010A10
+#define CS35L41_IRQ2_EDGE4		0x00010A1C
+#define CS35L41_IRQ2_POL1		0x00010A90
+#define CS35L41_IRQ2_POL2		0x00010A94
+#define CS35L41_IRQ2_POL3		0x00010A98
+#define CS35L41_IRQ2_POL4		0x00010A9C
+#define CS35L41_IRQ2_DB3		0x00010B18
+#define CS35L41_GPIO_STATUS1		0x00011000
+#define CS35L41_GPIO1_CTRL1		0x00011008
+#define CS35L41_GPIO2_CTRL1		0x0001100C
+#define CS35L41_MIXER_NGATE_CFG		0x00012000
+#define CS35L41_MIXER_NGATE_CH1_CFG	0x00012004
+#define CS35L41_MIXER_NGATE_CH2_CFG	0x00012008
+#define CS35L41_DSP_MBOX_1		0x00013000
+#define CS35L41_DSP_MBOX_2		0x00013004
+#define CS35L41_DSP_MBOX_3		0x00013008
+#define CS35L41_DSP_MBOX_4		0x0001300C
+#define CS35L41_DSP_MBOX_5		0x00013010
+#define CS35L41_DSP_MBOX_6		0x00013014
+#define CS35L41_DSP_MBOX_7		0x00013018
+#define CS35L41_DSP_MBOX_8		0x0001301C
+#define CS35L41_DSP_VIRT1_MBOX_1	0x00013020
+#define CS35L41_DSP_VIRT1_MBOX_2	0x00013024
+#define CS35L41_DSP_VIRT1_MBOX_3	0x00013028
+#define CS35L41_DSP_VIRT1_MBOX_4	0x0001302C
+#define CS35L41_DSP_VIRT1_MBOX_5	0x00013030
+#define CS35L41_DSP_VIRT1_MBOX_6	0x00013034
+#define CS35L41_DSP_VIRT1_MBOX_7	0x00013038
+#define CS35L41_DSP_VIRT1_MBOX_8	0x0001303C
+#define CS35L41_DSP_VIRT2_MBOX_1	0x00013040
+#define CS35L41_DSP_VIRT2_MBOX_2	0x00013044
+#define CS35L41_DSP_VIRT2_MBOX_3	0x00013048
+#define CS35L41_DSP_VIRT2_MBOX_4	0x0001304C
+#define CS35L41_DSP_VIRT2_MBOX_5	0x00013050
+#define CS35L41_DSP_VIRT2_MBOX_6	0x00013054
+#define CS35L41_DSP_VIRT2_MBOX_7	0x00013058
+#define CS35L41_DSP_VIRT2_MBOX_8	0x0001305C
+#define CS35L41_CLOCK_DETECT_1		0x00014000
+#define CS35L41_TIMER1_CONTROL		0x00015000
+#define CS35L41_TIMER1_COUNT_PRESET	0x00015004
+#define CS35L41_TIMER1_START_STOP	0x0001500C
+#define CS35L41_TIMER1_STATUS		0x00015010
+#define CS35L41_TIMER1_COUNT_READBACK	0x00015014
+#define CS35L41_TIMER1_DSP_CLK_CFG	0x00015018
+#define CS35L41_TIMER1_DSP_CLK_STATUS	0x0001501C
+#define CS35L41_TIMER2_CONTROL		0x00015100
+#define CS35L41_TIMER2_COUNT_PRESET	0x00015104
+#define CS35L41_TIMER2_START_STOP	0x0001510C
+#define CS35L41_TIMER2_STATUS		0x00015110
+#define CS35L41_TIMER2_COUNT_READBACK	0x00015114
+#define CS35L41_TIMER2_DSP_CLK_CFG	0x00015118
+#define CS35L41_TIMER2_DSP_CLK_STATUS	0x0001511C
+#define CS35L41_DFT_JTAG_CONTROL	0x00016000
+#define CS35L41_DIE_STS1		0x00017040
+#define CS35L41_DIE_STS2		0x00017044
+#define CS35L41_TEMP_CAL1		0x00017048
+#define CS35L41_TEMP_CAL2		0x0001704C
+#define CS35L41_DSP1_XMEM_PACK_0	0x02000000
+#define CS35L41_DSP1_XMEM_PACK_3068	0x02002FF0
+#define CS35L41_DSP1_XMEM_UNPACK32_0	0x02400000
+#define CS35L41_DSP1_XMEM_UNPACK32_2046	0x02401FF8
+#define CS35L41_DSP1_TIMESTAMP_COUNT	0x025C0800
+#define CS35L41_DSP1_SYS_ID		0x025E0000
+#define CS35L41_DSP1_SYS_VERSION	0x025E0004
+#define CS35L41_DSP1_SYS_CORE_ID	0x025E0008
+#define CS35L41_DSP1_SYS_AHB_ADDR	0x025E000C
+#define CS35L41_DSP1_SYS_XSRAM_SIZE	0x025E0010
+#define CS35L41_DSP1_SYS_YSRAM_SIZE	0x025E0018
+#define CS35L41_DSP1_SYS_PSRAM_SIZE	0x025E0020
+#define CS35L41_DSP1_SYS_PM_BOOT_SIZE	0x025E0028
+#define CS35L41_DSP1_SYS_FEATURES	0x025E002C
+#define CS35L41_DSP1_SYS_FIR_FILTERS	0x025E0030
+#define CS35L41_DSP1_SYS_LMS_FILTERS	0x025E0034
+#define CS35L41_DSP1_SYS_XM_BANK_SIZE	0x025E0038
+#define CS35L41_DSP1_SYS_YM_BANK_SIZE	0x025E003C
+#define CS35L41_DSP1_SYS_PM_BANK_SIZE	0x025E0040
+#define CS35L41_DSP1_AHBM_WIN0_CTRL0	0x025E2000
+#define CS35L41_DSP1_AHBM_WIN0_CTRL1	0x025E2004
+#define CS35L41_DSP1_AHBM_WIN1_CTRL0	0x025E2008
+#define CS35L41_DSP1_AHBM_WIN1_CTRL1	0x025E200C
+#define CS35L41_DSP1_AHBM_WIN2_CTRL0	0x025E2010
+#define CS35L41_DSP1_AHBM_WIN2_CTRL1	0x025E2014
+#define CS35L41_DSP1_AHBM_WIN3_CTRL0	0x025E2018
+#define CS35L41_DSP1_AHBM_WIN3_CTRL1	0x025E201C
+#define CS35L41_DSP1_AHBM_WIN4_CTRL0	0x025E2020
+#define CS35L41_DSP1_AHBM_WIN4_CTRL1	0x025E2024
+#define CS35L41_DSP1_AHBM_WIN5_CTRL0	0x025E2028
+#define CS35L41_DSP1_AHBM_WIN5_CTRL1	0x025E202C
+#define CS35L41_DSP1_AHBM_WIN6_CTRL0	0x025E2030
+#define CS35L41_DSP1_AHBM_WIN6_CTRL1	0x025E2034
+#define CS35L41_DSP1_AHBM_WIN7_CTRL0	0x025E2038
+#define CS35L41_DSP1_AHBM_WIN7_CTRL1	0x025E203C
+#define CS35L41_DSP1_AHBM_WIN_DBG_CTRL0	0x025E2040
+#define CS35L41_DSP1_AHBM_WIN_DBG_CTRL1	0x025E2044
+#define CS35L41_DSP1_XMEM_UNPACK24_0	0x02800000
+#define CS35L41_DSP1_XMEM_UNPACK24_4093	0x02803FF4
+#define CS35L41_DSP1_CTRL_BASE		0x02B80000
+#define CS35L41_DSP1_CORE_SOFT_RESET	0x02B80010
+#define CS35L41_DSP1_DEBUG		0x02B80040
+#define CS35L41_DSP1_TIMER_CTRL		0x02B80048
+#define CS35L41_DSP1_STREAM_ARB_CTRL	0x02B80050
+#define CS35L41_DSP1_RX1_RATE		0x02B80080
+#define CS35L41_DSP1_RX2_RATE		0x02B80088
+#define CS35L41_DSP1_RX3_RATE		0x02B80090
+#define CS35L41_DSP1_RX4_RATE		0x02B80098
+#define CS35L41_DSP1_RX5_RATE		0x02B800A0
+#define CS35L41_DSP1_RX6_RATE		0x02B800A8
+#define CS35L41_DSP1_RX7_RATE		0x02B800B0
+#define CS35L41_DSP1_RX8_RATE		0x02B800B8
+#define CS35L41_DSP1_TX1_RATE		0x02B80280
+#define CS35L41_DSP1_TX2_RATE		0x02B80288
+#define CS35L41_DSP1_TX3_RATE		0x02B80290
+#define CS35L41_DSP1_TX4_RATE		0x02B80298
+#define CS35L41_DSP1_TX5_RATE		0x02B802A0
+#define CS35L41_DSP1_TX6_RATE		0x02B802A8
+#define CS35L41_DSP1_TX7_RATE		0x02B802B0
+#define CS35L41_DSP1_TX8_RATE		0x02B802B8
+#define CS35L41_DSP1_NMI_CTRL1		0x02B80480
+#define CS35L41_DSP1_NMI_CTRL2		0x02B80488
+#define CS35L41_DSP1_NMI_CTRL3		0x02B80490
+#define CS35L41_DSP1_NMI_CTRL4		0x02B80498
+#define CS35L41_DSP1_NMI_CTRL5		0x02B804A0
+#define CS35L41_DSP1_NMI_CTRL6		0x02B804A8
+#define CS35L41_DSP1_NMI_CTRL7		0x02B804B0
+#define CS35L41_DSP1_NMI_CTRL8		0x02B804B8
+#define CS35L41_DSP1_RESUME_CTRL	0x02B80500
+#define CS35L41_DSP1_IRQ1_CTRL		0x02B80508
+#define CS35L41_DSP1_IRQ2_CTRL		0x02B80510
+#define CS35L41_DSP1_IRQ3_CTRL		0x02B80518
+#define CS35L41_DSP1_IRQ4_CTRL		0x02B80520
+#define CS35L41_DSP1_IRQ5_CTRL		0x02B80528
+#define CS35L41_DSP1_IRQ6_CTRL		0x02B80530
+#define CS35L41_DSP1_IRQ7_CTRL		0x02B80538
+#define CS35L41_DSP1_IRQ8_CTRL		0x02B80540
+#define CS35L41_DSP1_IRQ9_CTRL		0x02B80548
+#define CS35L41_DSP1_IRQ10_CTRL		0x02B80550
+#define CS35L41_DSP1_IRQ11_CTRL		0x02B80558
+#define CS35L41_DSP1_IRQ12_CTRL		0x02B80560
+#define CS35L41_DSP1_IRQ13_CTRL		0x02B80568
+#define CS35L41_DSP1_IRQ14_CTRL		0x02B80570
+#define CS35L41_DSP1_IRQ15_CTRL		0x02B80578
+#define CS35L41_DSP1_IRQ16_CTRL		0x02B80580
+#define CS35L41_DSP1_IRQ17_CTRL		0x02B80588
+#define CS35L41_DSP1_IRQ18_CTRL		0x02B80590
+#define CS35L41_DSP1_IRQ19_CTRL		0x02B80598
+#define CS35L41_DSP1_IRQ20_CTRL		0x02B805A0
+#define CS35L41_DSP1_IRQ21_CTRL		0x02B805A8
+#define CS35L41_DSP1_IRQ22_CTRL		0x02B805B0
+#define CS35L41_DSP1_IRQ23_CTRL		0x02B805B8
+#define CS35L41_DSP1_SCRATCH1		0x02B805C0
+#define CS35L41_DSP1_SCRATCH2		0x02B805C8
+#define CS35L41_DSP1_SCRATCH3		0x02B805D0
+#define CS35L41_DSP1_SCRATCH4		0x02B805D8
+#define CS35L41_DSP1_CCM_CORE_CTRL	0x02BC1000
+#define CS35L41_DSP1_CCM_CLK_OVERRIDE	0x02BC1008
+#define CS35L41_DSP1_XM_MSTR_EN		0x02BC2000
+#define CS35L41_DSP1_XM_CORE_PRI	0x02BC2008
+#define CS35L41_DSP1_XM_AHB_PACK_PL_PRI	0x02BC2010
+#define CS35L41_DSP1_XM_AHB_UP_PL_PRI	0x02BC2018
+#define CS35L41_DSP1_XM_ACCEL_PL0_PRI	0x02BC2020
+#define CS35L41_DSP1_XM_NPL0_PRI	0x02BC2078
+#define CS35L41_DSP1_YM_MSTR_EN		0x02BC20C0
+#define CS35L41_DSP1_YM_CORE_PRI	0x02BC20C8
+#define CS35L41_DSP1_YM_AHB_PACK_PL_PRI	0x02BC20D0
+#define CS35L41_DSP1_YM_AHB_UP_PL_PRI	0x02BC20D8
+#define CS35L41_DSP1_YM_ACCEL_PL0_PRI	0x02BC20E0
+#define CS35L41_DSP1_YM_NPL0_PRI	0x02BC2138
+#define CS35L41_DSP1_PM_MSTR_EN		0x02BC2180
+#define CS35L41_DSP1_PM_PATCH0_ADDR	0x02BC2188
+#define CS35L41_DSP1_PM_PATCH0_EN	0x02BC218C
+#define CS35L41_DSP1_PM_PATCH0_DATA_LO	0x02BC2190
+#define CS35L41_DSP1_PM_PATCH0_DATA_HI	0x02BC2194
+#define CS35L41_DSP1_PM_PATCH1_ADDR	0x02BC2198
+#define CS35L41_DSP1_PM_PATCH1_EN	0x02BC219C
+#define CS35L41_DSP1_PM_PATCH1_DATA_LO	0x02BC21A0
+#define CS35L41_DSP1_PM_PATCH1_DATA_HI	0x02BC21A4
+#define CS35L41_DSP1_PM_PATCH2_ADDR	0x02BC21A8
+#define CS35L41_DSP1_PM_PATCH2_EN	0x02BC21AC
+#define CS35L41_DSP1_PM_PATCH2_DATA_LO	0x02BC21B0
+#define CS35L41_DSP1_PM_PATCH2_DATA_HI	0x02BC21B4
+#define CS35L41_DSP1_PM_PATCH3_ADDR	0x02BC21B8
+#define CS35L41_DSP1_PM_PATCH3_EN	0x02BC21BC
+#define CS35L41_DSP1_PM_PATCH3_DATA_LO	0x02BC21C0
+#define CS35L41_DSP1_PM_PATCH3_DATA_HI	0x02BC21C4
+#define CS35L41_DSP1_PM_PATCH4_ADDR	0x02BC21C8
+#define CS35L41_DSP1_PM_PATCH4_EN	0x02BC21CC
+#define CS35L41_DSP1_PM_PATCH4_DATA_LO	0x02BC21D0
+#define CS35L41_DSP1_PM_PATCH4_DATA_HI	0x02BC21D4
+#define CS35L41_DSP1_PM_PATCH5_ADDR	0x02BC21D8
+#define CS35L41_DSP1_PM_PATCH5_EN	0x02BC21DC
+#define CS35L41_DSP1_PM_PATCH5_DATA_LO	0x02BC21E0
+#define CS35L41_DSP1_PM_PATCH5_DATA_HI	0x02BC21E4
+#define CS35L41_DSP1_PM_PATCH6_ADDR	0x02BC21E8
+#define CS35L41_DSP1_PM_PATCH6_EN	0x02BC21EC
+#define CS35L41_DSP1_PM_PATCH6_DATA_LO	0x02BC21F0
+#define CS35L41_DSP1_PM_PATCH6_DATA_HI	0x02BC21F4
+#define CS35L41_DSP1_PM_PATCH7_ADDR	0x02BC21F8
+#define CS35L41_DSP1_PM_PATCH7_EN	0x02BC21FC
+#define CS35L41_DSP1_PM_PATCH7_DATA_LO	0x02BC2200
+#define CS35L41_DSP1_PM_PATCH7_DATA_HI	0x02BC2204
+#define CS35L41_DSP1_MPU_XM_ACCESS0	0x02BC3000
+#define CS35L41_DSP1_MPU_YM_ACCESS0	0x02BC3004
+#define CS35L41_DSP1_MPU_WNDW_ACCESS0	0x02BC3008
+#define CS35L41_DSP1_MPU_XREG_ACCESS0	0x02BC300C
+#define CS35L41_DSP1_MPU_YREG_ACCESS0	0x02BC3014
+#define CS35L41_DSP1_MPU_XM_ACCESS1	0x02BC3018
+#define CS35L41_DSP1_MPU_YM_ACCESS1	0x02BC301C
+#define CS35L41_DSP1_MPU_WNDW_ACCESS1	0x02BC3020
+#define CS35L41_DSP1_MPU_XREG_ACCESS1	0x02BC3024
+#define CS35L41_DSP1_MPU_YREG_ACCESS1	0x02BC302C
+#define CS35L41_DSP1_MPU_XM_ACCESS2	0x02BC3030
+#define CS35L41_DSP1_MPU_YM_ACCESS2	0x02BC3034
+#define CS35L41_DSP1_MPU_WNDW_ACCESS2	0x02BC3038
+#define CS35L41_DSP1_MPU_XREG_ACCESS2	0x02BC303C
+#define CS35L41_DSP1_MPU_YREG_ACCESS2	0x02BC3044
+#define CS35L41_DSP1_MPU_XM_ACCESS3	0x02BC3048
+#define CS35L41_DSP1_MPU_YM_ACCESS3	0x02BC304C
+#define CS35L41_DSP1_MPU_WNDW_ACCESS3	0x02BC3050
+#define CS35L41_DSP1_MPU_XREG_ACCESS3	0x02BC3054
+#define CS35L41_DSP1_MPU_YREG_ACCESS3	0x02BC305C
+#define CS35L41_DSP1_MPU_XM_VIO_ADDR	0x02BC3100
+#define CS35L41_DSP1_MPU_XM_VIO_STATUS	0x02BC3104
+#define CS35L41_DSP1_MPU_YM_VIO_ADDR	0x02BC3108
+#define CS35L41_DSP1_MPU_YM_VIO_STATUS	0x02BC310C
+#define CS35L41_DSP1_MPU_PM_VIO_ADDR	0x02BC3110
+#define CS35L41_DSP1_MPU_PM_VIO_STATUS	0x02BC3114
+#define CS35L41_DSP1_MPU_LOCK_CONFIG	0x02BC3140
+#define CS35L41_DSP1_MPU_WDT_RST_CTRL	0x02BC3180
+#define CS35L41_DSP1_STRMARB_MSTR0_CFG0	0x02BC5000
+#define CS35L41_DSP1_STRMARB_MSTR0_CFG1	0x02BC5004
+#define CS35L41_DSP1_STRMARB_MSTR0_CFG2	0x02BC5008
+#define CS35L41_DSP1_STRMARB_MSTR1_CFG0	0x02BC5010
+#define CS35L41_DSP1_STRMARB_MSTR1_CFG1	0x02BC5014
+#define CS35L41_DSP1_STRMARB_MSTR1_CFG2	0x02BC5018
+#define CS35L41_DSP1_STRMARB_MSTR2_CFG0	0x02BC5020
+#define CS35L41_DSP1_STRMARB_MSTR2_CFG1	0x02BC5024
+#define CS35L41_DSP1_STRMARB_MSTR2_CFG2	0x02BC5028
+#define CS35L41_DSP1_STRMARB_MSTR3_CFG0	0x02BC5030
+#define CS35L41_DSP1_STRMARB_MSTR3_CFG1	0x02BC5034
+#define CS35L41_DSP1_STRMARB_MSTR3_CFG2	0x02BC5038
+#define CS35L41_DSP1_STRMARB_MSTR4_CFG0	0x02BC5040
+#define CS35L41_DSP1_STRMARB_MSTR4_CFG1	0x02BC5044
+#define CS35L41_DSP1_STRMARB_MSTR4_CFG2	0x02BC5048
+#define CS35L41_DSP1_STRMARB_MSTR5_CFG0	0x02BC5050
+#define CS35L41_DSP1_STRMARB_MSTR5_CFG1	0x02BC5054
+#define CS35L41_DSP1_STRMARB_MSTR5_CFG2	0x02BC5058
+#define CS35L41_DSP1_STRMARB_MSTR6_CFG0	0x02BC5060
+#define CS35L41_DSP1_STRMARB_MSTR6_CFG1	0x02BC5064
+#define CS35L41_DSP1_STRMARB_MSTR6_CFG2	0x02BC5068
+#define CS35L41_DSP1_STRMARB_MSTR7_CFG0	0x02BC5070
+#define CS35L41_DSP1_STRMARB_MSTR7_CFG1	0x02BC5074
+#define CS35L41_DSP1_STRMARB_MSTR7_CFG2	0x02BC5078
+#define CS35L41_DSP1_STRMARB_TX0_CFG0	0x02BC5200
+#define CS35L41_DSP1_STRMARB_TX0_CFG1	0x02BC5204
+#define CS35L41_DSP1_STRMARB_TX1_CFG0	0x02BC5208
+#define CS35L41_DSP1_STRMARB_TX1_CFG1	0x02BC520C
+#define CS35L41_DSP1_STRMARB_TX2_CFG0	0x02BC5210
+#define CS35L41_DSP1_STRMARB_TX2_CFG1	0x02BC5214
+#define CS35L41_DSP1_STRMARB_TX3_CFG0	0x02BC5218
+#define CS35L41_DSP1_STRMARB_TX3_CFG1	0x02BC521C
+#define CS35L41_DSP1_STRMARB_TX4_CFG0	0x02BC5220
+#define CS35L41_DSP1_STRMARB_TX4_CFG1	0x02BC5224
+#define CS35L41_DSP1_STRMARB_TX5_CFG0	0x02BC5228
+#define CS35L41_DSP1_STRMARB_TX5_CFG1	0x02BC522C
+#define CS35L41_DSP1_STRMARB_TX6_CFG0	0x02BC5230
+#define CS35L41_DSP1_STRMARB_TX6_CFG1	0x02BC5234
+#define CS35L41_DSP1_STRMARB_TX7_CFG0	0x02BC5238
+#define CS35L41_DSP1_STRMARB_TX7_CFG1	0x02BC523C
+#define CS35L41_DSP1_STRMARB_RX0_CFG0	0x02BC5400
+#define CS35L41_DSP1_STRMARB_RX0_CFG1	0x02BC5404
+#define CS35L41_DSP1_STRMARB_RX1_CFG0	0x02BC5408
+#define CS35L41_DSP1_STRMARB_RX1_CFG1	0x02BC540C
+#define CS35L41_DSP1_STRMARB_RX2_CFG0	0x02BC5410
+#define CS35L41_DSP1_STRMARB_RX2_CFG1	0x02BC5414
+#define CS35L41_DSP1_STRMARB_RX3_CFG0	0x02BC5418
+#define CS35L41_DSP1_STRMARB_RX3_CFG1	0x02BC541C
+#define CS35L41_DSP1_STRMARB_RX4_CFG0	0x02BC5420
+#define CS35L41_DSP1_STRMARB_RX4_CFG1	0x02BC5424
+#define CS35L41_DSP1_STRMARB_RX5_CFG0	0x02BC5428
+#define CS35L41_DSP1_STRMARB_RX5_CFG1	0x02BC542C
+#define CS35L41_DSP1_STRMARB_RX6_CFG0	0x02BC5430
+#define CS35L41_DSP1_STRMARB_RX6_CFG1	0x02BC5434
+#define CS35L41_DSP1_STRMARB_RX7_CFG0	0x02BC5438
+#define CS35L41_DSP1_STRMARB_RX7_CFG1	0x02BC543C
+#define CS35L41_DSP1_STRMARB_IRQ0_CFG0	0x02BC5600
+#define CS35L41_DSP1_STRMARB_IRQ0_CFG1	0x02BC5604
+#define CS35L41_DSP1_STRMARB_IRQ0_CFG2	0x02BC5608
+#define CS35L41_DSP1_STRMARB_IRQ1_CFG0	0x02BC5610
+#define CS35L41_DSP1_STRMARB_IRQ1_CFG1	0x02BC5614
+#define CS35L41_DSP1_STRMARB_IRQ1_CFG2	0x02BC5618
+#define CS35L41_DSP1_STRMARB_IRQ2_CFG0	0x02BC5620
+#define CS35L41_DSP1_STRMARB_IRQ2_CFG1	0x02BC5624
+#define CS35L41_DSP1_STRMARB_IRQ2_CFG2	0x02BC5628
+#define CS35L41_DSP1_STRMARB_IRQ3_CFG0	0x02BC5630
+#define CS35L41_DSP1_STRMARB_IRQ3_CFG1	0x02BC5634
+#define CS35L41_DSP1_STRMARB_IRQ3_CFG2	0x02BC5638
+#define CS35L41_DSP1_STRMARB_IRQ4_CFG0	0x02BC5640
+#define CS35L41_DSP1_STRMARB_IRQ4_CFG1	0x02BC5644
+#define CS35L41_DSP1_STRMARB_IRQ4_CFG2	0x02BC5648
+#define CS35L41_DSP1_STRMARB_IRQ5_CFG0	0x02BC5650
+#define CS35L41_DSP1_STRMARB_IRQ5_CFG1	0x02BC5654
+#define CS35L41_DSP1_STRMARB_IRQ5_CFG2	0x02BC5658
+#define CS35L41_DSP1_STRMARB_IRQ6_CFG0	0x02BC5660
+#define CS35L41_DSP1_STRMARB_IRQ6_CFG1	0x02BC5664
+#define CS35L41_DSP1_STRMARB_IRQ6_CFG2	0x02BC5668
+#define CS35L41_DSP1_STRMARB_IRQ7_CFG0	0x02BC5670
+#define CS35L41_DSP1_STRMARB_IRQ7_CFG1	0x02BC5674
+#define CS35L41_DSP1_STRMARB_IRQ7_CFG2	0x02BC5678
+#define CS35L41_DSP1_STRMARB_RESYNC_MSK	0x02BC5A00
+#define CS35L41_DSP1_STRMARB_ERR_STATUS	0x02BC5A08
+#define CS35L41_DSP1_INTPCTL_RES_STATIC	0x02BC6000
+#define CS35L41_DSP1_INTPCTL_RES_DYN	0x02BC6004
+#define CS35L41_DSP1_INTPCTL_NMI_CTRL	0x02BC6008
+#define CS35L41_DSP1_INTPCTL_IRQ_INV	0x02BC6010
+#define CS35L41_DSP1_INTPCTL_IRQ_MODE	0x02BC6014
+#define CS35L41_DSP1_INTPCTL_IRQ_EN	0x02BC6018
+#define CS35L41_DSP1_INTPCTL_IRQ_MSK	0x02BC601C
+#define CS35L41_DSP1_INTPCTL_IRQ_FLUSH	0x02BC6020
+#define CS35L41_DSP1_INTPCTL_IRQ_MSKCLR	0x02BC6024
+#define CS35L41_DSP1_INTPCTL_IRQ_FRC	0x02BC6028
+#define CS35L41_DSP1_INTPCTL_IRQ_MSKSET	0x02BC602C
+#define CS35L41_DSP1_INTPCTL_IRQ_ERR	0x02BC6030
+#define CS35L41_DSP1_INTPCTL_IRQ_PEND	0x02BC6034
+#define CS35L41_DSP1_INTPCTL_IRQ_GEN	0x02BC6038
+#define CS35L41_DSP1_INTPCTL_TESTBITS	0x02BC6040
+#define CS35L41_DSP1_WDT_CONTROL	0x02BC7000
+#define CS35L41_DSP1_WDT_STATUS		0x02BC7008
+#define CS35L41_DSP1_YMEM_PACK_0	0x02C00000
+#define CS35L41_DSP1_YMEM_PACK_1532	0x02C017F0
+#define CS35L41_DSP1_YMEM_UNPACK32_0	0x03000000
+#define CS35L41_DSP1_YMEM_UNPACK32_1022	0x03000FF8
+#define CS35L41_DSP1_YMEM_UNPACK24_0	0x03400000
+#define CS35L41_DSP1_YMEM_UNPACK24_2045	0x03401FF4
+#define CS35L41_DSP1_PMEM_0		0x03800000
+#define CS35L41_DSP1_PMEM_5114		0x03804FE8
+
+/*test regs for emulation bringup*/
+#define CS35L41_PLL_OVR			0x00003018
+#define CS35L41_BST_TEST_DUTY		0x00003900
+#define CS35L41_DIGPWM_IOCTRL		0x0000706C
+
+/*registers populated by OTP*/
+#define CS35L41_OTP_TRIM_1	0x0000208c
+#define CS35L41_OTP_TRIM_2	0x00002090
+#define CS35L41_OTP_TRIM_3	0x00003010
+#define CS35L41_OTP_TRIM_4	0x0000300C
+#define CS35L41_OTP_TRIM_5	0x0000394C
+#define CS35L41_OTP_TRIM_6	0x00003950
+#define CS35L41_OTP_TRIM_7	0x00003954
+#define CS35L41_OTP_TRIM_8	0x00003958
+#define CS35L41_OTP_TRIM_9	0x0000395C
+#define CS35L41_OTP_TRIM_10	0x0000416C
+#define CS35L41_OTP_TRIM_11	0x00004160
+#define CS35L41_OTP_TRIM_12	0x00004170
+#define CS35L41_OTP_TRIM_13	0x00004360
+#define CS35L41_OTP_TRIM_14	0x00004448
+#define CS35L41_OTP_TRIM_15	0x0000444C
+#define CS35L41_OTP_TRIM_16	0x00006E30
+#define CS35L41_OTP_TRIM_17	0x00006E34
+#define CS35L41_OTP_TRIM_18	0x00006E38
+#define CS35L41_OTP_TRIM_19	0x00006E3C
+#define CS35L41_OTP_TRIM_20	0x00006E40
+#define CS35L41_OTP_TRIM_21	0x00006E44
+#define CS35L41_OTP_TRIM_22	0x00006E48
+#define CS35L41_OTP_TRIM_23	0x00006E4C
+#define CS35L41_OTP_TRIM_24	0x00006E50
+#define CS35L41_OTP_TRIM_25	0x00006E54
+#define CS35L41_OTP_TRIM_26	0x00006E58
+#define CS35L41_OTP_TRIM_27	0x00006E5C
+#define CS35L41_OTP_TRIM_28	0x00006E60
+#define CS35L41_OTP_TRIM_29	0x00006E64
+#define CS35L41_OTP_TRIM_30	0x00007418
+#define CS35L41_OTP_TRIM_31	0x0000741C
+#define CS35L41_OTP_TRIM_32	0x00007434
+#define CS35L41_OTP_TRIM_33	0x00007068
+#define CS35L41_OTP_TRIM_34	0x0000410C
+#define CS35L41_OTP_TRIM_35	0x0000400C
+#define CS35L41_OTP_TRIM_36	0x00002030
+
+#define CS35L41_MAX_CACHE_REG		0x0000006B
+#define CS35L41_OTP_SIZE_WORDS		32
+#define CS35L41_NUM_OTP_ELEM		100
+#define CS35L41_NUM_OTP_MAPS		5
+
+#define CS35L41_VALID_PDATA		0x80000000
+
+#define CS35L41_SCLK_MSTR_MASK		0x10
+#define CS35L41_SCLK_MSTR_SHIFT		4
+#define CS35L41_LRCLK_MSTR_MASK		0x01
+#define CS35L41_LRCLK_MSTR_SHIFT	0
+#define CS35L41_SCLK_INV_MASK		0x40
+#define CS35L41_SCLK_INV_SHIFT		6
+#define CS35L41_LRCLK_INV_MASK		0x04
+#define CS35L41_LRCLK_INV_SHIFT		2
+#define CS35L41_SCLK_FRC_MASK		0x20
+#define CS35L41_SCLK_FRC_SHIFT		5
+#define CS35L41_LRCLK_FRC_MASK		0x02
+#define CS35L41_LRCLK_FRC_SHIFT		1
+
+#define CS35L41_AMP_GAIN_ZC_MASK	0x0400
+#define CS35L41_AMP_GAIN_ZC_SHIFT	10
+
+#define CS35L41_BST_CTL_MASK		0xFF
+#define CS35L41_BST_CTL_SEL_MASK	0x03
+#define CS35L41_BST_CTL_SEL_REG		0x00
+#define CS35L41_BST_CTL_SEL_CLASSH	0x01
+#define CS35L41_BST_IPK_MASK		0x7F
+#define CS35L41_BST_IPK_SHIFT		0
+#define CS35L41_BST_LIM_MASK		0x4
+#define CS35L41_BST_LIM_SHIFT		2
+#define CS35L41_BST_K1_MASK		0x000000FF
+#define CS35L41_BST_K1_SHIFT		0
+#define CS35L41_BST_K2_MASK		0x0000FF00
+#define CS35L41_BST_K2_SHIFT		8
+#define CS35L41_BST_SLOPE_MASK		0x0000FF00
+#define CS35L41_BST_SLOPE_SHIFT		8
+#define CS35L41_BST_LBST_VAL_MASK	0x00000003
+#define CS35L41_BST_LBST_VAL_SHIFT	0
+
+#define CS35L41_TEMP_THLD_MASK		0x03
+#define CS35L41_VMON_IMON_VOL_MASK	0x07FF07FF
+#define CS35L41_PDM_MODE_MASK		0x01
+#define CS35L41_PDM_MODE_SHIFT		0
+
+#define CS35L41_CH_MEM_DEPTH_MASK	0x07
+#define CS35L41_CH_MEM_DEPTH_SHIFT	0
+#define CS35L41_CH_HDRM_CTL_MASK	0x007F0000
+#define CS35L41_CH_HDRM_CTL_SHIFT	16
+#define CS35L41_CH_REL_RATE_MASK	0xFF00
+#define CS35L41_CH_REL_RATE_SHIFT	8
+#define CS35L41_CH_WKFET_DLY_MASK	0x001C
+#define CS35L41_CH_WKFET_DLY_SHIFT	2
+#define CS35L41_CH_WKFET_THLD_MASK	0x0F00
+#define CS35L41_CH_WKFET_THLD_SHIFT	8
+
+#define CS35L41_HW_NG_SEL_MASK		0x3F00
+#define CS35L41_HW_NG_SEL_SHIFT		8
+#define CS35L41_HW_NG_DLY_MASK		0x0070
+#define CS35L41_HW_NG_DLY_SHIFT		4
+#define CS35L41_HW_NG_THLD_MASK		0x0007
+#define CS35L41_HW_NG_THLD_SHIFT	0
+
+#define CS35L41_DSP_NG_ENABLE_MASK	0x00010000
+#define CS35L41_DSP_NG_ENABLE_SHIFT	16
+#define CS35L41_DSP_NG_THLD_MASK	0x7
+#define CS35L41_DSP_NG_THLD_SHIFT	0
+#define CS35L41_DSP_NG_DELAY_MASK	0x0F00
+#define CS35L41_DSP_NG_DELAY_SHIFT	8
+
+#define CS35L41_ASP_FMT_MASK		0x0700
+#define CS35L41_ASP_FMT_SHIFT		8
+#define CS35L41_ASP_DOUT_HIZ_MASK	0x03
+#define CS35L41_ASP_DOUT_HIZ_SHIFT	0
+#define CS35L41_ASP_WIDTH_16		0x10
+#define CS35L41_ASP_WIDTH_24		0x18
+#define CS35L41_ASP_WIDTH_32		0x20
+#define CS35L41_ASP_WIDTH_TX_MASK	0xFF0000
+#define CS35L41_ASP_WIDTH_TX_SHIFT	16
+#define CS35L41_ASP_WIDTH_RX_MASK	0xFF000000
+#define CS35L41_ASP_WIDTH_RX_SHIFT	24
+#define CS35L41_ASP_RX1_SLOT_MASK	0x3F
+#define CS35L41_ASP_RX1_SLOT_SHIFT	0
+#define CS35L41_ASP_RX2_SLOT_MASK	0x3F00
+#define CS35L41_ASP_RX2_SLOT_SHIFT	8
+#define CS35L41_ASP_RX_WL_MASK		0x3F
+#define CS35L41_ASP_TX_WL_MASK		0x3F
+#define CS35L41_ASP_RX_WL_SHIFT		0
+#define CS35L41_ASP_TX_WL_SHIFT		0
+#define CS35L41_ASP_SOURCE_MASK		0x7F
+
+#define CS35L41_INPUT_SRC_ASPRX1	0x08
+#define CS35L41_INPUT_SRC_ASPRX2	0x09
+#define CS35L41_INPUT_SRC_VMON		0x18
+#define CS35L41_INPUT_SRC_IMON		0x19
+#define CS35L41_INPUT_SRC_CLASSH	0x21
+#define CS35L41_INPUT_SRC_VPMON		0x28
+#define CS35L41_INPUT_SRC_VBSTMON	0x29
+#define CS35L41_INPUT_SRC_TEMPMON	0x3A
+#define CS35L41_INPUT_SRC_RSVD		0x3B
+#define CS35L41_INPUT_DSP_TX1		0x32
+#define CS35L41_INPUT_DSP_TX2		0x33
+
+#define CS35L41_PLL_CLK_SEL_MASK	0x07
+#define CS35L41_PLL_CLK_SEL_SHIFT	0
+#define CS35L41_PLL_CLK_EN_MASK		0x10
+#define CS35L41_PLL_CLK_EN_SHIFT	4
+#define CS35L41_PLL_OPENLOOP_MASK	0x0800
+#define CS35L41_PLL_OPENLOOP_SHIFT	11
+#define CS35L41_PLL_FORCE_EN_MASK	0x10000
+#define CS35L41_PLL_FORCE_EN_SHIFT	16
+#define CS35L41_PLLSRC_SCLK		0
+#define CS35L41_PLLSRC_LRCLK		1
+#define CS35L41_PLLSRC_SELF		3
+#define CS35L41_PLLSRC_PDMCLK		4
+#define CS35L41_PLLSRC_MCLK		5
+#define CS35L41_PLLSRC_SWIRE		7
+#define CS35L41_REFCLK_FREQ_MASK	0x7E0
+#define CS35L41_REFCLK_FREQ_SHIFT	5
+
+#define CS35L41_GLOBAL_FS_MASK		0x1F
+#define CS35L41_GLOBAL_FS_SHIFT		0
+
+#define CS35L41_GLOBAL_EN_MASK		0x01
+#define CS35L41_GLOBAL_EN_SHIFT		0
+#define CS35L41_BST_EN_MASK		0x0030
+#define CS35L41_BST_EN_SHIFT		4
+#define CS35L41_BST_EN_DEFAULT		0x2
+
+#define CS35L41_PDN_DONE_MASK		0x00800000
+#define CS35L41_PDN_DONE_SHIFT		23
+#define CS35L41_PUP_DONE_MASK		0x01000000
+#define CS35L41_PUP_DONE_SHIFT		24
+
+#define CS35L36_PUP_DONE_IRQ_UNMASK	0x5F
+#define CS35L36_PUP_DONE_IRQ_MASK	0xBF
+
+#define CS35L41_SYNC_EN_MASK		(1 << 8)
+
+#define CS35L41_AMP_SHORT_ERR		0x80000000
+#define CS35L41_BST_SHORT_ERR		0x0100
+#define CS35L41_TEMP_WARN		0x8000
+#define CS35L41_TEMP_ERR		0x00020000
+#define CS35L41_BST_OVP_ERR		0x40
+#define CS35L41_BST_DCM_UVP_ERR		0x80
+#define CS35L41_OTP_BOOT_DONE		0x02
+#define CS35L41_PLL_UNLOCK		0x10
+#define CS35L41_PLL_LOCK		0x02
+#define CS35L41_OTP_BOOT_ERR		0x80000000
+
+#define CS35L41_AMP_SHORT_ERR_RLS	0x02
+#define CS35L41_BST_SHORT_ERR_RLS	0x04
+#define CS35L41_BST_OVP_ERR_RLS		0x08
+#define CS35L41_BST_UVP_ERR_RLS		0x10
+#define CS35L41_TEMP_WARN_ERR_RLS	0x20
+#define CS35L41_TEMP_ERR_RLS		0x40
+
+#define CS35L41_INT1_MASK_DEFAULT	0x7FFCFE3F
+#define CS35L41_INT1_UNMASK_PUP		0xFEFFFFFF
+#define CS35L41_INT1_UNMASK_PDN		0xFF7FFFFF
+#define CS35L41_INT1_MASK_FORCE		0xFFFFFFFE
+#define CS35L41_INT3_MASK_DEFAULT	0xFFFF87FF
+#define CS35L41_INT3_UNMASK_PLL_LOCK	0xFFFF87FD
+
+#define CS35L41_INT2_VIRT2_MBOX_WR	0x00200000
 
-#include "wm_adsp.h"
+#define CS35L41_GPIO_DIR_MASK		0x80000000
+#define CS35L41_GPIO1_CTRL_MASK		0x00030000
+#define CS35L41_GPIO1_CTRL_SHIFT	16
+#define CS35L41_GPIO2_CTRL_MASK		0x07000000
+#define CS35L41_GPIO2_CTRL_SHIFT	24
+#define CS35L41_GPIO_CTRL_ACTV_LO	4
+#define CS35L41_GPIO_CTRL_ACTV_HI	5
+#define CS35L41_GPIO_POL_MASK		0x1000
+#define CS35L41_GPIO_POL_SHIFT		12
+
+#define CS35L41_AMP_INV_PCM_SHIFT	14
+#define CS35L41_AMP_INV_PCM_MASK	(1 << CS35L41_AMP_INV_PCM_SHIFT)
+#define CS35L41_AMP_PCM_VOL_SHIFT	3
+#define CS35L41_AMP_PCM_VOL_MASK	(0x7FF << 3)
+#define CS35L41_AMP_PCM_VOL_MUTE	0x4CF
+
+#define CS35L41_CHIP_ID			0x35a40
+#define CS35L41R_CHIP_ID		0x35b40
+#define CS35L41_MTLREVID_MASK		0x0F
+#define CS35L41_REVID_A0		0xA0
+#define CS35L41_REVID_B0		0xB0
+#define CS35L41_REVID_B2		0xB2
+
+#define CS35L41_HALO_CORE_RESET		0x00000200
+
+#define CS35L41_FS1_WINDOW_MASK		0x000007FF
+#define CS35L41_FS2_WINDOW_MASK		0x00FFF800
+#define CS35L41_FS2_WINDOW_SHIFT	12
+
+#define CS35L41_SPI_MAX_FREQ		4000000
 
 #define CS35L41_RX_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)
-#define CS35L41_TX_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE)
+#define CS35L41_TX_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S24_LE \
+				| SNDRV_PCM_FMTBIT_S32_LE)
+
+#define CS35L41_MAX_AUTO_RAMP_TIMEOUT	65535
+#define CS35L41_MAX_PCM_VOL		913
+#define CS35L41_MAX_VOL_ATT		120
+#define CS35L41_ZERO_PCM_VOL		817
+#define CS35L41_OUTPUT_DEV_SPK		0
+#define CS35L41_OUTPUT_DEV_RCV		1
+
+#define CS35L41_MBOX3_CMD_MASK		0xFF
+#define CS35L41_MBOX3_CMD_SHIFT		0
+#define CS35L41_MBOX3_DATA_MASK		0xFFFFFF00
+#define CS35L41_MBOX3_DATA_SHIFT	8
 
-extern const struct dev_pm_ops cs35l41_pm_ops;
+bool cs35l41_readable_reg(struct device *dev, unsigned int reg);
+bool cs35l41_precious_reg(struct device *dev, unsigned int reg);
+bool cs35l41_volatile_reg(struct device *dev, unsigned int reg);
 
-struct cs35l41_private {
-	struct wm_adsp dsp; /* needs to be first member */
-	struct snd_soc_codec *codec;
-	struct cs35l41_hw_cfg hw_cfg;
-	struct device *dev;
-	struct regmap *regmap;
-	struct regulator_bulk_data supplies[CS35L41_NUM_SUPPLIES];
-	int irq;
-	/* GPIO for /RST */
-	struct gpio_desc *reset_gpio;
+struct cs35l41_otp_packed_element_t {
+	u32 reg;
+	u8 shift;
+	u8 size;
 };
 
-int cs35l41_probe(struct cs35l41_private *cs35l41, const struct cs35l41_hw_cfg *hw_cfg);
-void cs35l41_remove(struct cs35l41_private *cs35l41);
+struct cs35l41_otp_map_element_t {
+	u32 id;
+	u32 num_elements;
+	const struct cs35l41_otp_packed_element_t *map;
+	u32 bit_offset;
+	u32 word_offset;
+};
+
+struct cs35l41_otp_trim_region_t {
+	u32 reg;
+	u8 size;
+};
+
+extern const struct reg_default cs35l41_reg[CS35L41_MAX_CACHE_REG];
+extern const struct cs35l41_otp_map_element_t
+				cs35l41_otp_map_map[CS35L41_NUM_OTP_MAPS];
+
+#define CS35L41_REGSTRIDE			4
+#define CS35L41_BUFSIZE				64
+
+#define CS35L41_DSP_VIRT1_MBOX_SHIFT		20
+#define CS35L41_DSP_VIRT2_MBOX_SHIFT		21
+#define CS35L41_CSPL_MBOX_STS			CS35L41_DSP_MBOX_2
+/* Firmware update following reg */
+#define CS35L41_CSPL_MBOX_CMD_FW		CS35L41_DSP_VIRT2_MBOX_1
+#define CS35L41_CSPL_MBOX_CMD_FW_SHIFT		CS35L41_DSP_VIRT2_MBOX_SHIFT
+/* Driver update following reg */
+#define CS35L41_CSPL_MBOX_CMD_DRV		CS35L41_DSP_VIRT1_MBOX_1
+#define CS35L41_CSPL_MBOX_CMD_DRV_SHIFT		CS35L41_DSP_VIRT1_MBOX_SHIFT
+
+#define CS35L41_CTRL_CACHE_SIZE 15
+#define CS35L41_TRIM_CACHE_REGIONS 18
+#define CS35L41_TRIM_CACHE_SIZE 38
+
+extern const unsigned int cs35l41_ctl_cache_regs[CS35L41_CTRL_CACHE_SIZE];
+extern const struct cs35l41_otp_trim_region_t
+			cs35l41_trim_cache_regs[CS35L41_TRIM_CACHE_REGIONS];
+
+enum cs35l41_cspl_mbox_status {
+	CSPL_MBOX_STS_RUNNING = 0,
+	CSPL_MBOX_STS_PAUSED = 1,
+	CSPL_MBOX_STS_RDY_FOR_REINIT = 2,
+	CSPL_MBOX_STS_HIBERNATE = 3,
+};
+
+enum cs35l41_cspl_mbox_cmd {
+	CSPL_MBOX_CMD_NONE = 0,
+	CSPL_MBOX_CMD_PAUSE = 1,
+	CSPL_MBOX_CMD_RESUME = 2,
+	CSPL_MBOX_CMD_REINIT = 3,
+	CSPL_MBOX_CMD_STOP_PRE_REINIT = 4,
+	CSPL_MBOX_CMD_HIBERNATE = 5,
+	CSPL_MBOX_CMD_OUT_OF_HIBERNATE = 6,
+	CSPL_MBOX_CMD_UNKNOWN_CMD = -1,
+	CSPL_MBOX_CMD_INVALID_SEQUENCE = -2,
+};
+
+enum cs35l41_cspl_cmd {
+	CSPL_CMD_NONE			= 0,
+	CSPL_CMD_MUTE			= 1,
+	CSPL_CMD_UNMUTE			= 2,
+	CSPL_CMD_UPDATE_PARAM		= 8,
+};
+
+enum cs35l41_cspl_st {
+	CSPL_ST_RUNNING			= 0,
+	CSPL_ST_ERROR			= 1,
+	CSPL_ST_MUTED			= 2,
+	CSPL_ST_REINITING		= 3,
+	CSPL_ST_DIAGNOSING		= 6,
+};
+
+enum cs35l41_hibernate_state {
+	CS35L41_HIBERNATE_AWAKE		= 0,
+	CS35L41_HIBERNATE_STANDBY	= 1,
+	CS35L41_HIBERNATE_NOT_LOADED	= 2,
+	CS35L41_HIBERNATE_INCOMPATIBLE	= 3,
+};
+
+enum cs35l41_shared_boost {
+	SHARED_BOOST_DISABLED,
+	SHARED_BOOST_ACTIVE,
+	SHARED_BOOST_PASSIVE,
+};
 
 #endif /*__CS35L41_H__*/
diff -ruN a/sound/soc/codecs/cs35l41-i2c.c b/sound/soc/codecs/cs35l41-i2c.c
--- a/sound/soc/codecs/cs35l41-i2c.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/codecs/cs35l41-i2c.c	2022-07-08 01:12:12.000000000 +0200
@@ -1,74 +1,110 @@
 // SPDX-License-Identifier: GPL-2.0
-//
-// cs35l41-i2c.c -- CS35l41 I2C driver
-//
-// Copyright 2017-2021 Cirrus Logic, Inc.
-//
-// Author: David Rhodes <david.rhodes@cirrus.com>
 
-#include <linux/acpi.h>
-#include <linux/delay.h>
-#include <linux/i2c.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
+/*
+ * cs35l41-i2c.c -- CS35l41 I2C driver
+ *
+ * Copyright 2017-2020 Cirrus Logic, Inc.
+ *
+ * Author:	David Rhodes	<david.rhodes@cirrus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
 #include <linux/module.h>
 #include <linux/moduleparam.h>
-#include <linux/of_device.h>
-#include <linux/platform_device.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
 #include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/gpio/consumer.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/regmap.h>
+#include <linux/gpio.h>
+#include <linux/acpi.h>
 
+#include "wm_adsp.h"
 #include "cs35l41.h"
+#include <sound/cs35l41.h>
+
+static struct regmap_config cs35l41_regmap_i2c = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.reg_stride = 4,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_BIG,
+	.max_register = CS35L41_LASTREG,
+	.reg_defaults = cs35l41_reg,
+	.num_reg_defaults = ARRAY_SIZE(cs35l41_reg),
+	.volatile_reg = cs35l41_volatile_reg,
+	.readable_reg = cs35l41_readable_reg,
+	.precious_reg = cs35l41_precious_reg,
+	.cache_type = REGCACHE_RBTREE,
+};
 
 static const struct i2c_device_id cs35l41_id_i2c[] = {
-	{ "cs35l40", 0 },
-	{ "cs35l41", 0 },
-	{ "cs35l51", 0 },
-	{ "cs35l53", 0 },
+	{"cs35l40", 0},
+	{"cs35l41", 0},
 	{}
 };
 
 MODULE_DEVICE_TABLE(i2c, cs35l41_id_i2c);
 
-static int cs35l41_i2c_probe(struct i2c_client *client)
+static int cs35l41_i2c_probe(struct i2c_client *client,
+				const struct i2c_device_id *id)
 {
 	struct cs35l41_private *cs35l41;
 	struct device *dev = &client->dev;
-	struct cs35l41_hw_cfg *hw_cfg = dev_get_platdata(dev);
+	struct cs35l41_platform_data *pdata = dev_get_platdata(dev);
 	const struct regmap_config *regmap_config = &cs35l41_regmap_i2c;
 	int ret;
 
 	cs35l41 = devm_kzalloc(dev, sizeof(struct cs35l41_private), GFP_KERNEL);
 
-	if (!cs35l41)
+	if (cs35l41 == NULL)
 		return -ENOMEM;
 
 	cs35l41->dev = dev;
 	cs35l41->irq = client->irq;
+	cs35l41->bus_spi = false;
 
 	i2c_set_clientdata(client, cs35l41);
 	cs35l41->regmap = devm_regmap_init_i2c(client, regmap_config);
 	if (IS_ERR(cs35l41->regmap)) {
 		ret = PTR_ERR(cs35l41->regmap);
-		dev_err(cs35l41->dev, "Failed to allocate register map: %d\n", ret);
+		dev_err(cs35l41->dev, "Failed to allocate register map: %d\n",
+			ret);
 		return ret;
 	}
-
-	return cs35l41_probe(cs35l41, hw_cfg);
+	ret = cs35l41_probe(cs35l41, pdata);
+	if ((ret != 0 ) && (ret != -ENODEV) && (ret != -ENOMEM)) {
+		dev_err(dev, "I2C bus IO error. Try to defer probe\n");
+		ret = -EPROBE_DEFER;
+	}
+	return ret;
 }
 
 static int cs35l41_i2c_remove(struct i2c_client *client)
 {
 	struct cs35l41_private *cs35l41 = i2c_get_clientdata(client);
 
 	cs35l41_remove(cs35l41);
 
 	return 0;
 }
 
 #ifdef CONFIG_OF
 static const struct of_device_id cs35l41_of_match[] = {
-	{ .compatible = "cirrus,cs35l40" },
-	{ .compatible = "cirrus,cs35l41" },
+	{.compatible = "cirrus,cs35l40"},
+	{.compatible = "cirrus,cs35l41"},
 	{},
 };
 MODULE_DEVICE_TABLE(of, cs35l41_of_match);
@@ -76,7 +110,7 @@
 
 #ifdef CONFIG_ACPI
 static const struct acpi_device_id cs35l41_acpi_match[] = {
-	{ "CSC3541", 0 }, /* Cirrus Logic PnP ID + part ID */
+	{ "CLSA3541", 0 },
 	{},
 };
 MODULE_DEVICE_TABLE(acpi, cs35l41_acpi_match);
@@ -85,12 +119,11 @@
 static struct i2c_driver cs35l41_i2c_driver = {
 	.driver = {
 		.name		= "cs35l41",
-		.pm		= &cs35l41_pm_ops,
 		.of_match_table = of_match_ptr(cs35l41_of_match),
 		.acpi_match_table = ACPI_PTR(cs35l41_acpi_match),
 	},
 	.id_table	= cs35l41_id_i2c,
-	.probe_new	= cs35l41_i2c_probe,
+	.probe		= cs35l41_i2c_probe,
 	.remove		= cs35l41_i2c_remove,
 };
 
diff -ruN a/sound/soc/codecs/cs35l41-lib.c b/sound/soc/codecs/cs35l41-lib.c
--- a/sound/soc/codecs/cs35l41-lib.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/codecs/cs35l41-lib.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,1413 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-//
-// cs35l41-lib.c -- CS35L41 Common functions for HDA and ASoC Audio drivers
-//
-// Copyright 2017-2021 Cirrus Logic, Inc.
-//
-// Author: David Rhodes <david.rhodes@cirrus.com>
-// Author: Lucas Tanure <lucas.tanure@cirrus.com>
-
-#include <linux/dev_printk.h>
-#include <linux/module.h>
-#include <linux/regmap.h>
-#include <linux/regulator/consumer.h>
-#include <linux/slab.h>
-#include <linux/firmware/cirrus/wmfw.h>
-
-#include <sound/cs35l41.h>
-
-static const struct reg_default cs35l41_reg[] = {
-	{ CS35L41_PWR_CTRL1,			0x00000000 },
-	{ CS35L41_PWR_CTRL2,			0x00000000 },
-	{ CS35L41_PWR_CTRL3,			0x01000010 },
-	{ CS35L41_GPIO_PAD_CONTROL,		0x00000000 },
-	{ CS35L41_GLOBAL_CLK_CTRL,		0x00000003 },
-	{ CS35L41_TST_FS_MON0,			0x00020016 },
-	{ CS35L41_BSTCVRT_COEFF,		0x00002424 },
-	{ CS35L41_BSTCVRT_SLOPE_LBST,		0x00007500 },
-	{ CS35L41_BSTCVRT_PEAK_CUR,		0x0000004A },
-	{ CS35L41_SP_ENABLES,			0x00000000 },
-	{ CS35L41_SP_RATE_CTRL,			0x00000028 },
-	{ CS35L41_SP_FORMAT,			0x18180200 },
-	{ CS35L41_SP_HIZ_CTRL,			0x00000002 },
-	{ CS35L41_SP_FRAME_TX_SLOT,		0x03020100 },
-	{ CS35L41_SP_FRAME_RX_SLOT,		0x00000100 },
-	{ CS35L41_SP_TX_WL,			0x00000018 },
-	{ CS35L41_SP_RX_WL,			0x00000018 },
-	{ CS35L41_DAC_PCM1_SRC,			0x00000008 },
-	{ CS35L41_ASP_TX1_SRC,			0x00000018 },
-	{ CS35L41_ASP_TX2_SRC,			0x00000019 },
-	{ CS35L41_ASP_TX3_SRC,			0x00000000 },
-	{ CS35L41_ASP_TX4_SRC,			0x00000000 },
-	{ CS35L41_DSP1_RX1_SRC,			0x00000008 },
-	{ CS35L41_DSP1_RX2_SRC,			0x00000009 },
-	{ CS35L41_DSP1_RX3_SRC,			0x00000018 },
-	{ CS35L41_DSP1_RX4_SRC,			0x00000019 },
-	{ CS35L41_DSP1_RX5_SRC,			0x00000020 },
-	{ CS35L41_DSP1_RX6_SRC,			0x00000021 },
-	{ CS35L41_DSP1_RX7_SRC,			0x0000003A },
-	{ CS35L41_DSP1_RX8_SRC,			0x00000001 },
-	{ CS35L41_NGATE1_SRC,			0x00000008 },
-	{ CS35L41_NGATE2_SRC,			0x00000009 },
-	{ CS35L41_AMP_DIG_VOL_CTRL,		0x00008000 },
-	{ CS35L41_CLASSH_CFG,			0x000B0405 },
-	{ CS35L41_WKFET_CFG,			0x00000111 },
-	{ CS35L41_NG_CFG,			0x00000033 },
-	{ CS35L41_AMP_GAIN_CTRL,		0x00000000 },
-	{ CS35L41_IRQ1_MASK1,			0xFFFFFFFF },
-	{ CS35L41_IRQ1_MASK2,			0xFFFFFFFF },
-	{ CS35L41_IRQ1_MASK3,			0xFFFF87FF },
-	{ CS35L41_IRQ1_MASK4,			0xFEFFFFFF },
-	{ CS35L41_GPIO1_CTRL1,			0xE1000001 },
-	{ CS35L41_GPIO2_CTRL1,			0xE1000001 },
-	{ CS35L41_MIXER_NGATE_CFG,		0x00000000 },
-	{ CS35L41_MIXER_NGATE_CH1_CFG,		0x00000303 },
-	{ CS35L41_MIXER_NGATE_CH2_CFG,		0x00000303 },
-	{ CS35L41_DSP1_CCM_CORE_CTRL,		0x00000101 },
-};
-
-static bool cs35l41_readable_reg(struct device *dev, unsigned int reg)
-{
-	switch (reg) {
-	case CS35L41_DEVID:
-	case CS35L41_REVID:
-	case CS35L41_FABID:
-	case CS35L41_RELID:
-	case CS35L41_OTPID:
-	case CS35L41_TEST_KEY_CTL:
-	case CS35L41_USER_KEY_CTL:
-	case CS35L41_OTP_CTRL0:
-	case CS35L41_OTP_CTRL3:
-	case CS35L41_OTP_CTRL4:
-	case CS35L41_OTP_CTRL5:
-	case CS35L41_OTP_CTRL6:
-	case CS35L41_OTP_CTRL7:
-	case CS35L41_OTP_CTRL8:
-	case CS35L41_PWR_CTRL1:
-	case CS35L41_PWR_CTRL2:
-	case CS35L41_PWR_CTRL3:
-	case CS35L41_CTRL_OVRRIDE:
-	case CS35L41_AMP_OUT_MUTE:
-	case CS35L41_PROTECT_REL_ERR_IGN:
-	case CS35L41_GPIO_PAD_CONTROL:
-	case CS35L41_JTAG_CONTROL:
-	case CS35L41_PWRMGT_CTL:
-	case CS35L41_WAKESRC_CTL:
-	case CS35L41_PWRMGT_STS:
-	case CS35L41_PLL_CLK_CTRL:
-	case CS35L41_DSP_CLK_CTRL:
-	case CS35L41_GLOBAL_CLK_CTRL:
-	case CS35L41_DATA_FS_SEL:
-	case CS35L41_TST_FS_MON0:
-	case CS35L41_MDSYNC_EN:
-	case CS35L41_MDSYNC_TX_ID:
-	case CS35L41_MDSYNC_PWR_CTRL:
-	case CS35L41_MDSYNC_DATA_TX:
-	case CS35L41_MDSYNC_TX_STATUS:
-	case CS35L41_MDSYNC_DATA_RX:
-	case CS35L41_MDSYNC_RX_STATUS:
-	case CS35L41_MDSYNC_ERR_STATUS:
-	case CS35L41_MDSYNC_SYNC_PTE2:
-	case CS35L41_MDSYNC_SYNC_PTE3:
-	case CS35L41_MDSYNC_SYNC_MSM_STATUS:
-	case CS35L41_BSTCVRT_VCTRL1:
-	case CS35L41_BSTCVRT_VCTRL2:
-	case CS35L41_BSTCVRT_PEAK_CUR:
-	case CS35L41_BSTCVRT_SFT_RAMP:
-	case CS35L41_BSTCVRT_COEFF:
-	case CS35L41_BSTCVRT_SLOPE_LBST:
-	case CS35L41_BSTCVRT_SW_FREQ:
-	case CS35L41_BSTCVRT_DCM_CTRL:
-	case CS35L41_BSTCVRT_DCM_MODE_FORCE:
-	case CS35L41_BSTCVRT_OVERVOLT_CTRL:
-	case CS35L41_VI_VOL_POL:
-	case CS35L41_DTEMP_WARN_THLD:
-	case CS35L41_DTEMP_CFG:
-	case CS35L41_DTEMP_EN:
-	case CS35L41_VPVBST_FS_SEL:
-	case CS35L41_SP_ENABLES:
-	case CS35L41_SP_RATE_CTRL:
-	case CS35L41_SP_FORMAT:
-	case CS35L41_SP_HIZ_CTRL:
-	case CS35L41_SP_FRAME_TX_SLOT:
-	case CS35L41_SP_FRAME_RX_SLOT:
-	case CS35L41_SP_TX_WL:
-	case CS35L41_SP_RX_WL:
-	case CS35L41_DAC_PCM1_SRC:
-	case CS35L41_ASP_TX1_SRC:
-	case CS35L41_ASP_TX2_SRC:
-	case CS35L41_ASP_TX3_SRC:
-	case CS35L41_ASP_TX4_SRC:
-	case CS35L41_DSP1_RX1_SRC:
-	case CS35L41_DSP1_RX2_SRC:
-	case CS35L41_DSP1_RX3_SRC:
-	case CS35L41_DSP1_RX4_SRC:
-	case CS35L41_DSP1_RX5_SRC:
-	case CS35L41_DSP1_RX6_SRC:
-	case CS35L41_DSP1_RX7_SRC:
-	case CS35L41_DSP1_RX8_SRC:
-	case CS35L41_NGATE1_SRC:
-	case CS35L41_NGATE2_SRC:
-	case CS35L41_AMP_DIG_VOL_CTRL:
-	case CS35L41_VPBR_CFG:
-	case CS35L41_VBBR_CFG:
-	case CS35L41_VPBR_STATUS:
-	case CS35L41_VBBR_STATUS:
-	case CS35L41_OVERTEMP_CFG:
-	case CS35L41_AMP_ERR_VOL:
-	case CS35L41_VOL_STATUS_TO_DSP:
-	case CS35L41_CLASSH_CFG:
-	case CS35L41_WKFET_CFG:
-	case CS35L41_NG_CFG:
-	case CS35L41_AMP_GAIN_CTRL:
-	case CS35L41_DAC_MSM_CFG:
-	case CS35L41_IRQ1_CFG:
-	case CS35L41_IRQ1_STATUS:
-	case CS35L41_IRQ1_STATUS1:
-	case CS35L41_IRQ1_STATUS2:
-	case CS35L41_IRQ1_STATUS3:
-	case CS35L41_IRQ1_STATUS4:
-	case CS35L41_IRQ1_RAW_STATUS1:
-	case CS35L41_IRQ1_RAW_STATUS2:
-	case CS35L41_IRQ1_RAW_STATUS3:
-	case CS35L41_IRQ1_RAW_STATUS4:
-	case CS35L41_IRQ1_MASK1:
-	case CS35L41_IRQ1_MASK2:
-	case CS35L41_IRQ1_MASK3:
-	case CS35L41_IRQ1_MASK4:
-	case CS35L41_IRQ1_FRC1:
-	case CS35L41_IRQ1_FRC2:
-	case CS35L41_IRQ1_FRC3:
-	case CS35L41_IRQ1_FRC4:
-	case CS35L41_IRQ1_EDGE1:
-	case CS35L41_IRQ1_EDGE4:
-	case CS35L41_IRQ1_POL1:
-	case CS35L41_IRQ1_POL2:
-	case CS35L41_IRQ1_POL3:
-	case CS35L41_IRQ1_POL4:
-	case CS35L41_IRQ1_DB3:
-	case CS35L41_IRQ2_CFG:
-	case CS35L41_IRQ2_STATUS:
-	case CS35L41_IRQ2_STATUS1:
-	case CS35L41_IRQ2_STATUS2:
-	case CS35L41_IRQ2_STATUS3:
-	case CS35L41_IRQ2_STATUS4:
-	case CS35L41_IRQ2_RAW_STATUS1:
-	case CS35L41_IRQ2_RAW_STATUS2:
-	case CS35L41_IRQ2_RAW_STATUS3:
-	case CS35L41_IRQ2_RAW_STATUS4:
-	case CS35L41_IRQ2_MASK1:
-	case CS35L41_IRQ2_MASK2:
-	case CS35L41_IRQ2_MASK3:
-	case CS35L41_IRQ2_MASK4:
-	case CS35L41_IRQ2_FRC1:
-	case CS35L41_IRQ2_FRC2:
-	case CS35L41_IRQ2_FRC3:
-	case CS35L41_IRQ2_FRC4:
-	case CS35L41_IRQ2_EDGE1:
-	case CS35L41_IRQ2_EDGE4:
-	case CS35L41_IRQ2_POL1:
-	case CS35L41_IRQ2_POL2:
-	case CS35L41_IRQ2_POL3:
-	case CS35L41_IRQ2_POL4:
-	case CS35L41_IRQ2_DB3:
-	case CS35L41_GPIO_STATUS1:
-	case CS35L41_GPIO1_CTRL1:
-	case CS35L41_GPIO2_CTRL1:
-	case CS35L41_MIXER_NGATE_CFG:
-	case CS35L41_MIXER_NGATE_CH1_CFG:
-	case CS35L41_MIXER_NGATE_CH2_CFG:
-	case CS35L41_DSP_MBOX_1 ... CS35L41_DSP_VIRT2_MBOX_8:
-	case CS35L41_CLOCK_DETECT_1:
-	case CS35L41_DIE_STS1:
-	case CS35L41_DIE_STS2:
-	case CS35L41_TEMP_CAL1:
-	case CS35L41_TEMP_CAL2:
-	case CS35L41_DSP1_TIMESTAMP_COUNT:
-	case CS35L41_DSP1_SYS_ID:
-	case CS35L41_DSP1_SYS_VERSION:
-	case CS35L41_DSP1_SYS_CORE_ID:
-	case CS35L41_DSP1_SYS_AHB_ADDR:
-	case CS35L41_DSP1_SYS_XSRAM_SIZE:
-	case CS35L41_DSP1_SYS_YSRAM_SIZE:
-	case CS35L41_DSP1_SYS_PSRAM_SIZE:
-	case CS35L41_DSP1_SYS_PM_BOOT_SIZE:
-	case CS35L41_DSP1_SYS_FEATURES:
-	case CS35L41_DSP1_SYS_FIR_FILTERS:
-	case CS35L41_DSP1_SYS_LMS_FILTERS:
-	case CS35L41_DSP1_SYS_XM_BANK_SIZE:
-	case CS35L41_DSP1_SYS_YM_BANK_SIZE:
-	case CS35L41_DSP1_SYS_PM_BANK_SIZE:
-	case CS35L41_DSP1_RX1_RATE:
-	case CS35L41_DSP1_RX2_RATE:
-	case CS35L41_DSP1_RX3_RATE:
-	case CS35L41_DSP1_RX4_RATE:
-	case CS35L41_DSP1_RX5_RATE:
-	case CS35L41_DSP1_RX6_RATE:
-	case CS35L41_DSP1_RX7_RATE:
-	case CS35L41_DSP1_RX8_RATE:
-	case CS35L41_DSP1_TX1_RATE:
-	case CS35L41_DSP1_TX2_RATE:
-	case CS35L41_DSP1_TX3_RATE:
-	case CS35L41_DSP1_TX4_RATE:
-	case CS35L41_DSP1_TX5_RATE:
-	case CS35L41_DSP1_TX6_RATE:
-	case CS35L41_DSP1_TX7_RATE:
-	case CS35L41_DSP1_TX8_RATE:
-	case CS35L41_DSP1_SCRATCH1:
-	case CS35L41_DSP1_SCRATCH2:
-	case CS35L41_DSP1_SCRATCH3:
-	case CS35L41_DSP1_SCRATCH4:
-	case CS35L41_DSP1_CCM_CORE_CTRL:
-	case CS35L41_DSP1_CCM_CLK_OVERRIDE:
-	case CS35L41_DSP1_XM_MSTR_EN:
-	case CS35L41_DSP1_XM_CORE_PRI:
-	case CS35L41_DSP1_XM_AHB_PACK_PL_PRI:
-	case CS35L41_DSP1_XM_AHB_UP_PL_PRI:
-	case CS35L41_DSP1_XM_ACCEL_PL0_PRI:
-	case CS35L41_DSP1_XM_NPL0_PRI:
-	case CS35L41_DSP1_YM_MSTR_EN:
-	case CS35L41_DSP1_YM_CORE_PRI:
-	case CS35L41_DSP1_YM_AHB_PACK_PL_PRI:
-	case CS35L41_DSP1_YM_AHB_UP_PL_PRI:
-	case CS35L41_DSP1_YM_ACCEL_PL0_PRI:
-	case CS35L41_DSP1_YM_NPL0_PRI:
-	case CS35L41_DSP1_MPU_XM_ACCESS0:
-	case CS35L41_DSP1_MPU_YM_ACCESS0:
-	case CS35L41_DSP1_MPU_WNDW_ACCESS0:
-	case CS35L41_DSP1_MPU_XREG_ACCESS0:
-	case CS35L41_DSP1_MPU_YREG_ACCESS0:
-	case CS35L41_DSP1_MPU_XM_ACCESS1:
-	case CS35L41_DSP1_MPU_YM_ACCESS1:
-	case CS35L41_DSP1_MPU_WNDW_ACCESS1:
-	case CS35L41_DSP1_MPU_XREG_ACCESS1:
-	case CS35L41_DSP1_MPU_YREG_ACCESS1:
-	case CS35L41_DSP1_MPU_XM_ACCESS2:
-	case CS35L41_DSP1_MPU_YM_ACCESS2:
-	case CS35L41_DSP1_MPU_WNDW_ACCESS2:
-	case CS35L41_DSP1_MPU_XREG_ACCESS2:
-	case CS35L41_DSP1_MPU_YREG_ACCESS2:
-	case CS35L41_DSP1_MPU_XM_ACCESS3:
-	case CS35L41_DSP1_MPU_YM_ACCESS3:
-	case CS35L41_DSP1_MPU_WNDW_ACCESS3:
-	case CS35L41_DSP1_MPU_XREG_ACCESS3:
-	case CS35L41_DSP1_MPU_YREG_ACCESS3:
-	case CS35L41_DSP1_MPU_XM_VIO_ADDR:
-	case CS35L41_DSP1_MPU_XM_VIO_STATUS:
-	case CS35L41_DSP1_MPU_YM_VIO_ADDR:
-	case CS35L41_DSP1_MPU_YM_VIO_STATUS:
-	case CS35L41_DSP1_MPU_PM_VIO_ADDR:
-	case CS35L41_DSP1_MPU_PM_VIO_STATUS:
-	case CS35L41_DSP1_MPU_LOCK_CONFIG:
-	case CS35L41_DSP1_MPU_WDT_RST_CTRL:
-	case CS35L41_OTP_TRIM_1:
-	case CS35L41_OTP_TRIM_2:
-	case CS35L41_OTP_TRIM_3:
-	case CS35L41_OTP_TRIM_4:
-	case CS35L41_OTP_TRIM_5:
-	case CS35L41_OTP_TRIM_6:
-	case CS35L41_OTP_TRIM_7:
-	case CS35L41_OTP_TRIM_8:
-	case CS35L41_OTP_TRIM_9:
-	case CS35L41_OTP_TRIM_10:
-	case CS35L41_OTP_TRIM_11:
-	case CS35L41_OTP_TRIM_12:
-	case CS35L41_OTP_TRIM_13:
-	case CS35L41_OTP_TRIM_14:
-	case CS35L41_OTP_TRIM_15:
-	case CS35L41_OTP_TRIM_16:
-	case CS35L41_OTP_TRIM_17:
-	case CS35L41_OTP_TRIM_18:
-	case CS35L41_OTP_TRIM_19:
-	case CS35L41_OTP_TRIM_20:
-	case CS35L41_OTP_TRIM_21:
-	case CS35L41_OTP_TRIM_22:
-	case CS35L41_OTP_TRIM_23:
-	case CS35L41_OTP_TRIM_24:
-	case CS35L41_OTP_TRIM_25:
-	case CS35L41_OTP_TRIM_26:
-	case CS35L41_OTP_TRIM_27:
-	case CS35L41_OTP_TRIM_28:
-	case CS35L41_OTP_TRIM_29:
-	case CS35L41_OTP_TRIM_30:
-	case CS35L41_OTP_TRIM_31:
-	case CS35L41_OTP_TRIM_32:
-	case CS35L41_OTP_TRIM_33:
-	case CS35L41_OTP_TRIM_34:
-	case CS35L41_OTP_TRIM_35:
-	case CS35L41_OTP_TRIM_36:
-	case CS35L41_OTP_MEM0 ... CS35L41_OTP_MEM31:
-	case CS35L41_DSP1_XMEM_PACK_0 ... CS35L41_DSP1_XMEM_PACK_3068:
-	case CS35L41_DSP1_XMEM_UNPACK32_0 ... CS35L41_DSP1_XMEM_UNPACK32_2046:
-	case CS35L41_DSP1_XMEM_UNPACK24_0 ... CS35L41_DSP1_XMEM_UNPACK24_4093:
-	case CS35L41_DSP1_YMEM_PACK_0 ... CS35L41_DSP1_YMEM_PACK_1532:
-	case CS35L41_DSP1_YMEM_UNPACK32_0 ... CS35L41_DSP1_YMEM_UNPACK32_1022:
-	case CS35L41_DSP1_YMEM_UNPACK24_0 ... CS35L41_DSP1_YMEM_UNPACK24_2045:
-	case CS35L41_DSP1_PMEM_0 ... CS35L41_DSP1_PMEM_5114:
-	/*test regs*/
-	case CS35L41_PLL_OVR:
-	case CS35L41_BST_TEST_DUTY:
-	case CS35L41_DIGPWM_IOCTRL:
-		return true;
-	default:
-		return false;
-	}
-}
-
-static bool cs35l41_precious_reg(struct device *dev, unsigned int reg)
-{
-	switch (reg) {
-	case CS35L41_TEST_KEY_CTL:
-	case CS35L41_USER_KEY_CTL:
-	case CS35L41_OTP_MEM0 ... CS35L41_OTP_MEM31:
-	case CS35L41_TST_FS_MON0:
-	case CS35L41_DSP1_XMEM_PACK_0 ... CS35L41_DSP1_XMEM_PACK_3068:
-	case CS35L41_DSP1_YMEM_PACK_0 ... CS35L41_DSP1_YMEM_PACK_1532:
-	case CS35L41_DSP1_PMEM_0 ... CS35L41_DSP1_PMEM_5114:
-		return true;
-	default:
-		return false;
-	}
-}
-
-static bool cs35l41_volatile_reg(struct device *dev, unsigned int reg)
-{
-	switch (reg) {
-	case CS35L41_DEVID:
-	case CS35L41_SFT_RESET:
-	case CS35L41_FABID:
-	case CS35L41_REVID:
-	case CS35L41_OTPID:
-	case CS35L41_TEST_KEY_CTL:
-	case CS35L41_USER_KEY_CTL:
-	case CS35L41_PWRMGT_CTL:
-	case CS35L41_WAKESRC_CTL:
-	case CS35L41_PWRMGT_STS:
-	case CS35L41_DTEMP_EN:
-	case CS35L41_IRQ1_STATUS:
-	case CS35L41_IRQ1_STATUS1:
-	case CS35L41_IRQ1_STATUS2:
-	case CS35L41_IRQ1_STATUS3:
-	case CS35L41_IRQ1_STATUS4:
-	case CS35L41_IRQ1_RAW_STATUS1:
-	case CS35L41_IRQ1_RAW_STATUS2:
-	case CS35L41_IRQ1_RAW_STATUS3:
-	case CS35L41_IRQ1_RAW_STATUS4:
-	case CS35L41_IRQ2_STATUS:
-	case CS35L41_IRQ2_STATUS1:
-	case CS35L41_IRQ2_STATUS2:
-	case CS35L41_IRQ2_STATUS3:
-	case CS35L41_IRQ2_STATUS4:
-	case CS35L41_IRQ2_RAW_STATUS1:
-	case CS35L41_IRQ2_RAW_STATUS2:
-	case CS35L41_IRQ2_RAW_STATUS3:
-	case CS35L41_IRQ2_RAW_STATUS4:
-	case CS35L41_GPIO_STATUS1:
-	case CS35L41_DSP_MBOX_1 ... CS35L41_DSP_VIRT2_MBOX_8:
-	case CS35L41_DSP1_XMEM_PACK_0 ... CS35L41_DSP1_XMEM_PACK_3068:
-	case CS35L41_DSP1_XMEM_UNPACK32_0 ... CS35L41_DSP1_XMEM_UNPACK32_2046:
-	case CS35L41_DSP1_XMEM_UNPACK24_0 ... CS35L41_DSP1_XMEM_UNPACK24_4093:
-	case CS35L41_DSP1_YMEM_PACK_0 ... CS35L41_DSP1_YMEM_PACK_1532:
-	case CS35L41_DSP1_YMEM_UNPACK32_0 ... CS35L41_DSP1_YMEM_UNPACK32_1022:
-	case CS35L41_DSP1_YMEM_UNPACK24_0 ... CS35L41_DSP1_YMEM_UNPACK24_2045:
-	case CS35L41_DSP1_PMEM_0 ... CS35L41_DSP1_PMEM_5114:
-	case CS35L41_DSP1_SCRATCH1:
-	case CS35L41_DSP1_SCRATCH2:
-	case CS35L41_DSP1_SCRATCH3:
-	case CS35L41_DSP1_SCRATCH4:
-	case CS35L41_DSP1_CCM_CLK_OVERRIDE ... CS35L41_DSP1_WDT_STATUS:
-	case CS35L41_OTP_MEM0 ... CS35L41_OTP_MEM31:
-		return true;
-	default:
-		return false;
-	}
-}
-
-static const struct cs35l41_otp_packed_element_t otp_map_1[] = {
-	/* addr         shift   size */
-	{ 0x00002030,	0,	4 }, /*TRIM_OSC_FREQ_TRIM*/
-	{ 0x00002030,	7,	1 }, /*TRIM_OSC_TRIM_DONE*/
-	{ 0x0000208c,	24,	6 }, /*TST_DIGREG_VREF_TRIM*/
-	{ 0x00002090,	14,	4 }, /*TST_REF_TRIM*/
-	{ 0x00002090,	10,	4 }, /*TST_REF_TEMPCO_TRIM*/
-	{ 0x0000300C,	11,	4 }, /*PLL_LDOA_TST_VREF_TRIM*/
-	{ 0x0000394C,	23,	2 }, /*BST_ATEST_CM_VOFF*/
-	{ 0x00003950,	0,	7 }, /*BST_ATRIM_IADC_OFFSET*/
-	{ 0x00003950,	8,	7 }, /*BST_ATRIM_IADC_GAIN1*/
-	{ 0x00003950,	16,	8 }, /*BST_ATRIM_IPKCOMP_OFFSET1*/
-	{ 0x00003950,	24,	8 }, /*BST_ATRIM_IPKCOMP_GAIN1*/
-	{ 0x00003954,	0,	7 }, /*BST_ATRIM_IADC_OFFSET2*/
-	{ 0x00003954,	8,	7 }, /*BST_ATRIM_IADC_GAIN2*/
-	{ 0x00003954,	16,	8 }, /*BST_ATRIM_IPKCOMP_OFFSET2*/
-	{ 0x00003954,	24,	8 }, /*BST_ATRIM_IPKCOMP_GAIN2*/
-	{ 0x00003958,	0,	7 }, /*BST_ATRIM_IADC_OFFSET3*/
-	{ 0x00003958,	8,	7 }, /*BST_ATRIM_IADC_GAIN3*/
-	{ 0x00003958,	16,	8 }, /*BST_ATRIM_IPKCOMP_OFFSET3*/
-	{ 0x00003958,	24,	8 }, /*BST_ATRIM_IPKCOMP_GAIN3*/
-	{ 0x0000395C,	0,	7 }, /*BST_ATRIM_IADC_OFFSET4*/
-	{ 0x0000395C,	8,	7 }, /*BST_ATRIM_IADC_GAIN4*/
-	{ 0x0000395C,	16,	8 }, /*BST_ATRIM_IPKCOMP_OFFSET4*/
-	{ 0x0000395C,	24,	8 }, /*BST_ATRIM_IPKCOMP_GAIN4*/
-	{ 0x0000416C,	0,	8 }, /*VMON_GAIN_OTP_VAL*/
-	{ 0x00004160,	0,	7 }, /*VMON_OFFSET_OTP_VAL*/
-	{ 0x0000416C,	8,	8 }, /*IMON_GAIN_OTP_VAL*/
-	{ 0x00004160,	16,	10 }, /*IMON_OFFSET_OTP_VAL*/
-	{ 0x0000416C,	16,	12 }, /*VMON_CM_GAIN_OTP_VAL*/
-	{ 0x0000416C,	28,	1 }, /*VMON_CM_GAIN_SIGN_OTP_VAL*/
-	{ 0x00004170,	0,	6 }, /*IMON_CAL_TEMPCO_OTP_VAL*/
-	{ 0x00004170,	6,	1 }, /*IMON_CAL_TEMPCO_SIGN_OTP*/
-	{ 0x00004170,	8,	6 }, /*IMON_CAL_TEMPCO2_OTP_VAL*/
-	{ 0x00004170,	14,	1 }, /*IMON_CAL_TEMPCO2_DN_UPB_OTP_VAL*/
-	{ 0x00004170,	16,	9 }, /*IMON_CAL_TEMPCO_TBASE_OTP_VAL*/
-	{ 0x00004360,	0,	5 }, /*TEMP_GAIN_OTP_VAL*/
-	{ 0x00004360,	6,	9 }, /*TEMP_OFFSET_OTP_VAL*/
-	{ 0x00004448,	0,	8 }, /*VP_SARADC_OFFSET*/
-	{ 0x00004448,	8,	8 }, /*VP_GAIN_INDEX*/
-	{ 0x00004448,	16,	8 }, /*VBST_SARADC_OFFSET*/
-	{ 0x00004448,	24,	8 }, /*VBST_GAIN_INDEX*/
-	{ 0x0000444C,	0,	3 }, /*ANA_SELINVREF*/
-	{ 0x00006E30,	0,	5 }, /*GAIN_ERR_COEFF_0*/
-	{ 0x00006E30,	8,	5 }, /*GAIN_ERR_COEFF_1*/
-	{ 0x00006E30,	16,	5 }, /*GAIN_ERR_COEFF_2*/
-	{ 0x00006E30,	24,	5 }, /*GAIN_ERR_COEFF_3*/
-	{ 0x00006E34,	0,	5 }, /*GAIN_ERR_COEFF_4*/
-	{ 0x00006E34,	8,	5 }, /*GAIN_ERR_COEFF_5*/
-	{ 0x00006E34,	16,	5 }, /*GAIN_ERR_COEFF_6*/
-	{ 0x00006E34,	24,	5 }, /*GAIN_ERR_COEFF_7*/
-	{ 0x00006E38,	0,	5 }, /*GAIN_ERR_COEFF_8*/
-	{ 0x00006E38,	8,	5 }, /*GAIN_ERR_COEFF_9*/
-	{ 0x00006E38,	16,	5 }, /*GAIN_ERR_COEFF_10*/
-	{ 0x00006E38,	24,	5 }, /*GAIN_ERR_COEFF_11*/
-	{ 0x00006E3C,	0,	5 }, /*GAIN_ERR_COEFF_12*/
-	{ 0x00006E3C,	8,	5 }, /*GAIN_ERR_COEFF_13*/
-	{ 0x00006E3C,	16,	5 }, /*GAIN_ERR_COEFF_14*/
-	{ 0x00006E3C,	24,	5 }, /*GAIN_ERR_COEFF_15*/
-	{ 0x00006E40,	0,	5 }, /*GAIN_ERR_COEFF_16*/
-	{ 0x00006E40,	8,	5 }, /*GAIN_ERR_COEFF_17*/
-	{ 0x00006E40,	16,	5 }, /*GAIN_ERR_COEFF_18*/
-	{ 0x00006E40,	24,	5 }, /*GAIN_ERR_COEFF_19*/
-	{ 0x00006E44,	0,	5 }, /*GAIN_ERR_COEFF_20*/
-	{ 0x00006E48,	0,	10 }, /*VOFF_GAIN_0*/
-	{ 0x00006E48,	10,	10 }, /*VOFF_GAIN_1*/
-	{ 0x00006E48,	20,	10 }, /*VOFF_GAIN_2*/
-	{ 0x00006E4C,	0,	10 }, /*VOFF_GAIN_3*/
-	{ 0x00006E4C,	10,	10 }, /*VOFF_GAIN_4*/
-	{ 0x00006E4C,	20,	10 }, /*VOFF_GAIN_5*/
-	{ 0x00006E50,	0,	10 }, /*VOFF_GAIN_6*/
-	{ 0x00006E50,	10,	10 }, /*VOFF_GAIN_7*/
-	{ 0x00006E50,	20,	10 }, /*VOFF_GAIN_8*/
-	{ 0x00006E54,	0,	10 }, /*VOFF_GAIN_9*/
-	{ 0x00006E54,	10,	10 }, /*VOFF_GAIN_10*/
-	{ 0x00006E54,	20,	10 }, /*VOFF_GAIN_11*/
-	{ 0x00006E58,	0,	10 }, /*VOFF_GAIN_12*/
-	{ 0x00006E58,	10,	10 }, /*VOFF_GAIN_13*/
-	{ 0x00006E58,	20,	10 }, /*VOFF_GAIN_14*/
-	{ 0x00006E5C,	0,	10 }, /*VOFF_GAIN_15*/
-	{ 0x00006E5C,	10,	10 }, /*VOFF_GAIN_16*/
-	{ 0x00006E5C,	20,	10 }, /*VOFF_GAIN_17*/
-	{ 0x00006E60,	0,	10 }, /*VOFF_GAIN_18*/
-	{ 0x00006E60,	10,	10 }, /*VOFF_GAIN_19*/
-	{ 0x00006E60,	20,	10 }, /*VOFF_GAIN_20*/
-	{ 0x00006E64,	0,	10 }, /*VOFF_INT1*/
-	{ 0x00007418,	7,	5 }, /*DS_SPK_INT1_CAP_TRIM*/
-	{ 0x0000741C,	0,	5 }, /*DS_SPK_INT2_CAP_TRIM*/
-	{ 0x0000741C,	11,	4 }, /*DS_SPK_LPF_CAP_TRIM*/
-	{ 0x0000741C,	19,	4 }, /*DS_SPK_QUAN_CAP_TRIM*/
-	{ 0x00007434,	17,	1 }, /*FORCE_CAL*/
-	{ 0x00007434,	18,	7 }, /*CAL_OVERRIDE*/
-	{ 0x00007068,	0,	9 }, /*MODIX*/
-	{ 0x0000410C,	7,	1 }, /*VIMON_DLY_NOT_COMB*/
-	{ 0x0000400C,	0,	7 }, /*VIMON_DLY*/
-	{ 0x00000000,	0,	1 }, /*extra bit*/
-	{ 0x00017040,	0,	8 }, /*X_COORDINATE*/
-	{ 0x00017040,	8,	8 }, /*Y_COORDINATE*/
-	{ 0x00017040,	16,	8 }, /*WAFER_ID*/
-	{ 0x00017040,	24,	8 }, /*DVS*/
-	{ 0x00017044,	0,	24 }, /*LOT_NUMBER*/
-};
-
-static const struct cs35l41_otp_packed_element_t otp_map_2[] = {
-	/* addr         shift   size */
-	{ 0x00002030,	0,	4 }, /*TRIM_OSC_FREQ_TRIM*/
-	{ 0x00002030,	7,	1 }, /*TRIM_OSC_TRIM_DONE*/
-	{ 0x0000208c,	24,	6 }, /*TST_DIGREG_VREF_TRIM*/
-	{ 0x00002090,	14,	4 }, /*TST_REF_TRIM*/
-	{ 0x00002090,	10,	4 }, /*TST_REF_TEMPCO_TRIM*/
-	{ 0x0000300C,	11,	4 }, /*PLL_LDOA_TST_VREF_TRIM*/
-	{ 0x0000394C,	23,	2 }, /*BST_ATEST_CM_VOFF*/
-	{ 0x00003950,	0,	7 }, /*BST_ATRIM_IADC_OFFSET*/
-	{ 0x00003950,	8,	7 }, /*BST_ATRIM_IADC_GAIN1*/
-	{ 0x00003950,	16,	8 }, /*BST_ATRIM_IPKCOMP_OFFSET1*/
-	{ 0x00003950,	24,	8 }, /*BST_ATRIM_IPKCOMP_GAIN1*/
-	{ 0x00003954,	0,	7 }, /*BST_ATRIM_IADC_OFFSET2*/
-	{ 0x00003954,	8,	7 }, /*BST_ATRIM_IADC_GAIN2*/
-	{ 0x00003954,	16,	8 }, /*BST_ATRIM_IPKCOMP_OFFSET2*/
-	{ 0x00003954,	24,	8 }, /*BST_ATRIM_IPKCOMP_GAIN2*/
-	{ 0x00003958,	0,	7 }, /*BST_ATRIM_IADC_OFFSET3*/
-	{ 0x00003958,	8,	7 }, /*BST_ATRIM_IADC_GAIN3*/
-	{ 0x00003958,	16,	8 }, /*BST_ATRIM_IPKCOMP_OFFSET3*/
-	{ 0x00003958,	24,	8 }, /*BST_ATRIM_IPKCOMP_GAIN3*/
-	{ 0x0000395C,	0,	7 }, /*BST_ATRIM_IADC_OFFSET4*/
-	{ 0x0000395C,	8,	7 }, /*BST_ATRIM_IADC_GAIN4*/
-	{ 0x0000395C,	16,	8 }, /*BST_ATRIM_IPKCOMP_OFFSET4*/
-	{ 0x0000395C,	24,	8 }, /*BST_ATRIM_IPKCOMP_GAIN4*/
-	{ 0x0000416C,	0,	8 }, /*VMON_GAIN_OTP_VAL*/
-	{ 0x00004160,	0,	7 }, /*VMON_OFFSET_OTP_VAL*/
-	{ 0x0000416C,	8,	8 }, /*IMON_GAIN_OTP_VAL*/
-	{ 0x00004160,	16,	10 }, /*IMON_OFFSET_OTP_VAL*/
-	{ 0x0000416C,	16,	12 }, /*VMON_CM_GAIN_OTP_VAL*/
-	{ 0x0000416C,	28,	1 }, /*VMON_CM_GAIN_SIGN_OTP_VAL*/
-	{ 0x00004170,	0,	6 }, /*IMON_CAL_TEMPCO_OTP_VAL*/
-	{ 0x00004170,	6,	1 }, /*IMON_CAL_TEMPCO_SIGN_OTP*/
-	{ 0x00004170,	8,	6 }, /*IMON_CAL_TEMPCO2_OTP_VAL*/
-	{ 0x00004170,	14,	1 }, /*IMON_CAL_TEMPCO2_DN_UPB_OTP_VAL*/
-	{ 0x00004170,	16,	9 }, /*IMON_CAL_TEMPCO_TBASE_OTP_VAL*/
-	{ 0x00004360,	0,	5 }, /*TEMP_GAIN_OTP_VAL*/
-	{ 0x00004360,	6,	9 }, /*TEMP_OFFSET_OTP_VAL*/
-	{ 0x00004448,	0,	8 }, /*VP_SARADC_OFFSET*/
-	{ 0x00004448,	8,	8 }, /*VP_GAIN_INDEX*/
-	{ 0x00004448,	16,	8 }, /*VBST_SARADC_OFFSET*/
-	{ 0x00004448,	24,	8 }, /*VBST_GAIN_INDEX*/
-	{ 0x0000444C,	0,	3 }, /*ANA_SELINVREF*/
-	{ 0x00006E30,	0,	5 }, /*GAIN_ERR_COEFF_0*/
-	{ 0x00006E30,	8,	5 }, /*GAIN_ERR_COEFF_1*/
-	{ 0x00006E30,	16,	5 }, /*GAIN_ERR_COEFF_2*/
-	{ 0x00006E30,	24,	5 }, /*GAIN_ERR_COEFF_3*/
-	{ 0x00006E34,	0,	5 }, /*GAIN_ERR_COEFF_4*/
-	{ 0x00006E34,	8,	5 }, /*GAIN_ERR_COEFF_5*/
-	{ 0x00006E34,	16,	5 }, /*GAIN_ERR_COEFF_6*/
-	{ 0x00006E34,	24,	5 }, /*GAIN_ERR_COEFF_7*/
-	{ 0x00006E38,	0,	5 }, /*GAIN_ERR_COEFF_8*/
-	{ 0x00006E38,	8,	5 }, /*GAIN_ERR_COEFF_9*/
-	{ 0x00006E38,	16,	5 }, /*GAIN_ERR_COEFF_10*/
-	{ 0x00006E38,	24,	5 }, /*GAIN_ERR_COEFF_11*/
-	{ 0x00006E3C,	0,	5 }, /*GAIN_ERR_COEFF_12*/
-	{ 0x00006E3C,	8,	5 }, /*GAIN_ERR_COEFF_13*/
-	{ 0x00006E3C,	16,	5 }, /*GAIN_ERR_COEFF_14*/
-	{ 0x00006E3C,	24,	5 }, /*GAIN_ERR_COEFF_15*/
-	{ 0x00006E40,	0,	5 }, /*GAIN_ERR_COEFF_16*/
-	{ 0x00006E40,	8,	5 }, /*GAIN_ERR_COEFF_17*/
-	{ 0x00006E40,	16,	5 }, /*GAIN_ERR_COEFF_18*/
-	{ 0x00006E40,	24,	5 }, /*GAIN_ERR_COEFF_19*/
-	{ 0x00006E44,	0,	5 }, /*GAIN_ERR_COEFF_20*/
-	{ 0x00006E48,	0,	10 }, /*VOFF_GAIN_0*/
-	{ 0x00006E48,	10,	10 }, /*VOFF_GAIN_1*/
-	{ 0x00006E48,	20,	10 }, /*VOFF_GAIN_2*/
-	{ 0x00006E4C,	0,	10 }, /*VOFF_GAIN_3*/
-	{ 0x00006E4C,	10,	10 }, /*VOFF_GAIN_4*/
-	{ 0x00006E4C,	20,	10 }, /*VOFF_GAIN_5*/
-	{ 0x00006E50,	0,	10 }, /*VOFF_GAIN_6*/
-	{ 0x00006E50,	10,	10 }, /*VOFF_GAIN_7*/
-	{ 0x00006E50,	20,	10 }, /*VOFF_GAIN_8*/
-	{ 0x00006E54,	0,	10 }, /*VOFF_GAIN_9*/
-	{ 0x00006E54,	10,	10 }, /*VOFF_GAIN_10*/
-	{ 0x00006E54,	20,	10 }, /*VOFF_GAIN_11*/
-	{ 0x00006E58,	0,	10 }, /*VOFF_GAIN_12*/
-	{ 0x00006E58,	10,	10 }, /*VOFF_GAIN_13*/
-	{ 0x00006E58,	20,	10 }, /*VOFF_GAIN_14*/
-	{ 0x00006E5C,	0,	10 }, /*VOFF_GAIN_15*/
-	{ 0x00006E5C,	10,	10 }, /*VOFF_GAIN_16*/
-	{ 0x00006E5C,	20,	10 }, /*VOFF_GAIN_17*/
-	{ 0x00006E60,	0,	10 }, /*VOFF_GAIN_18*/
-	{ 0x00006E60,	10,	10 }, /*VOFF_GAIN_19*/
-	{ 0x00006E60,	20,	10 }, /*VOFF_GAIN_20*/
-	{ 0x00006E64,	0,	10 }, /*VOFF_INT1*/
-	{ 0x00007418,	7,	5 }, /*DS_SPK_INT1_CAP_TRIM*/
-	{ 0x0000741C,	0,	5 }, /*DS_SPK_INT2_CAP_TRIM*/
-	{ 0x0000741C,	11,	4 }, /*DS_SPK_LPF_CAP_TRIM*/
-	{ 0x0000741C,	19,	4 }, /*DS_SPK_QUAN_CAP_TRIM*/
-	{ 0x00007434,	17,	1 }, /*FORCE_CAL*/
-	{ 0x00007434,	18,	7 }, /*CAL_OVERRIDE*/
-	{ 0x00007068,	0,	9 }, /*MODIX*/
-	{ 0x0000410C,	7,	1 }, /*VIMON_DLY_NOT_COMB*/
-	{ 0x0000400C,	0,	7 }, /*VIMON_DLY*/
-	{ 0x00004000,	11,	1 }, /*VMON_POL*/
-	{ 0x00017040,	0,	8 }, /*X_COORDINATE*/
-	{ 0x00017040,	8,	8 }, /*Y_COORDINATE*/
-	{ 0x00017040,	16,	8 }, /*WAFER_ID*/
-	{ 0x00017040,	24,	8 }, /*DVS*/
-	{ 0x00017044,	0,	24 }, /*LOT_NUMBER*/
-};
-
-static const struct reg_sequence cs35l41_reva0_errata_patch[] = {
-	{ 0x00003854,			 0x05180240 },
-	{ CS35L41_VIMON_SPKMON_RESYNC,	 0x00000000 },
-	{ 0x00004310,			 0x00000000 },
-	{ CS35L41_VPVBST_FS_SEL,	 0x00000000 },
-	{ CS35L41_OTP_TRIM_30,		 0x9091A1C8 },
-	{ 0x00003014,			 0x0200EE0E },
-	{ CS35L41_BSTCVRT_DCM_CTRL,	 0x00000051 },
-	{ 0x00000054,			 0x00000004 },
-	{ CS35L41_IRQ1_DB3,		 0x00000000 },
-	{ CS35L41_IRQ2_DB3,		 0x00000000 },
-	{ CS35L41_DSP1_YM_ACCEL_PL0_PRI, 0x00000000 },
-	{ CS35L41_DSP1_XM_ACCEL_PL0_PRI, 0x00000000 },
-	{ CS35L41_PWR_CTRL2,		 0x00000000 },
-	{ CS35L41_AMP_GAIN_CTRL,	 0x00000000 },
-	{ CS35L41_ASP_TX3_SRC,		 0x00000000 },
-	{ CS35L41_ASP_TX4_SRC,		 0x00000000 },
-};
-
-static const struct reg_sequence cs35l41_revb0_errata_patch[] = {
-	{ CS35L41_VIMON_SPKMON_RESYNC,	 0x00000000 },
-	{ 0x00004310,			 0x00000000 },
-	{ CS35L41_VPVBST_FS_SEL,	 0x00000000 },
-	{ CS35L41_BSTCVRT_DCM_CTRL,	 0x00000051 },
-	{ CS35L41_DSP1_YM_ACCEL_PL0_PRI, 0x00000000 },
-	{ CS35L41_DSP1_XM_ACCEL_PL0_PRI, 0x00000000 },
-	{ CS35L41_PWR_CTRL2,		 0x00000000 },
-	{ CS35L41_AMP_GAIN_CTRL,	 0x00000000 },
-	{ CS35L41_ASP_TX3_SRC,		 0x00000000 },
-	{ CS35L41_ASP_TX4_SRC,		 0x00000000 },
-};
-
-static const struct reg_sequence cs35l41_revb2_errata_patch[] = {
-	{ CS35L41_VIMON_SPKMON_RESYNC,	 0x00000000 },
-	{ 0x00004310,			 0x00000000 },
-	{ CS35L41_VPVBST_FS_SEL,	 0x00000000 },
-	{ CS35L41_BSTCVRT_DCM_CTRL,	 0x00000051 },
-	{ CS35L41_DSP1_YM_ACCEL_PL0_PRI, 0x00000000 },
-	{ CS35L41_DSP1_XM_ACCEL_PL0_PRI, 0x00000000 },
-	{ CS35L41_PWR_CTRL2,		 0x00000000 },
-	{ CS35L41_AMP_GAIN_CTRL,	 0x00000000 },
-	{ CS35L41_ASP_TX3_SRC,		 0x00000000 },
-	{ CS35L41_ASP_TX4_SRC,		 0x00000000 },
-};
-
-static const struct reg_sequence cs35l41_fs_errata_patch[] = {
-	{ CS35L41_DSP1_RX1_RATE,	0x00000001 },
-	{ CS35L41_DSP1_RX2_RATE,	0x00000001 },
-	{ CS35L41_DSP1_RX3_RATE,	0x00000001 },
-	{ CS35L41_DSP1_RX4_RATE,	0x00000001 },
-	{ CS35L41_DSP1_RX5_RATE,	0x00000001 },
-	{ CS35L41_DSP1_RX6_RATE,	0x00000001 },
-	{ CS35L41_DSP1_RX7_RATE,	0x00000001 },
-	{ CS35L41_DSP1_RX8_RATE,	0x00000001 },
-	{ CS35L41_DSP1_TX1_RATE,	0x00000001 },
-	{ CS35L41_DSP1_TX2_RATE,	0x00000001 },
-	{ CS35L41_DSP1_TX3_RATE,	0x00000001 },
-	{ CS35L41_DSP1_TX4_RATE,	0x00000001 },
-	{ CS35L41_DSP1_TX5_RATE,	0x00000001 },
-	{ CS35L41_DSP1_TX6_RATE,	0x00000001 },
-	{ CS35L41_DSP1_TX7_RATE,	0x00000001 },
-	{ CS35L41_DSP1_TX8_RATE,	0x00000001 },
-};
-
-static const struct cs35l41_otp_map_element_t cs35l41_otp_map_map[] = {
-	{
-		.id = 0x01,
-		.map = otp_map_1,
-		.num_elements = ARRAY_SIZE(otp_map_1),
-		.bit_offset = 16,
-		.word_offset = 2,
-	},
-	{
-		.id = 0x02,
-		.map = otp_map_2,
-		.num_elements = ARRAY_SIZE(otp_map_2),
-		.bit_offset = 16,
-		.word_offset = 2,
-	},
-	{
-		.id = 0x03,
-		.map = otp_map_2,
-		.num_elements = ARRAY_SIZE(otp_map_2),
-		.bit_offset = 16,
-		.word_offset = 2,
-	},
-	{
-		.id = 0x06,
-		.map = otp_map_2,
-		.num_elements = ARRAY_SIZE(otp_map_2),
-		.bit_offset = 16,
-		.word_offset = 2,
-	},
-	{
-		.id = 0x08,
-		.map = otp_map_1,
-		.num_elements = ARRAY_SIZE(otp_map_1),
-		.bit_offset = 16,
-		.word_offset = 2,
-	},
-};
-
-struct regmap_config cs35l41_regmap_i2c = {
-	.reg_bits = 32,
-	.val_bits = 32,
-	.reg_stride = CS35L41_REGSTRIDE,
-	.reg_format_endian = REGMAP_ENDIAN_BIG,
-	.val_format_endian = REGMAP_ENDIAN_BIG,
-	.max_register = CS35L41_LASTREG,
-	.reg_defaults = cs35l41_reg,
-	.num_reg_defaults = ARRAY_SIZE(cs35l41_reg),
-	.volatile_reg = cs35l41_volatile_reg,
-	.readable_reg = cs35l41_readable_reg,
-	.precious_reg = cs35l41_precious_reg,
-	.cache_type = REGCACHE_RBTREE,
-};
-EXPORT_SYMBOL_GPL(cs35l41_regmap_i2c);
-
-struct regmap_config cs35l41_regmap_spi = {
-	.reg_bits = 32,
-	.val_bits = 32,
-	.pad_bits = 16,
-	.reg_stride = CS35L41_REGSTRIDE,
-	.reg_format_endian = REGMAP_ENDIAN_BIG,
-	.val_format_endian = REGMAP_ENDIAN_BIG,
-	.max_register = CS35L41_LASTREG,
-	.reg_defaults = cs35l41_reg,
-	.num_reg_defaults = ARRAY_SIZE(cs35l41_reg),
-	.volatile_reg = cs35l41_volatile_reg,
-	.readable_reg = cs35l41_readable_reg,
-	.precious_reg = cs35l41_precious_reg,
-	.cache_type = REGCACHE_RBTREE,
-};
-EXPORT_SYMBOL_GPL(cs35l41_regmap_spi);
-
-static const struct cs35l41_otp_map_element_t *cs35l41_find_otp_map(u32 otp_id)
-{
-	int i;
-
-	for (i = 0; i < ARRAY_SIZE(cs35l41_otp_map_map); i++) {
-		if (cs35l41_otp_map_map[i].id == otp_id)
-			return &cs35l41_otp_map_map[i];
-	}
-
-	return NULL;
-}
-
-int cs35l41_test_key_unlock(struct device *dev, struct regmap *regmap)
-{
-	static const struct reg_sequence unlock[] = {
-		{ CS35L41_TEST_KEY_CTL, 0x00000055 },
-		{ CS35L41_TEST_KEY_CTL, 0x000000AA },
-	};
-	int ret;
-
-	ret = regmap_multi_reg_write(regmap, unlock, ARRAY_SIZE(unlock));
-	if (ret)
-		dev_err(dev, "Failed to unlock test key: %d\n", ret);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(cs35l41_test_key_unlock);
-
-int cs35l41_test_key_lock(struct device *dev, struct regmap *regmap)
-{
-	static const struct reg_sequence unlock[] = {
-		{ CS35L41_TEST_KEY_CTL, 0x000000CC },
-		{ CS35L41_TEST_KEY_CTL, 0x00000033 },
-	};
-	int ret;
-
-	ret = regmap_multi_reg_write(regmap, unlock, ARRAY_SIZE(unlock));
-	if (ret)
-		dev_err(dev, "Failed to lock test key: %d\n", ret);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(cs35l41_test_key_lock);
-
-/* Must be called with the TEST_KEY unlocked */
-int cs35l41_otp_unpack(struct device *dev, struct regmap *regmap)
-{
-	const struct cs35l41_otp_map_element_t *otp_map_match;
-	const struct cs35l41_otp_packed_element_t *otp_map;
-	int bit_offset, word_offset, ret, i;
-	unsigned int bit_sum = 8;
-	u32 otp_val, otp_id_reg;
-	u32 *otp_mem;
-
-	otp_mem = kmalloc_array(CS35L41_OTP_SIZE_WORDS, sizeof(*otp_mem), GFP_KERNEL);
-	if (!otp_mem)
-		return -ENOMEM;
-
-	ret = regmap_read(regmap, CS35L41_OTPID, &otp_id_reg);
-	if (ret) {
-		dev_err(dev, "Read OTP ID failed: %d\n", ret);
-		goto err_otp_unpack;
-	}
-
-	otp_map_match = cs35l41_find_otp_map(otp_id_reg);
-
-	if (!otp_map_match) {
-		dev_err(dev, "OTP Map matching ID %d not found\n", otp_id_reg);
-		ret = -EINVAL;
-		goto err_otp_unpack;
-	}
-
-	ret = regmap_bulk_read(regmap, CS35L41_OTP_MEM0, otp_mem, CS35L41_OTP_SIZE_WORDS);
-	if (ret) {
-		dev_err(dev, "Read OTP Mem failed: %d\n", ret);
-		goto err_otp_unpack;
-	}
-
-	otp_map = otp_map_match->map;
-
-	bit_offset = otp_map_match->bit_offset;
-	word_offset = otp_map_match->word_offset;
-
-	for (i = 0; i < otp_map_match->num_elements; i++) {
-		dev_dbg(dev, "bitoffset= %d, word_offset=%d, bit_sum mod 32=%d, otp_map[i].size = %u\n",
-			bit_offset, word_offset, bit_sum % 32, otp_map[i].size);
-		if (bit_offset + otp_map[i].size - 1 >= 32) {
-			otp_val = (otp_mem[word_offset] &
-					GENMASK(31, bit_offset)) >> bit_offset;
-			otp_val |= (otp_mem[++word_offset] &
-					GENMASK(bit_offset + otp_map[i].size - 33, 0)) <<
-					(32 - bit_offset);
-			bit_offset += otp_map[i].size - 32;
-		} else if (bit_offset + otp_map[i].size - 1 >= 0) {
-			otp_val = (otp_mem[word_offset] &
-				   GENMASK(bit_offset + otp_map[i].size - 1, bit_offset)
-				  ) >> bit_offset;
-			bit_offset += otp_map[i].size;
-		} else /* both bit_offset and otp_map[i].size are 0 */
-			otp_val = 0;
-
-		bit_sum += otp_map[i].size;
-
-		if (bit_offset == 32) {
-			bit_offset = 0;
-			word_offset++;
-		}
-
-		if (otp_map[i].reg != 0) {
-			ret = regmap_update_bits(regmap, otp_map[i].reg,
-						 GENMASK(otp_map[i].shift + otp_map[i].size - 1,
-							 otp_map[i].shift),
-						 otp_val << otp_map[i].shift);
-			if (ret < 0) {
-				dev_err(dev, "Write OTP val failed: %d\n", ret);
-				goto err_otp_unpack;
-			}
-		}
-	}
-
-	ret = 0;
-
-err_otp_unpack:
-	kfree(otp_mem);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(cs35l41_otp_unpack);
-
-/* Must be called with the TEST_KEY unlocked */
-int cs35l41_register_errata_patch(struct device *dev, struct regmap *reg, unsigned int reg_revid)
-{
-	char *rev;
-	int ret;
-
-	switch (reg_revid) {
-	case CS35L41_REVID_A0:
-		ret = regmap_register_patch(reg, cs35l41_reva0_errata_patch,
-					    ARRAY_SIZE(cs35l41_reva0_errata_patch));
-		rev = "A0";
-		break;
-	case CS35L41_REVID_B0:
-		ret = regmap_register_patch(reg, cs35l41_revb0_errata_patch,
-					    ARRAY_SIZE(cs35l41_revb0_errata_patch));
-		rev = "B0";
-		break;
-	case CS35L41_REVID_B2:
-		ret = regmap_register_patch(reg, cs35l41_revb2_errata_patch,
-					    ARRAY_SIZE(cs35l41_revb2_errata_patch));
-		rev = "B2";
-		break;
-	default:
-		ret = -EINVAL;
-		rev = "XX";
-		break;
-	}
-
-	if (ret)
-		dev_err(dev, "Failed to apply %s errata patch: %d\n", rev, ret);
-
-	ret = regmap_write(reg, CS35L41_DSP1_CCM_CORE_CTRL, 0);
-	if (ret < 0)
-		dev_err(dev, "Write CCM_CORE_CTRL failed: %d\n", ret);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(cs35l41_register_errata_patch);
-
-int cs35l41_set_channels(struct device *dev, struct regmap *reg,
-			 unsigned int tx_num, unsigned int *tx_slot,
-			 unsigned int rx_num, unsigned int *rx_slot)
-{
-	unsigned int val, mask;
-	int i;
-
-	if (tx_num > 4 || rx_num > 2)
-		return -EINVAL;
-
-	val = 0;
-	mask = 0;
-	for (i = 0; i < rx_num; i++) {
-		dev_dbg(dev, "rx slot %d position = %d\n", i, rx_slot[i]);
-		val |= rx_slot[i] << (i * 8);
-		mask |= 0x3F << (i * 8);
-	}
-	regmap_update_bits(reg, CS35L41_SP_FRAME_RX_SLOT, mask, val);
-
-	val = 0;
-	mask = 0;
-	for (i = 0; i < tx_num; i++) {
-		dev_dbg(dev, "tx slot %d position = %d\n", i, tx_slot[i]);
-		val |= tx_slot[i] << (i * 8);
-		mask |= 0x3F << (i * 8);
-	}
-	regmap_update_bits(reg, CS35L41_SP_FRAME_TX_SLOT, mask, val);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(cs35l41_set_channels);
-
-static const unsigned char cs35l41_bst_k1_table[4][5] = {
-	{ 0x24, 0x32, 0x32, 0x4F, 0x57 },
-	{ 0x24, 0x32, 0x32, 0x4F, 0x57 },
-	{ 0x40, 0x32, 0x32, 0x4F, 0x57 },
-	{ 0x40, 0x32, 0x32, 0x4F, 0x57 }
-};
-
-static const unsigned char cs35l41_bst_k2_table[4][5] = {
-	{ 0x24, 0x49, 0x66, 0xA3, 0xEA },
-	{ 0x24, 0x49, 0x66, 0xA3, 0xEA },
-	{ 0x48, 0x49, 0x66, 0xA3, 0xEA },
-	{ 0x48, 0x49, 0x66, 0xA3, 0xEA }
-};
-
-static const unsigned char cs35l41_bst_slope_table[4] = {
-	0x75, 0x6B, 0x3B, 0x28
-};
-
-static int cs35l41_boost_config(struct device *dev, struct regmap *regmap, int boost_ind,
-				int boost_cap, int boost_ipk)
-{
-	unsigned char bst_lbst_val, bst_cbst_range, bst_ipk_scaled;
-	int ret;
-
-	switch (boost_ind) {
-	case 1000:	/* 1.0 uH */
-		bst_lbst_val = 0;
-		break;
-	case 1200:	/* 1.2 uH */
-		bst_lbst_val = 1;
-		break;
-	case 1500:	/* 1.5 uH */
-		bst_lbst_val = 2;
-		break;
-	case 2200:	/* 2.2 uH */
-		bst_lbst_val = 3;
-		break;
-	default:
-		dev_err(dev, "Invalid boost inductor value: %d nH\n", boost_ind);
-		return -EINVAL;
-	}
-
-	switch (boost_cap) {
-	case 0 ... 19:
-		bst_cbst_range = 0;
-		break;
-	case 20 ... 50:
-		bst_cbst_range = 1;
-		break;
-	case 51 ... 100:
-		bst_cbst_range = 2;
-		break;
-	case 101 ... 200:
-		bst_cbst_range = 3;
-		break;
-	default:
-		if (boost_cap < 0) {
-			dev_err(dev, "Invalid boost capacitor value: %d nH\n", boost_cap);
-			return -EINVAL;
-		}
-		/* 201 uF and greater */
-		bst_cbst_range = 4;
-	}
-
-	if (boost_ipk < 1600 || boost_ipk > 4500) {
-		dev_err(dev, "Invalid boost inductor peak current: %d mA\n", boost_ipk);
-		return -EINVAL;
-	}
-
-	ret = regmap_update_bits(regmap, CS35L41_BSTCVRT_COEFF,
-				 CS35L41_BST_K1_MASK | CS35L41_BST_K2_MASK,
-				 cs35l41_bst_k1_table[bst_lbst_val][bst_cbst_range]
-					<< CS35L41_BST_K1_SHIFT |
-				 cs35l41_bst_k2_table[bst_lbst_val][bst_cbst_range]
-					<< CS35L41_BST_K2_SHIFT);
-	if (ret) {
-		dev_err(dev, "Failed to write boost coefficients: %d\n", ret);
-		return ret;
-	}
-
-	ret = regmap_update_bits(regmap, CS35L41_BSTCVRT_SLOPE_LBST,
-				 CS35L41_BST_SLOPE_MASK | CS35L41_BST_LBST_VAL_MASK,
-				 cs35l41_bst_slope_table[bst_lbst_val]
-					<< CS35L41_BST_SLOPE_SHIFT |
-				 bst_lbst_val << CS35L41_BST_LBST_VAL_SHIFT);
-	if (ret) {
-		dev_err(dev, "Failed to write boost slope/inductor value: %d\n", ret);
-		return ret;
-	}
-
-	bst_ipk_scaled = ((boost_ipk - 1600) / 50) + 0x10;
-
-	ret = regmap_update_bits(regmap, CS35L41_BSTCVRT_PEAK_CUR, CS35L41_BST_IPK_MASK,
-				 bst_ipk_scaled << CS35L41_BST_IPK_SHIFT);
-	if (ret) {
-		dev_err(dev, "Failed to write boost inductor peak current: %d\n", ret);
-		return ret;
-	}
-
-	regmap_update_bits(regmap, CS35L41_PWR_CTRL2, CS35L41_BST_EN_MASK,
-			   CS35L41_BST_EN_DEFAULT << CS35L41_BST_EN_SHIFT);
-
-	return 0;
-}
-
-static const struct reg_sequence cs35l41_safe_to_reset[] = {
-	{ 0x00000040,			0x00000055 },
-	{ 0x00000040,			0x000000AA },
-	{ 0x0000393C,			0x000000C0, 6000},
-	{ 0x0000393C,			0x00000000 },
-	{ 0x00007414,			0x00C82222 },
-	{ 0x0000742C,			0x00000000 },
-	{ 0x00000040,			0x000000CC },
-	{ 0x00000040,			0x00000033 },
-};
-
-static const struct reg_sequence cs35l41_active_to_safe[] = {
-	{ 0x00000040,			0x00000055 },
-	{ 0x00000040,			0x000000AA },
-	{ 0x00007438,			0x00585941 },
-	{ CS35L41_PWR_CTRL1,		0x00000000 },
-	{ 0x0000742C,			0x00000009, 3000 },
-	{ 0x00007438,			0x00580941 },
-	{ 0x00000040,			0x000000CC },
-	{ 0x00000040,			0x00000033 },
-};
-
-static const struct reg_sequence cs35l41_safe_to_active[] = {
-	{ 0x00000040,			0x00000055 },
-	{ 0x00000040,			0x000000AA },
-	{ 0x0000742C,			0x0000000F },
-	{ 0x0000742C,			0x00000079 },
-	{ 0x00007438,			0x00585941 },
-	{ CS35L41_PWR_CTRL1,		0x00000001, 3000 }, // GLOBAL_EN = 1
-	{ 0x0000742C,			0x000000F9 },
-	{ 0x00007438,			0x00580941 },
-	{ 0x00000040,			0x000000CC },
-	{ 0x00000040,			0x00000033 },
-};
-
-static const struct reg_sequence cs35l41_reset_to_safe[] = {
-	{ 0x00000040,			0x00000055 },
-	{ 0x00000040,			0x000000AA },
-	{ 0x00007438,			0x00585941 },
-	{ 0x00007414,			0x08C82222 },
-	{ 0x0000742C,			0x00000009 },
-	{ 0x00000040,			0x000000CC },
-	{ 0x00000040,			0x00000033 },
-};
-
-int cs35l41_init_boost(struct device *dev, struct regmap *regmap,
-		       struct cs35l41_hw_cfg *hw_cfg)
-{
-	int ret;
-
-	switch (hw_cfg->bst_type) {
-	case CS35L41_INT_BOOST:
-		ret = cs35l41_boost_config(dev, regmap, hw_cfg->bst_ind,
-					   hw_cfg->bst_cap, hw_cfg->bst_ipk);
-		if (ret)
-			dev_err(dev, "Error in Boost DT config: %d\n", ret);
-		break;
-	case CS35L41_EXT_BOOST:
-	case CS35L41_EXT_BOOST_NO_VSPK_SWITCH:
-		/* Only CLSA0100 doesn't use GPIO as VSPK switch, but even on that laptop we can
-		 * toggle GPIO1 as is not connected to anything.
-		 * There will be no other device without VSPK switch.
-		 */
-		regmap_write(regmap, CS35L41_GPIO1_CTRL1, 0x00000001);
-		regmap_multi_reg_write(regmap, cs35l41_reset_to_safe,
-				       ARRAY_SIZE(cs35l41_reset_to_safe));
-		ret = regmap_update_bits(regmap, CS35L41_PWR_CTRL2, CS35L41_BST_EN_MASK,
-					 CS35L41_BST_DIS_FET_OFF << CS35L41_BST_EN_SHIFT);
-		break;
-	default:
-		dev_err(dev, "Boost type %d not supported\n", hw_cfg->bst_type);
-		ret = -EINVAL;
-		break;
-	}
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(cs35l41_init_boost);
-
-bool cs35l41_safe_reset(struct regmap *regmap, enum cs35l41_boost_type b_type)
-{
-	switch (b_type) {
-	/* There is only one laptop that doesn't have VSPK switch. */
-	case CS35L41_EXT_BOOST_NO_VSPK_SWITCH:
-		return false;
-	case CS35L41_EXT_BOOST:
-		regmap_write(regmap, CS35L41_GPIO1_CTRL1, 0x00000001);
-		regmap_multi_reg_write(regmap, cs35l41_safe_to_reset,
-				       ARRAY_SIZE(cs35l41_safe_to_reset));
-		return true;
-	default:
-		return true;
-	}
-}
-EXPORT_SYMBOL_GPL(cs35l41_safe_reset);
-
-int cs35l41_global_enable(struct regmap *regmap, enum cs35l41_boost_type b_type, int enable)
-{
-	int ret;
-
-	switch (b_type) {
-	case CS35L41_INT_BOOST:
-		ret = regmap_update_bits(regmap, CS35L41_PWR_CTRL1, CS35L41_GLOBAL_EN_MASK,
-					 enable << CS35L41_GLOBAL_EN_SHIFT);
-		usleep_range(3000, 3100);
-		break;
-	case CS35L41_EXT_BOOST:
-	case CS35L41_EXT_BOOST_NO_VSPK_SWITCH:
-		if (enable)
-			ret = regmap_multi_reg_write(regmap, cs35l41_safe_to_active,
-						     ARRAY_SIZE(cs35l41_safe_to_active));
-		else
-			ret = regmap_multi_reg_write(regmap, cs35l41_active_to_safe,
-						     ARRAY_SIZE(cs35l41_active_to_safe));
-		break;
-	default:
-		ret = -EINVAL;
-		break;
-	}
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(cs35l41_global_enable);
-
-int cs35l41_gpio_config(struct regmap *regmap, struct cs35l41_hw_cfg *hw_cfg)
-{
-	struct cs35l41_gpio_cfg *gpio1 = &hw_cfg->gpio1;
-	struct cs35l41_gpio_cfg *gpio2 = &hw_cfg->gpio2;
-	int irq_pol = IRQF_TRIGGER_NONE;
-
-	regmap_update_bits(regmap, CS35L41_GPIO1_CTRL1,
-			   CS35L41_GPIO_POL_MASK | CS35L41_GPIO_DIR_MASK,
-			   gpio1->pol_inv << CS35L41_GPIO_POL_SHIFT |
-			   !gpio1->out_en << CS35L41_GPIO_DIR_SHIFT);
-
-	regmap_update_bits(regmap, CS35L41_GPIO2_CTRL1,
-			   CS35L41_GPIO_POL_MASK | CS35L41_GPIO_DIR_MASK,
-			   gpio2->pol_inv << CS35L41_GPIO_POL_SHIFT |
-			   !gpio2->out_en << CS35L41_GPIO_DIR_SHIFT);
-
-	if (gpio1->valid)
-		regmap_update_bits(regmap, CS35L41_GPIO_PAD_CONTROL, CS35L41_GPIO1_CTRL_MASK,
-				   gpio1->func << CS35L41_GPIO1_CTRL_SHIFT);
-
-	if (gpio2->valid) {
-		regmap_update_bits(regmap, CS35L41_GPIO_PAD_CONTROL, CS35L41_GPIO2_CTRL_MASK,
-				   gpio2->func << CS35L41_GPIO2_CTRL_SHIFT);
-
-		switch (gpio2->func) {
-		case CS35L41_GPIO2_INT_PUSH_PULL_LOW:
-		case CS35L41_GPIO2_INT_OPEN_DRAIN:
-			irq_pol = IRQF_TRIGGER_LOW;
-			break;
-		case CS35L41_GPIO2_INT_PUSH_PULL_HIGH:
-			irq_pol = IRQF_TRIGGER_HIGH;
-			break;
-		default:
-			break;
-		}
-	}
-
-	return irq_pol;
-}
-EXPORT_SYMBOL_GPL(cs35l41_gpio_config);
-
-static const struct cs_dsp_region cs35l41_dsp1_regions[] = {
-	{ .type = WMFW_HALO_PM_PACKED,	.base = CS35L41_DSP1_PMEM_0 },
-	{ .type = WMFW_HALO_XM_PACKED,	.base = CS35L41_DSP1_XMEM_PACK_0 },
-	{ .type = WMFW_HALO_YM_PACKED,	.base = CS35L41_DSP1_YMEM_PACK_0 },
-	{. type = WMFW_ADSP2_XM,	.base = CS35L41_DSP1_XMEM_UNPACK24_0},
-	{. type = WMFW_ADSP2_YM,	.base = CS35L41_DSP1_YMEM_UNPACK24_0},
-};
-
-void cs35l41_configure_cs_dsp(struct device *dev, struct regmap *reg, struct cs_dsp *dsp)
-{
-	dsp->num = 1;
-	dsp->type = WMFW_HALO;
-	dsp->rev = 0;
-	dsp->dev = dev;
-	dsp->regmap = reg;
-	dsp->base = CS35L41_DSP1_CTRL_BASE;
-	dsp->base_sysinfo = CS35L41_DSP1_SYS_ID;
-	dsp->mem = cs35l41_dsp1_regions;
-	dsp->num_mems = ARRAY_SIZE(cs35l41_dsp1_regions);
-	dsp->lock_regions = 0xFFFFFFFF;
-}
-EXPORT_SYMBOL_GPL(cs35l41_configure_cs_dsp);
-
-static bool cs35l41_check_cspl_mbox_sts(enum cs35l41_cspl_mbox_cmd cmd,
-					enum cs35l41_cspl_mbox_status sts)
-{
-	switch (cmd) {
-	case CSPL_MBOX_CMD_NONE:
-	case CSPL_MBOX_CMD_UNKNOWN_CMD:
-		return true;
-	case CSPL_MBOX_CMD_PAUSE:
-	case CSPL_MBOX_CMD_OUT_OF_HIBERNATE:
-		return (sts == CSPL_MBOX_STS_PAUSED);
-	case CSPL_MBOX_CMD_RESUME:
-		return (sts == CSPL_MBOX_STS_RUNNING);
-	case CSPL_MBOX_CMD_REINIT:
-		return (sts == CSPL_MBOX_STS_RUNNING);
-	case CSPL_MBOX_CMD_STOP_PRE_REINIT:
-		return (sts == CSPL_MBOX_STS_RDY_FOR_REINIT);
-	default:
-		return false;
-	}
-}
-
-int cs35l41_set_cspl_mbox_cmd(struct device *dev, struct regmap *regmap,
-			      enum cs35l41_cspl_mbox_cmd cmd)
-{
-	unsigned int sts = 0, i;
-	int ret;
-
-	// Set mailbox cmd
-	ret = regmap_write(regmap, CS35L41_DSP_VIRT1_MBOX_1, cmd);
-	if (ret < 0) {
-		if (cmd != CSPL_MBOX_CMD_OUT_OF_HIBERNATE)
-			dev_err(dev, "Failed to write MBOX: %d\n", ret);
-		return ret;
-	}
-
-	// Read mailbox status and verify it is appropriate for the given cmd
-	for (i = 0; i < 5; i++) {
-		usleep_range(1000, 1100);
-
-		ret = regmap_read(regmap, CS35L41_DSP_MBOX_2, &sts);
-		if (ret < 0) {
-			dev_err(dev, "Failed to read MBOX STS: %d\n", ret);
-			continue;
-		}
-
-		if (!cs35l41_check_cspl_mbox_sts(cmd, sts))
-			dev_dbg(dev, "[%u] cmd %u returned invalid sts %u", i, cmd, sts);
-		else
-			return 0;
-	}
-
-	if (cmd != CSPL_MBOX_CMD_OUT_OF_HIBERNATE)
-		dev_err(dev, "Failed to set mailbox cmd %u (status %u)\n", cmd, sts);
-
-	return -ENOMSG;
-}
-EXPORT_SYMBOL_GPL(cs35l41_set_cspl_mbox_cmd);
-
-int cs35l41_write_fs_errata(struct device *dev, struct regmap *regmap)
-{
-	int ret;
-
-	ret = regmap_multi_reg_write(regmap, cs35l41_fs_errata_patch,
-				     ARRAY_SIZE(cs35l41_fs_errata_patch));
-	if (ret < 0)
-		dev_err(dev, "Failed to write fs errata: %d\n", ret);
-
-	return ret;
-}
-EXPORT_SYMBOL_GPL(cs35l41_write_fs_errata);
-
-int cs35l41_enter_hibernate(struct device *dev, struct regmap *regmap,
-			    enum cs35l41_boost_type b_type)
-{
-	if (!cs35l41_safe_reset(regmap, b_type)) {
-		dev_dbg(dev, "System does not support Suspend\n");
-		return -EINVAL;
-	}
-
-	dev_dbg(dev, "Enter hibernate\n");
-	regmap_write(regmap, CS35L41_WAKESRC_CTL, 0x0088);
-	regmap_write(regmap, CS35L41_WAKESRC_CTL, 0x0188);
-
-	// Don't wait for ACK since bus activity would wake the device
-	regmap_write(regmap, CS35L41_DSP_VIRT1_MBOX_1, CSPL_MBOX_CMD_HIBERNATE);
-
-	return 0;
-}
-EXPORT_SYMBOL_GPL(cs35l41_enter_hibernate);
-
-static void cs35l41_wait_for_pwrmgt_sts(struct device *dev, struct regmap *regmap)
-{
-	const int pwrmgt_retries = 10;
-	unsigned int sts;
-	int i, ret;
-
-	for (i = 0; i < pwrmgt_retries; i++) {
-		ret = regmap_read(regmap, CS35L41_PWRMGT_STS, &sts);
-		if (ret)
-			dev_err(dev, "Failed to read PWRMGT_STS: %d\n", ret);
-		else if (!(sts & CS35L41_WR_PEND_STS_MASK))
-			return;
-
-		udelay(20);
-	}
-
-	dev_err(dev, "Timed out reading PWRMGT_STS\n");
-}
-
-int cs35l41_exit_hibernate(struct device *dev, struct regmap *regmap)
-{
-	const int wake_retries = 20;
-	const int sleep_retries = 5;
-	int ret, i, j;
-
-	for (i = 0; i < sleep_retries; i++) {
-		dev_dbg(dev, "Exit hibernate\n");
-
-		for (j = 0; j < wake_retries; j++) {
-			ret = cs35l41_set_cspl_mbox_cmd(dev, regmap,
-							CSPL_MBOX_CMD_OUT_OF_HIBERNATE);
-			if (!ret)
-				break;
-
-			usleep_range(100, 200);
-		}
-
-		if (j < wake_retries) {
-			dev_dbg(dev, "Wake success at cycle: %d\n", j);
-			return 0;
-		}
-
-		dev_err(dev, "Wake failed, re-enter hibernate: %d\n", ret);
-
-		cs35l41_wait_for_pwrmgt_sts(dev, regmap);
-		regmap_write(regmap, CS35L41_WAKESRC_CTL, 0x0088);
-
-		cs35l41_wait_for_pwrmgt_sts(dev, regmap);
-		regmap_write(regmap, CS35L41_WAKESRC_CTL, 0x0188);
-
-		cs35l41_wait_for_pwrmgt_sts(dev, regmap);
-		regmap_write(regmap, CS35L41_PWRMGT_CTL, 0x3);
-	}
-
-	dev_err(dev, "Timed out waking device\n");
-
-	return -ETIMEDOUT;
-}
-EXPORT_SYMBOL_GPL(cs35l41_exit_hibernate);
-
-MODULE_DESCRIPTION("CS35L41 library");
-MODULE_AUTHOR("David Rhodes, Cirrus Logic Inc, <david.rhodes@cirrus.com>");
-MODULE_AUTHOR("Lucas Tanure, Cirrus Logic Inc, <tanureal@opensource.cirrus.com>");
-MODULE_LICENSE("GPL");
diff -ruN a/sound/soc/codecs/cs35l41-spi.c b/sound/soc/codecs/cs35l41-spi.c
--- a/sound/soc/codecs/cs35l41-spi.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/codecs/cs35l41-spi.c	2022-07-08 01:12:12.000000000 +0200
@@ -1,27 +1,54 @@
 // SPDX-License-Identifier: GPL-2.0
-//
-// cs35l41-spi.c -- CS35l41 SPI driver
-//
-// Copyright 2017-2021 Cirrus Logic, Inc.
-//
-// Author: David Rhodes	<david.rhodes@cirrus.com>
 
-#include <linux/acpi.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
+/*
+ * cs35l41-spi.c -- CS35l41 SPI driver
+ *
+ * Copyright 2017-2020 Cirrus Logic, Inc.
+ *
+ * Author:	David Rhodes	<david.rhodes@cirrus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
 #include <linux/module.h>
 #include <linux/moduleparam.h>
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
 #include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/gpio.h>
 #include <linux/spi/spi.h>
+#include <linux/regulator/consumer.h>
+#include <linux/acpi.h>
 
+#include "wm_adsp.h"
 #include "cs35l41.h"
+#include <sound/cs35l41.h>
+
+static struct regmap_config cs35l41_regmap_spi = {
+	.reg_bits = 32,
+	.val_bits = 32,
+	.pad_bits = 16,
+	.reg_stride = 4,
+	.reg_format_endian = REGMAP_ENDIAN_BIG,
+	.val_format_endian = REGMAP_ENDIAN_BIG,
+	.max_register = CS35L41_LASTREG,
+	.reg_defaults = cs35l41_reg,
+	.num_reg_defaults = ARRAY_SIZE(cs35l41_reg),
+	.volatile_reg = cs35l41_volatile_reg,
+	.readable_reg = cs35l41_readable_reg,
+	.precious_reg = cs35l41_precious_reg,
+	.cache_type = REGCACHE_RBTREE,
+};
 
 static const struct spi_device_id cs35l41_id_spi[] = {
-	{ "cs35l40", 0 },
-	{ "cs35l41", 0 },
-	{ "cs35l51", 0 },
-	{ "cs35l53", 0 },
+	{"cs35l40", 0},
+	{"cs35l41", 0},
 	{}
 };
 
@@ -30,12 +57,15 @@
 static int cs35l41_spi_probe(struct spi_device *spi)
 {
 	const struct regmap_config *regmap_config = &cs35l41_regmap_spi;
-	struct cs35l41_hw_cfg *hw_cfg = dev_get_platdata(&spi->dev);
+	struct cs35l41_platform_data *pdata =
+					dev_get_platdata(&spi->dev);
 	struct cs35l41_private *cs35l41;
 	int ret;
 
-	cs35l41 = devm_kzalloc(&spi->dev, sizeof(struct cs35l41_private), GFP_KERNEL);
-	if (!cs35l41)
+	cs35l41 = devm_kzalloc(&spi->dev,
+			       sizeof(struct cs35l41_private),
+			       GFP_KERNEL);
+	if (cs35l41 == NULL)
 		return -ENOMEM;
 
 	spi->max_speed_hz = CS35L41_SPI_MAX_FREQ;
@@ -45,27 +75,29 @@
 	cs35l41->regmap = devm_regmap_init_spi(spi, regmap_config);
 	if (IS_ERR(cs35l41->regmap)) {
 		ret = PTR_ERR(cs35l41->regmap);
-		dev_err(&spi->dev, "Failed to allocate register map: %d\n", ret);
+		dev_err(&spi->dev, "Failed to allocate register map: %d\n",
+			ret);
 		return ret;
 	}
 
 	cs35l41->dev = &spi->dev;
 	cs35l41->irq = spi->irq;
+	cs35l41->bus_spi = true;
 
-	return cs35l41_probe(cs35l41, hw_cfg);
+	return cs35l41_probe(cs35l41, pdata);
 }
 
 static void cs35l41_spi_remove(struct spi_device *spi)
 {
 	struct cs35l41_private *cs35l41 = spi_get_drvdata(spi);
 
 	cs35l41_remove(cs35l41);
 }
 
 #ifdef CONFIG_OF
 static const struct of_device_id cs35l41_of_match[] = {
-	{ .compatible = "cirrus,cs35l40" },
-	{ .compatible = "cirrus,cs35l41" },
+	{.compatible = "cirrus,cs35l40"},
+	{.compatible = "cirrus,cs35l41"},
 	{},
 };
 MODULE_DEVICE_TABLE(of, cs35l41_of_match);
@@ -73,8 +105,7 @@
 
 #ifdef CONFIG_ACPI
 static const struct acpi_device_id cs35l41_acpi_match[] = {
-	{ "CSC3541", 0 }, /* Cirrus Logic PnP ID + part ID */
-	{ "CLSA3541", 0 }, /* Cirrus Logic PnP ID + part ID */
+	{ "CLSA3541", 0 }, /* Cirrus Logic PCI ID + part ID */
 	{},
 };
 MODULE_DEVICE_TABLE(acpi, cs35l41_acpi_match);
@@ -83,7 +114,6 @@
 static struct spi_driver cs35l41_spi_driver = {
 	.driver = {
 		.name		= "cs35l41",
-		.pm		= &cs35l41_pm_ops,
 		.of_match_table = of_match_ptr(cs35l41_of_match),
 		.acpi_match_table = ACPI_PTR(cs35l41_acpi_match),
 	},
diff -ruN a/sound/soc/codecs/cs35l41-tables.c b/sound/soc/codecs/cs35l41-tables.c
--- a/sound/soc/codecs/cs35l41-tables.c	1970-01-01 01:00:00.000000000 +0100
+++ b/sound/soc/codecs/cs35l41-tables.c	2022-07-08 01:12:12.000000000 +0200
@@ -0,0 +1,1006 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/*
+ * cs35l41-tables.c -- CS35L41 ALSA SoC audio driver
+ *
+ * Copyright 2017-2020 Cirrus Logic, Inc.
+ *
+ * Author: Brian Austin <brian.austin@cirrus.com>
+ *         David Rhodes <david.rhodes@cirrus.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include "cs35l41.h"
+
+const struct reg_default cs35l41_reg[CS35L41_MAX_CACHE_REG] = {
+	{CS35L41_TEST_KEY_CTL,			0x00000000},
+	{CS35L41_USER_KEY_CTL,			0x00000000},
+	{CS35L41_OTP_CTRL0,			0x00006418},
+	{CS35L41_OTP_CTRL1,			0x00000000},
+	{CS35L41_OTP_CTRL3,			0x00000000},
+	{CS35L41_OTP_CTRL4,			0x00000000},
+	{CS35L41_OTP_CTRL5,			0x00000030},
+	{CS35L41_OTP_CTRL6,			0x00000000},
+	{CS35L41_OTP_CTRL7,			0x00000000},
+	{CS35L41_OTP_CTRL8,			0x00000000},
+	{CS35L41_PWR_CTRL1,			0x00000000},
+	{CS35L41_PWR_CTRL3,			0x01000010},
+	{CS35L41_CTRL_OVRRIDE,			0x00000002},
+	{CS35L41_AMP_OUT_MUTE,			0x00000000},
+	{CS35L41_PROTECT_REL_ERR_IGN,		0x00000000},
+	{CS35L41_GPIO_PAD_CONTROL,		0x00000000},
+	{CS35L41_JTAG_CONTROL,			0x00000000},
+	{CS35L41_PLL_CLK_CTRL,			0x00000010},
+	{CS35L41_DSP_CLK_CTRL,			0x00000003},
+	{CS35L41_GLOBAL_CLK_CTRL,		0x00000003},
+	{CS35L41_DATA_FS_SEL,			0x00000000},
+	{CS35L41_MDSYNC_EN,			0x00000200},
+	{CS35L41_MDSYNC_TX_ID,			0x00000000},
+	{CS35L41_MDSYNC_PWR_CTRL,		0x00000002},
+	{CS35L41_MDSYNC_DATA_TX,		0x00000000},
+	{CS35L41_MDSYNC_TX_STATUS,		0x00000002},
+	{CS35L41_MDSYNC_DATA_RX,		0x00000000},
+	{CS35L41_MDSYNC_RX_STATUS,		0x00000002},
+	{CS35L41_MDSYNC_ERR_STATUS,		0x00000000},
+	{CS35L41_MDSYNC_SYNC_PTE2,		0x00000000},
+	{CS35L41_MDSYNC_SYNC_PTE3,		0x00000000},
+	{CS35L41_MDSYNC_SYNC_MSM_STATUS,	0x00000000},
+	{CS35L41_BSTCVRT_VCTRL1,		0x00000000},
+	{CS35L41_BSTCVRT_VCTRL2,		0x00000001},
+	{CS35L41_BSTCVRT_PEAK_CUR,		0x0000004A},
+	{CS35L41_BSTCVRT_SFT_RAMP,		0x00000003},
+	{CS35L41_BSTCVRT_COEFF,			0x00002424},
+	{CS35L41_BSTCVRT_SLOPE_LBST,		0x00007500},
+	{CS35L41_BSTCVRT_SW_FREQ,		0x01008000},
+	{CS35L41_BSTCVRT_DCM_CTRL,		0x00002001},
+	{CS35L41_BSTCVRT_DCM_MODE_FORCE,	0x00000000},
+	{CS35L41_BSTCVRT_OVERVOLT_CTRL,		0x00000130},
+	{CS35L41_VI_VOL_POL,			0x08000800},
+	{CS35L41_DTEMP_WARN_THLD,		0x00000002},
+	{CS35L41_DTEMP_EN,			0x00000000},
+	{CS35L41_VPVBST_FS_SEL,			0x00000001},
+	{CS35L41_SP_ENABLES,			0x00000000},
+	{CS35L41_SP_RATE_CTRL,			0x00000028},
+	{CS35L41_SP_FORMAT,			0x18180200},
+	{CS35L41_SP_HIZ_CTRL,			0x00000002},
+	{CS35L41_SP_FRAME_TX_SLOT,		0x03020100},
+	{CS35L41_SP_FRAME_RX_SLOT,		0x00000100},
+	{CS35L41_SP_TX_WL,			0x00000018},
+	{CS35L41_SP_RX_WL,			0x00000018},
+	{CS35L41_DAC_PCM1_SRC,			0x00000008},
+	{CS35L41_ASP_TX1_SRC,			0x00000018},
+	{CS35L41_ASP_TX2_SRC,			0x00000019},
+	{CS35L41_ASP_TX3_SRC,			0x00000020},
+	{CS35L41_ASP_TX4_SRC,			0x00000021},
+	{CS35L41_DSP1_RX1_SRC,			0x00000008},
+	{CS35L41_DSP1_RX2_SRC,			0x00000009},
+	{CS35L41_DSP1_RX3_SRC,			0x00000018},
+	{CS35L41_DSP1_RX4_SRC,			0x00000019},
+	{CS35L41_DSP1_RX5_SRC,			0x00000020},
+	{CS35L41_DSP1_RX6_SRC,			0x00000021},
+	{CS35L41_DSP1_RX7_SRC,			0x0000003A},
+	{CS35L41_DSP1_RX8_SRC,			0x00000001},
+	{CS35L41_NGATE1_SRC,			0x00000008},
+	{CS35L41_NGATE2_SRC,			0x00000009},
+	{CS35L41_AMP_DIG_VOL_CTRL,		0x00008000},
+	{CS35L41_VPBR_CFG,			0x02AA1905},
+	{CS35L41_VBBR_CFG,			0x02AA1905},
+	{CS35L41_VPBR_STATUS,			0x00000000},
+	{CS35L41_VBBR_STATUS,			0x00000000},
+	{CS35L41_OVERTEMP_CFG,			0x00000001},
+	{CS35L41_AMP_ERR_VOL,			0x00000000},
+	{CS35L41_VOL_STATUS_TO_DSP,		0x00000000},
+	{CS35L41_CLASSH_CFG,			0x000B0405},
+	{CS35L41_WKFET_CFG,			0x00000111},
+	{CS35L41_NG_CFG,			0x00000033},
+	{CS35L41_AMP_GAIN_CTRL,			0x00000273},
+	{CS35L41_DAC_MSM_CFG,			0x00580000},
+	{CS35L41_GPIO1_CTRL1,			0xE1000001},
+	{CS35L41_GPIO2_CTRL1,			0xE1000001},
+	{CS35L41_MIXER_NGATE_CFG,		0x00000000},
+	{CS35L41_MIXER_NGATE_CH1_CFG,		0x00000303},
+	{CS35L41_MIXER_NGATE_CH2_CFG,		0x00000303},
+	{CS35L41_CLOCK_DETECT_1,		0x00000000},
+	{CS35L41_TIMER1_CONTROL,		0x00000000},
+	{CS35L41_TIMER1_COUNT_PRESET,		0x00000000},
+	{CS35L41_TIMER1_START_STOP,		0x00000000},
+	{CS35L41_TIMER1_STATUS,			0x00000000},
+	{CS35L41_TIMER1_COUNT_READBACK,		0x00000000},
+	{CS35L41_TIMER1_DSP_CLK_CFG,		0x00000000},
+	{CS35L41_TIMER1_DSP_CLK_STATUS,		0x00000000},
+	{CS35L41_TIMER2_CONTROL,		0x00000000},
+	{CS35L41_TIMER2_COUNT_PRESET,		0x00000000},
+	{CS35L41_TIMER2_START_STOP,		0x00000000},
+	{CS35L41_TIMER2_STATUS,			0x00000000},
+	{CS35L41_TIMER2_COUNT_READBACK,		0x00000000},
+	{CS35L41_TIMER2_DSP_CLK_CFG,		0x00000000},
+	{CS35L41_TIMER2_DSP_CLK_STATUS,		0x00000000},
+	{CS35L41_DFT_JTAG_CONTROL,		0x00000000},
+	{CS35L41_DIE_STS1,			0x00000000},
+	{CS35L41_DIE_STS2,			0x00000000},
+	{CS35L41_TEMP_CAL1,			0x00000000},
+	{CS35L41_TEMP_CAL2,			0x00000000},
+};
+
+bool cs35l41_readable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case CS35L41_DEVID:
+	case CS35L41_REVID:
+	case CS35L41_FABID:
+	case CS35L41_RELID:
+	case CS35L41_OTPID:
+	case CS35L41_TEST_KEY_CTL:
+	case CS35L41_USER_KEY_CTL:
+	case CS35L41_OTP_CTRL0:
+	case CS35L41_OTP_CTRL3:
+	case CS35L41_OTP_CTRL4:
+	case CS35L41_OTP_CTRL5:
+	case CS35L41_OTP_CTRL6:
+	case CS35L41_OTP_CTRL7:
+	case CS35L41_OTP_CTRL8:
+	case CS35L41_PWR_CTRL1:
+	case CS35L41_PWR_CTRL2:
+	case CS35L41_PWR_CTRL3:
+	case CS35L41_CTRL_OVRRIDE:
+	case CS35L41_AMP_OUT_MUTE:
+	case CS35L41_PROTECT_REL_ERR_IGN:
+	case CS35L41_GPIO_PAD_CONTROL:
+	case CS35L41_JTAG_CONTROL:
+	case CS35L41_PWRMGT_CTL:
+	case CS35L41_WAKESRC_CTL:
+	case CS35L41_PWRMGT_STS:
+	case CS35L41_PLL_CLK_CTRL:
+	case CS35L41_DSP_CLK_CTRL:
+	case CS35L41_GLOBAL_CLK_CTRL:
+	case CS35L41_DATA_FS_SEL:
+	case CS35L41_MDSYNC_EN:
+	case CS35L41_MDSYNC_TX_ID:
+	case CS35L41_MDSYNC_PWR_CTRL:
+	case CS35L41_MDSYNC_DATA_TX:
+	case CS35L41_MDSYNC_TX_STATUS:
+	case CS35L41_MDSYNC_DATA_RX:
+	case CS35L41_MDSYNC_RX_STATUS:
+	case CS35L41_MDSYNC_ERR_STATUS:
+	case CS35L41_MDSYNC_SYNC_PTE2:
+	case CS35L41_MDSYNC_SYNC_PTE3:
+	case CS35L41_MDSYNC_SYNC_MSM_STATUS:
+	case CS35L41_BSTCVRT_VCTRL1:
+	case CS35L41_BSTCVRT_VCTRL2:
+	case CS35L41_BSTCVRT_PEAK_CUR:
+	case CS35L41_BSTCVRT_SFT_RAMP:
+	case CS35L41_BSTCVRT_COEFF:
+	case CS35L41_BSTCVRT_SLOPE_LBST:
+	case CS35L41_BSTCVRT_SW_FREQ:
+	case CS35L41_BSTCVRT_DCM_CTRL:
+	case CS35L41_BSTCVRT_DCM_MODE_FORCE:
+	case CS35L41_BSTCVRT_OVERVOLT_CTRL:
+	case CS35L41_VI_VOL_POL:
+	case CS35L41_DTEMP_WARN_THLD:
+	case CS35L41_DTEMP_CFG:
+	case CS35L41_DTEMP_EN:
+	case CS35L41_VPVBST_FS_SEL:
+	case CS35L41_SP_ENABLES:
+	case CS35L41_SP_RATE_CTRL:
+	case CS35L41_SP_FORMAT:
+	case CS35L41_SP_HIZ_CTRL:
+	case CS35L41_SP_FRAME_TX_SLOT:
+	case CS35L41_SP_FRAME_RX_SLOT:
+	case CS35L41_SP_TX_WL:
+	case CS35L41_SP_RX_WL:
+	case CS35L41_DAC_PCM1_SRC:
+	case CS35L41_ASP_TX1_SRC:
+	case CS35L41_ASP_TX2_SRC:
+	case CS35L41_ASP_TX3_SRC:
+	case CS35L41_ASP_TX4_SRC:
+	case CS35L41_DSP1_RX1_SRC:
+	case CS35L41_DSP1_RX2_SRC:
+	case CS35L41_DSP1_RX3_SRC:
+	case CS35L41_DSP1_RX4_SRC:
+	case CS35L41_DSP1_RX5_SRC:
+	case CS35L41_DSP1_RX6_SRC:
+	case CS35L41_DSP1_RX7_SRC:
+	case CS35L41_DSP1_RX8_SRC:
+	case CS35L41_NGATE1_SRC:
+	case CS35L41_NGATE2_SRC:
+	case CS35L41_AMP_DIG_VOL_CTRL:
+	case CS35L41_VPBR_CFG:
+	case CS35L41_VBBR_CFG:
+	case CS35L41_VPBR_STATUS:
+	case CS35L41_VBBR_STATUS:
+	case CS35L41_OVERTEMP_CFG:
+	case CS35L41_AMP_ERR_VOL:
+	case CS35L41_VOL_STATUS_TO_DSP:
+	case CS35L41_CLASSH_CFG:
+	case CS35L41_WKFET_CFG:
+	case CS35L41_NG_CFG:
+	case CS35L41_AMP_GAIN_CTRL:
+	case CS35L41_DAC_MSM_CFG:
+	case CS35L41_IRQ1_CFG:
+	case CS35L41_IRQ1_STATUS:
+	case CS35L41_IRQ1_STATUS1:
+	case CS35L41_IRQ1_STATUS2:
+	case CS35L41_IRQ1_STATUS3:
+	case CS35L41_IRQ1_STATUS4:
+	case CS35L41_IRQ1_RAW_STATUS1:
+	case CS35L41_IRQ1_RAW_STATUS2:
+	case CS35L41_IRQ1_RAW_STATUS3:
+	case CS35L41_IRQ1_RAW_STATUS4:
+	case CS35L41_IRQ1_MASK1:
+	case CS35L41_IRQ1_MASK2:
+	case CS35L41_IRQ1_MASK3:
+	case CS35L41_IRQ1_MASK4:
+	case CS35L41_IRQ1_FRC1:
+	case CS35L41_IRQ1_FRC2:
+	case CS35L41_IRQ1_FRC3:
+	case CS35L41_IRQ1_FRC4:
+	case CS35L41_IRQ1_EDGE1:
+	case CS35L41_IRQ1_EDGE4:
+	case CS35L41_IRQ1_POL1:
+	case CS35L41_IRQ1_POL2:
+	case CS35L41_IRQ1_POL3:
+	case CS35L41_IRQ1_POL4:
+	case CS35L41_IRQ1_DB3:
+	case CS35L41_IRQ2_CFG:
+	case CS35L41_IRQ2_STATUS:
+	case CS35L41_IRQ2_STATUS1:
+	case CS35L41_IRQ2_STATUS2:
+	case CS35L41_IRQ2_STATUS3:
+	case CS35L41_IRQ2_STATUS4:
+	case CS35L41_IRQ2_RAW_STATUS1:
+	case CS35L41_IRQ2_RAW_STATUS2:
+	case CS35L41_IRQ2_RAW_STATUS3:
+	case CS35L41_IRQ2_RAW_STATUS4:
+	case CS35L41_IRQ2_MASK1:
+	case CS35L41_IRQ2_MASK2:
+	case CS35L41_IRQ2_MASK3:
+	case CS35L41_IRQ2_MASK4:
+	case CS35L41_IRQ2_FRC1:
+	case CS35L41_IRQ2_FRC2:
+	case CS35L41_IRQ2_FRC3:
+	case CS35L41_IRQ2_FRC4:
+	case CS35L41_IRQ2_EDGE1:
+	case CS35L41_IRQ2_EDGE4:
+	case CS35L41_IRQ2_POL1:
+	case CS35L41_IRQ2_POL2:
+	case CS35L41_IRQ2_POL3:
+	case CS35L41_IRQ2_POL4:
+	case CS35L41_IRQ2_DB3:
+	case CS35L41_GPIO_STATUS1:
+	case CS35L41_GPIO1_CTRL1:
+	case CS35L41_GPIO2_CTRL1:
+	case CS35L41_MIXER_NGATE_CFG:
+	case CS35L41_MIXER_NGATE_CH1_CFG:
+	case CS35L41_MIXER_NGATE_CH2_CFG:
+	case CS35L41_DSP_MBOX_1 ... CS35L41_DSP_VIRT2_MBOX_8:
+	case CS35L41_CLOCK_DETECT_1:
+	case CS35L41_TIMER1_CONTROL:
+	case CS35L41_TIMER1_COUNT_PRESET:
+	case CS35L41_TIMER1_STATUS:
+	case CS35L41_TIMER1_COUNT_READBACK:
+	case CS35L41_TIMER1_DSP_CLK_CFG:
+	case CS35L41_TIMER1_DSP_CLK_STATUS:
+	case CS35L41_TIMER2_CONTROL:
+	case CS35L41_TIMER2_COUNT_PRESET:
+	case CS35L41_TIMER2_STATUS:
+	case CS35L41_TIMER2_COUNT_READBACK:
+	case CS35L41_TIMER2_DSP_CLK_CFG:
+	case CS35L41_TIMER2_DSP_CLK_STATUS:
+	case CS35L41_DFT_JTAG_CONTROL:
+	case CS35L41_DIE_STS1:
+	case CS35L41_DIE_STS2:
+	case CS35L41_TEMP_CAL1:
+	case CS35L41_TEMP_CAL2:
+	case CS35L41_DSP1_TIMESTAMP_COUNT:
+	case CS35L41_DSP1_SYS_ID:
+	case CS35L41_DSP1_SYS_VERSION:
+	case CS35L41_DSP1_SYS_CORE_ID:
+	case CS35L41_DSP1_SYS_AHB_ADDR:
+	case CS35L41_DSP1_SYS_XSRAM_SIZE:
+	case CS35L41_DSP1_SYS_YSRAM_SIZE:
+	case CS35L41_DSP1_SYS_PSRAM_SIZE:
+	case CS35L41_DSP1_SYS_PM_BOOT_SIZE:
+	case CS35L41_DSP1_SYS_FEATURES:
+	case CS35L41_DSP1_SYS_FIR_FILTERS:
+	case CS35L41_DSP1_SYS_LMS_FILTERS:
+	case CS35L41_DSP1_SYS_XM_BANK_SIZE:
+	case CS35L41_DSP1_SYS_YM_BANK_SIZE:
+	case CS35L41_DSP1_SYS_PM_BANK_SIZE:
+	case CS35L41_DSP1_AHBM_WIN0_CTRL0:
+	case CS35L41_DSP1_AHBM_WIN0_CTRL1:
+	case CS35L41_DSP1_AHBM_WIN1_CTRL0:
+	case CS35L41_DSP1_AHBM_WIN1_CTRL1:
+	case CS35L41_DSP1_AHBM_WIN2_CTRL0:
+	case CS35L41_DSP1_AHBM_WIN2_CTRL1:
+	case CS35L41_DSP1_AHBM_WIN3_CTRL0:
+	case CS35L41_DSP1_AHBM_WIN3_CTRL1:
+	case CS35L41_DSP1_AHBM_WIN4_CTRL0:
+	case CS35L41_DSP1_AHBM_WIN4_CTRL1:
+	case CS35L41_DSP1_AHBM_WIN5_CTRL0:
+	case CS35L41_DSP1_AHBM_WIN5_CTRL1:
+	case CS35L41_DSP1_AHBM_WIN6_CTRL0:
+	case CS35L41_DSP1_AHBM_WIN6_CTRL1:
+	case CS35L41_DSP1_AHBM_WIN7_CTRL0:
+	case CS35L41_DSP1_AHBM_WIN7_CTRL1:
+	case CS35L41_DSP1_AHBM_WIN_DBG_CTRL0:
+	case CS35L41_DSP1_AHBM_WIN_DBG_CTRL1:
+	case CS35L41_DSP1_DEBUG:
+	case CS35L41_DSP1_TIMER_CTRL:
+	case CS35L41_DSP1_RX1_RATE:
+	case CS35L41_DSP1_RX2_RATE:
+	case CS35L41_DSP1_RX3_RATE:
+	case CS35L41_DSP1_RX4_RATE:
+	case CS35L41_DSP1_RX5_RATE:
+	case CS35L41_DSP1_RX6_RATE:
+	case CS35L41_DSP1_RX7_RATE:
+	case CS35L41_DSP1_RX8_RATE:
+	case CS35L41_DSP1_TX1_RATE:
+	case CS35L41_DSP1_TX2_RATE:
+	case CS35L41_DSP1_TX3_RATE:
+	case CS35L41_DSP1_TX4_RATE:
+	case CS35L41_DSP1_TX5_RATE:
+	case CS35L41_DSP1_TX6_RATE:
+	case CS35L41_DSP1_TX7_RATE:
+	case CS35L41_DSP1_TX8_RATE:
+	case CS35L41_DSP1_NMI_CTRL1:
+	case CS35L41_DSP1_NMI_CTRL2:
+	case CS35L41_DSP1_NMI_CTRL3:
+	case CS35L41_DSP1_NMI_CTRL4:
+	case CS35L41_DSP1_NMI_CTRL5:
+	case CS35L41_DSP1_NMI_CTRL6:
+	case CS35L41_DSP1_NMI_CTRL7:
+	case CS35L41_DSP1_NMI_CTRL8:
+	case CS35L41_DSP1_RESUME_CTRL:
+	case CS35L41_DSP1_IRQ1_CTRL:
+	case CS35L41_DSP1_IRQ2_CTRL:
+	case CS35L41_DSP1_IRQ3_CTRL:
+	case CS35L41_DSP1_IRQ4_CTRL:
+	case CS35L41_DSP1_IRQ5_CTRL:
+	case CS35L41_DSP1_IRQ6_CTRL:
+	case CS35L41_DSP1_IRQ7_CTRL:
+	case CS35L41_DSP1_IRQ8_CTRL:
+	case CS35L41_DSP1_IRQ9_CTRL:
+	case CS35L41_DSP1_IRQ10_CTRL:
+	case CS35L41_DSP1_IRQ11_CTRL:
+	case CS35L41_DSP1_IRQ12_CTRL:
+	case CS35L41_DSP1_IRQ13_CTRL:
+	case CS35L41_DSP1_IRQ14_CTRL:
+	case CS35L41_DSP1_IRQ15_CTRL:
+	case CS35L41_DSP1_IRQ16_CTRL:
+	case CS35L41_DSP1_IRQ17_CTRL:
+	case CS35L41_DSP1_IRQ18_CTRL:
+	case CS35L41_DSP1_IRQ19_CTRL:
+	case CS35L41_DSP1_IRQ20_CTRL:
+	case CS35L41_DSP1_IRQ21_CTRL:
+	case CS35L41_DSP1_IRQ22_CTRL:
+	case CS35L41_DSP1_IRQ23_CTRL:
+	case CS35L41_DSP1_SCRATCH1:
+	case CS35L41_DSP1_SCRATCH2:
+	case CS35L41_DSP1_SCRATCH3:
+	case CS35L41_DSP1_SCRATCH4:
+	case CS35L41_DSP1_CCM_CORE_CTRL:
+	case CS35L41_DSP1_CCM_CLK_OVERRIDE:
+	case CS35L41_DSP1_XM_MSTR_EN:
+	case CS35L41_DSP1_XM_CORE_PRI:
+	case CS35L41_DSP1_XM_AHB_PACK_PL_PRI:
+	case CS35L41_DSP1_XM_AHB_UP_PL_PRI:
+	case CS35L41_DSP1_XM_ACCEL_PL0_PRI:
+	case CS35L41_DSP1_XM_NPL0_PRI:
+	case CS35L41_DSP1_YM_MSTR_EN:
+	case CS35L41_DSP1_YM_CORE_PRI:
+	case CS35L41_DSP1_YM_AHB_PACK_PL_PRI:
+	case CS35L41_DSP1_YM_AHB_UP_PL_PRI:
+	case CS35L41_DSP1_YM_ACCEL_PL0_PRI:
+	case CS35L41_DSP1_YM_NPL0_PRI:
+	case CS35L41_DSP1_PM_MSTR_EN:
+	case CS35L41_DSP1_PM_PATCH0_ADDR:
+	case CS35L41_DSP1_PM_PATCH0_EN:
+	case CS35L41_DSP1_PM_PATCH0_DATA_LO:
+	case CS35L41_DSP1_PM_PATCH0_DATA_HI:
+	case CS35L41_DSP1_PM_PATCH1_ADDR:
+	case CS35L41_DSP1_PM_PATCH1_EN:
+	case CS35L41_DSP1_PM_PATCH1_DATA_LO:
+	case CS35L41_DSP1_PM_PATCH1_DATA_HI:
+	case CS35L41_DSP1_PM_PATCH2_ADDR:
+	case CS35L41_DSP1_PM_PATCH2_EN:
+	case CS35L41_DSP1_PM_PATCH2_DATA_LO:
+	case CS35L41_DSP1_PM_PATCH2_DATA_HI:
+	case CS35L41_DSP1_PM_PATCH3_ADDR:
+	case CS35L41_DSP1_PM_PATCH3_EN:
+	case CS35L41_DSP1_PM_PATCH3_DATA_LO:
+	case CS35L41_DSP1_PM_PATCH3_DATA_HI:
+	case CS35L41_DSP1_PM_PATCH4_ADDR:
+	case CS35L41_DSP1_PM_PATCH4_EN:
+	case CS35L41_DSP1_PM_PATCH4_DATA_LO:
+	case CS35L41_DSP1_PM_PATCH4_DATA_HI:
+	case CS35L41_DSP1_PM_PATCH5_ADDR:
+	case CS35L41_DSP1_PM_PATCH5_EN:
+	case CS35L41_DSP1_PM_PATCH5_DATA_LO:
+	case CS35L41_DSP1_PM_PATCH5_DATA_HI:
+	case CS35L41_DSP1_PM_PATCH6_ADDR:
+	case CS35L41_DSP1_PM_PATCH6_EN:
+	case CS35L41_DSP1_PM_PATCH6_DATA_LO:
+	case CS35L41_DSP1_PM_PATCH6_DATA_HI:
+	case CS35L41_DSP1_PM_PATCH7_ADDR:
+	case CS35L41_DSP1_PM_PATCH7_EN:
+	case CS35L41_DSP1_PM_PATCH7_DATA_LO:
+	case CS35L41_DSP1_PM_PATCH7_DATA_HI:
+	case CS35L41_DSP1_MPU_XM_ACCESS0:
+	case CS35L41_DSP1_MPU_YM_ACCESS0:
+	case CS35L41_DSP1_MPU_WNDW_ACCESS0:
+	case CS35L41_DSP1_MPU_XREG_ACCESS0:
+	case CS35L41_DSP1_MPU_YREG_ACCESS0:
+	case CS35L41_DSP1_MPU_XM_ACCESS1:
+	case CS35L41_DSP1_MPU_YM_ACCESS1:
+	case CS35L41_DSP1_MPU_WNDW_ACCESS1:
+	case CS35L41_DSP1_MPU_XREG_ACCESS1:
+	case CS35L41_DSP1_MPU_YREG_ACCESS1:
+	case CS35L41_DSP1_MPU_XM_ACCESS2:
+	case CS35L41_DSP1_MPU_YM_ACCESS2:
+	case CS35L41_DSP1_MPU_WNDW_ACCESS2:
+	case CS35L41_DSP1_MPU_XREG_ACCESS2:
+	case CS35L41_DSP1_MPU_YREG_ACCESS2:
+	case CS35L41_DSP1_MPU_XM_ACCESS3:
+	case CS35L41_DSP1_MPU_YM_ACCESS3:
+	case CS35L41_DSP1_MPU_WNDW_ACCESS3:
+	case CS35L41_DSP1_MPU_XREG_ACCESS3:
+	case CS35L41_DSP1_MPU_YREG_ACCESS3:
+	case CS35L41_DSP1_MPU_XM_VIO_ADDR:
+	case CS35L41_DSP1_MPU_XM_VIO_STATUS:
+	case CS35L41_DSP1_MPU_YM_VIO_ADDR:
+	case CS35L41_DSP1_MPU_YM_VIO_STATUS:
+	case CS35L41_DSP1_MPU_PM_VIO_ADDR:
+	case CS35L41_DSP1_MPU_PM_VIO_STATUS:
+	case CS35L41_DSP1_MPU_LOCK_CONFIG:
+	case CS35L41_DSP1_MPU_WDT_RST_CTRL:
+	case CS35L41_DSP1_STRMARB_MSTR0_CFG0:
+	case CS35L41_DSP1_STRMARB_MSTR0_CFG1:
+	case CS35L41_DSP1_STRMARB_MSTR0_CFG2:
+	case CS35L41_DSP1_STRMARB_MSTR1_CFG0:
+	case CS35L41_DSP1_STRMARB_MSTR1_CFG1:
+	case CS35L41_DSP1_STRMARB_MSTR1_CFG2:
+	case CS35L41_DSP1_STRMARB_MSTR2_CFG0:
+	case CS35L41_DSP1_STRMARB_MSTR2_CFG1:
+	case CS35L41_DSP1_STRMARB_MSTR2_CFG2:
+	case CS35L41_DSP1_STRMARB_MSTR3_CFG0:
+	case CS35L41_DSP1_STRMARB_MSTR3_CFG1:
+	case CS35L41_DSP1_STRMARB_MSTR3_CFG2:
+	case CS35L41_DSP1_STRMARB_MSTR4_CFG0:
+	case CS35L41_DSP1_STRMARB_MSTR4_CFG1:
+	case CS35L41_DSP1_STRMARB_MSTR4_CFG2:
+	case CS35L41_DSP1_STRMARB_MSTR5_CFG0:
+	case CS35L41_DSP1_STRMARB_MSTR5_CFG1:
+	case CS35L41_DSP1_STRMARB_MSTR5_CFG2:
+	case CS35L41_DSP1_STRMARB_MSTR6_CFG0:
+	case CS35L41_DSP1_STRMARB_MSTR6_CFG1:
+	case CS35L41_DSP1_STRMARB_MSTR6_CFG2:
+	case CS35L41_DSP1_STRMARB_MSTR7_CFG0:
+	case CS35L41_DSP1_STRMARB_MSTR7_CFG1:
+	case CS35L41_DSP1_STRMARB_MSTR7_CFG2:
+	case CS35L41_DSP1_STRMARB_TX0_CFG0:
+	case CS35L41_DSP1_STRMARB_TX0_CFG1:
+	case CS35L41_DSP1_STRMARB_TX1_CFG0:
+	case CS35L41_DSP1_STRMARB_TX1_CFG1:
+	case CS35L41_DSP1_STRMARB_TX2_CFG0:
+	case CS35L41_DSP1_STRMARB_TX2_CFG1:
+	case CS35L41_DSP1_STRMARB_TX3_CFG0:
+	case CS35L41_DSP1_STRMARB_TX3_CFG1:
+	case CS35L41_DSP1_STRMARB_TX4_CFG0:
+	case CS35L41_DSP1_STRMARB_TX4_CFG1:
+	case CS35L41_DSP1_STRMARB_TX5_CFG0:
+	case CS35L41_DSP1_STRMARB_TX5_CFG1:
+	case CS35L41_DSP1_STRMARB_TX6_CFG0:
+	case CS35L41_DSP1_STRMARB_TX6_CFG1:
+	case CS35L41_DSP1_STRMARB_TX7_CFG0:
+	case CS35L41_DSP1_STRMARB_TX7_CFG1:
+	case CS35L41_DSP1_STRMARB_RX0_CFG0:
+	case CS35L41_DSP1_STRMARB_RX0_CFG1:
+	case CS35L41_DSP1_STRMARB_RX1_CFG0:
+	case CS35L41_DSP1_STRMARB_RX1_CFG1:
+	case CS35L41_DSP1_STRMARB_RX2_CFG0:
+	case CS35L41_DSP1_STRMARB_RX2_CFG1:
+	case CS35L41_DSP1_STRMARB_RX3_CFG0:
+	case CS35L41_DSP1_STRMARB_RX3_CFG1:
+	case CS35L41_DSP1_STRMARB_RX4_CFG0:
+	case CS35L41_DSP1_STRMARB_RX4_CFG1:
+	case CS35L41_DSP1_STRMARB_RX5_CFG0:
+	case CS35L41_DSP1_STRMARB_RX5_CFG1:
+	case CS35L41_DSP1_STRMARB_RX6_CFG0:
+	case CS35L41_DSP1_STRMARB_RX6_CFG1:
+	case CS35L41_DSP1_STRMARB_RX7_CFG0:
+	case CS35L41_DSP1_STRMARB_RX7_CFG1:
+	case CS35L41_DSP1_STRMARB_IRQ0_CFG0:
+	case CS35L41_DSP1_STRMARB_IRQ0_CFG1:
+	case CS35L41_DSP1_STRMARB_IRQ0_CFG2:
+	case CS35L41_DSP1_STRMARB_IRQ1_CFG0:
+	case CS35L41_DSP1_STRMARB_IRQ1_CFG1:
+	case CS35L41_DSP1_STRMARB_IRQ1_CFG2:
+	case CS35L41_DSP1_STRMARB_IRQ2_CFG0:
+	case CS35L41_DSP1_STRMARB_IRQ2_CFG1:
+	case CS35L41_DSP1_STRMARB_IRQ2_CFG2:
+	case CS35L41_DSP1_STRMARB_IRQ3_CFG0:
+	case CS35L41_DSP1_STRMARB_IRQ3_CFG1:
+	case CS35L41_DSP1_STRMARB_IRQ3_CFG2:
+	case CS35L41_DSP1_STRMARB_IRQ4_CFG0:
+	case CS35L41_DSP1_STRMARB_IRQ4_CFG1:
+	case CS35L41_DSP1_STRMARB_IRQ4_CFG2:
+	case CS35L41_DSP1_STRMARB_IRQ5_CFG0:
+	case CS35L41_DSP1_STRMARB_IRQ5_CFG1:
+	case CS35L41_DSP1_STRMARB_IRQ5_CFG2:
+	case CS35L41_DSP1_STRMARB_IRQ6_CFG0:
+	case CS35L41_DSP1_STRMARB_IRQ6_CFG1:
+	case CS35L41_DSP1_STRMARB_IRQ6_CFG2:
+	case CS35L41_DSP1_STRMARB_IRQ7_CFG0:
+	case CS35L41_DSP1_STRMARB_IRQ7_CFG1:
+	case CS35L41_DSP1_STRMARB_IRQ7_CFG2:
+	case CS35L41_DSP1_STRMARB_RESYNC_MSK:
+	case CS35L41_DSP1_STRMARB_ERR_STATUS:
+	case CS35L41_DSP1_INTPCTL_RES_STATIC:
+	case CS35L41_DSP1_INTPCTL_RES_DYN:
+	case CS35L41_DSP1_INTPCTL_NMI_CTRL:
+	case CS35L41_DSP1_INTPCTL_IRQ_INV:
+	case CS35L41_DSP1_INTPCTL_IRQ_MODE:
+	case CS35L41_DSP1_INTPCTL_IRQ_EN:
+	case CS35L41_DSP1_INTPCTL_IRQ_MSK:
+	case CS35L41_DSP1_INTPCTL_IRQ_ERR:
+	case CS35L41_DSP1_INTPCTL_IRQ_PEND:
+	case CS35L41_DSP1_INTPCTL_TESTBITS:
+	case CS35L41_DSP1_WDT_CONTROL:
+	case CS35L41_DSP1_WDT_STATUS:
+	case CS35L41_OTP_TRIM_1:
+	case CS35L41_OTP_TRIM_2:
+	case CS35L41_OTP_TRIM_3:
+	case CS35L41_OTP_TRIM_4:
+	case CS35L41_OTP_TRIM_5:
+	case CS35L41_OTP_TRIM_6:
+	case CS35L41_OTP_TRIM_7:
+	case CS35L41_OTP_TRIM_8:
+	case CS35L41_OTP_TRIM_9:
+	case CS35L41_OTP_TRIM_10:
+	case CS35L41_OTP_TRIM_11:
+	case CS35L41_OTP_TRIM_12:
+	case CS35L41_OTP_TRIM_13:
+	case CS35L41_OTP_TRIM_14:
+	case CS35L41_OTP_TRIM_15:
+	case CS35L41_OTP_TRIM_16:
+	case CS35L41_OTP_TRIM_17:
+	case CS35L41_OTP_TRIM_18:
+	case CS35L41_OTP_TRIM_19:
+	case CS35L41_OTP_TRIM_20:
+	case CS35L41_OTP_TRIM_21:
+	case CS35L41_OTP_TRIM_22:
+	case CS35L41_OTP_TRIM_23:
+	case CS35L41_OTP_TRIM_24:
+	case CS35L41_OTP_TRIM_25:
+	case CS35L41_OTP_TRIM_26:
+	case CS35L41_OTP_TRIM_27:
+	case CS35L41_OTP_TRIM_28:
+	case CS35L41_OTP_TRIM_29:
+	case CS35L41_OTP_TRIM_30:
+	case CS35L41_OTP_TRIM_31:
+	case CS35L41_OTP_TRIM_32:
+	case CS35L41_OTP_TRIM_33:
+	case CS35L41_OTP_TRIM_34:
+	case CS35L41_OTP_TRIM_35:
+	case CS35L41_OTP_TRIM_36:
+	case CS35L41_OTP_MEM0 ... CS35L41_OTP_MEM31:
+	case CS35L41_DSP1_XMEM_PACK_0 ... CS35L41_DSP1_XMEM_PACK_3068:
+	case CS35L41_DSP1_XMEM_UNPACK32_0 ... CS35L41_DSP1_XMEM_UNPACK32_2046:
+	case CS35L41_DSP1_XMEM_UNPACK24_0 ... CS35L41_DSP1_XMEM_UNPACK24_4093:
+	case CS35L41_DSP1_YMEM_PACK_0 ... CS35L41_DSP1_YMEM_PACK_1532:
+	case CS35L41_DSP1_YMEM_UNPACK32_0 ... CS35L41_DSP1_YMEM_UNPACK32_1022:
+	case CS35L41_DSP1_YMEM_UNPACK24_0 ... CS35L41_DSP1_YMEM_UNPACK24_2045:
+	case CS35L41_DSP1_PMEM_0 ... CS35L41_DSP1_PMEM_5114:
+	/*test regs*/
+	case CS35L41_PLL_OVR:
+	case CS35L41_BST_TEST_DUTY:
+	case CS35L41_DIGPWM_IOCTRL:
+		return true;
+	default:
+		return false;
+	}
+}
+
+bool cs35l41_precious_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case CS35L41_OTP_MEM0 ... CS35L41_OTP_MEM31:
+		return true;
+	default:
+		return false;
+	}
+}
+
+bool cs35l41_volatile_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case CS35L41_DEVID:
+	case CS35L41_SFT_RESET:
+	case CS35L41_FABID:
+	case CS35L41_REVID:
+	case CS35L41_PWR_CTRL1:
+	case CS35L41_DTEMP_EN:
+	case CS35L41_PWRMGT_STS:
+	case CS35L41_IRQ1_STATUS:
+	case CS35L41_IRQ1_STATUS1:
+	case CS35L41_IRQ1_STATUS2:
+	case CS35L41_IRQ1_STATUS3:
+	case CS35L41_IRQ1_STATUS4:
+	case CS35L41_IRQ1_RAW_STATUS1:
+	case CS35L41_IRQ1_RAW_STATUS2:
+	case CS35L41_IRQ1_RAW_STATUS3:
+	case CS35L41_IRQ1_RAW_STATUS4:
+	case CS35L41_IRQ1_FRC1:
+	case CS35L41_IRQ1_FRC2:
+	case CS35L41_IRQ1_FRC3:
+	case CS35L41_IRQ1_FRC4:
+	case CS35L41_IRQ1_EDGE1:
+	case CS35L41_IRQ1_EDGE4:
+	case CS35L41_IRQ1_POL1:
+	case CS35L41_IRQ1_POL2:
+	case CS35L41_IRQ1_POL3:
+	case CS35L41_IRQ1_POL4:
+	case CS35L41_IRQ1_DB3:
+	case CS35L41_IRQ2_STATUS:
+	case CS35L41_IRQ2_STATUS1:
+	case CS35L41_IRQ2_STATUS2:
+	case CS35L41_IRQ2_STATUS3:
+	case CS35L41_IRQ2_STATUS4:
+	case CS35L41_IRQ2_RAW_STATUS1:
+	case CS35L41_IRQ2_RAW_STATUS2:
+	case CS35L41_IRQ2_RAW_STATUS3:
+	case CS35L41_IRQ2_RAW_STATUS4:
+	case CS35L41_IRQ2_FRC1:
+	case CS35L41_IRQ2_FRC2:
+	case CS35L41_IRQ2_FRC3:
+	case CS35L41_IRQ2_FRC4:
+	case CS35L41_IRQ2_EDGE1:
+	case CS35L41_IRQ2_EDGE4:
+	case CS35L41_IRQ2_POL1:
+	case CS35L41_IRQ2_POL2:
+	case CS35L41_IRQ2_POL3:
+	case CS35L41_IRQ2_POL4:
+	case CS35L41_IRQ2_DB3:
+	case CS35L41_GPIO_STATUS1:
+	case CS35L41_OTP_TRIM_1:
+	case CS35L41_OTP_TRIM_2:
+	case CS35L41_OTP_TRIM_3:
+	case CS35L41_OTP_TRIM_4:
+	case CS35L41_OTP_TRIM_5:
+	case CS35L41_OTP_TRIM_6:
+	case CS35L41_OTP_TRIM_7:
+	case CS35L41_OTP_TRIM_8:
+	case CS35L41_OTP_TRIM_9:
+	case CS35L41_OTP_TRIM_10:
+	case CS35L41_OTP_TRIM_11:
+	case CS35L41_OTP_TRIM_12:
+	case CS35L41_OTP_TRIM_13:
+	case CS35L41_OTP_TRIM_14:
+	case CS35L41_OTP_TRIM_15:
+	case CS35L41_OTP_TRIM_16:
+	case CS35L41_OTP_TRIM_17:
+	case CS35L41_OTP_TRIM_18:
+	case CS35L41_OTP_TRIM_19:
+	case CS35L41_OTP_TRIM_20:
+	case CS35L41_OTP_TRIM_21:
+	case CS35L41_OTP_TRIM_22:
+	case CS35L41_OTP_TRIM_23:
+	case CS35L41_OTP_TRIM_24:
+	case CS35L41_OTP_TRIM_25:
+	case CS35L41_OTP_TRIM_26:
+	case CS35L41_OTP_TRIM_27:
+	case CS35L41_OTP_TRIM_28:
+	case CS35L41_OTP_TRIM_29:
+	case CS35L41_OTP_TRIM_30:
+	case CS35L41_OTP_TRIM_31:
+	case CS35L41_OTP_TRIM_32:
+	case CS35L41_OTP_TRIM_33:
+	case CS35L41_OTP_TRIM_34:
+	case CS35L41_OTP_TRIM_35:
+	case CS35L41_OTP_TRIM_36:
+	case CS35L41_DSP_MBOX_1 ... CS35L41_DSP_VIRT2_MBOX_8:
+	case CS35L41_DSP1_XMEM_PACK_0 ... CS35L41_DSP1_XMEM_PACK_3068:
+	case CS35L41_DSP1_XMEM_UNPACK32_0 ... CS35L41_DSP1_XMEM_UNPACK32_2046:
+	case CS35L41_DSP1_XMEM_UNPACK24_0 ... CS35L41_DSP1_XMEM_UNPACK24_4093:
+	case CS35L41_DSP1_YMEM_PACK_0 ... CS35L41_DSP1_YMEM_PACK_1532:
+	case CS35L41_DSP1_YMEM_UNPACK32_0 ... CS35L41_DSP1_YMEM_UNPACK32_1022:
+	case CS35L41_DSP1_YMEM_UNPACK24_0 ... CS35L41_DSP1_YMEM_UNPACK24_2045:
+	case CS35L41_DSP1_PMEM_0 ... CS35L41_DSP1_PMEM_5114:
+	case CS35L41_DSP1_CCM_CORE_CTRL ... CS35L41_DSP1_WDT_STATUS:
+	case CS35L41_OTP_MEM0 ... CS35L41_OTP_MEM31:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static const struct cs35l41_otp_packed_element_t
+					otp_map_1[CS35L41_NUM_OTP_ELEM] = {
+	/* addr         shift   size */
+	{0x00002030,	0,	4}, /*TRIM_OSC_FREQ_TRIM*/
+	{0x00002030,	7,	1}, /*TRIM_OSC_TRIM_DONE*/
+	{0x0000208c,	24,	6}, /*TST_DIGREG_VREF_TRIM*/
+	{0x00002090,	14,	4}, /*TST_REF_TRIM*/
+	{0x00002090,	10,	4}, /*TST_REF_TEMPCO_TRIM*/
+	{0x0000300C,	11,	4}, /*PLL_LDOA_TST_VREF_TRIM*/
+	{0x0000394C,	23,	2}, /*BST_ATEST_CM_VOFF*/
+	{0x00003950,	0,	7}, /*BST_ATRIM_IADC_OFFSET*/
+	{0x00003950,	8,	7}, /*BST_ATRIM_IADC_GAIN1*/
+	{0x00003950,	16,	8}, /*BST_ATRIM_IPKCOMP_OFFSET1*/
+	{0x00003950,	24,	8}, /*BST_ATRIM_IPKCOMP_GAIN1*/
+	{0x00003954,	0,	7}, /*BST_ATRIM_IADC_OFFSET2*/
+	{0x00003954,	8,	7}, /*BST_ATRIM_IADC_GAIN2*/
+	{0x00003954,	16,	8}, /*BST_ATRIM_IPKCOMP_OFFSET2*/
+	{0x00003954,	24,	8}, /*BST_ATRIM_IPKCOMP_GAIN2*/
+	{0x00003958,	0,	7}, /*BST_ATRIM_IADC_OFFSET3*/
+	{0x00003958,	8,	7}, /*BST_ATRIM_IADC_GAIN3*/
+	{0x00003958,	16,	8}, /*BST_ATRIM_IPKCOMP_OFFSET3*/
+	{0x00003958,	24,	8}, /*BST_ATRIM_IPKCOMP_GAIN3*/
+	{0x0000395C,	0,	7}, /*BST_ATRIM_IADC_OFFSET4*/
+	{0x0000395C,	8,	7}, /*BST_ATRIM_IADC_GAIN4*/
+	{0x0000395C,	16,	8}, /*BST_ATRIM_IPKCOMP_OFFSET4*/
+	{0x0000395C,	24,	8}, /*BST_ATRIM_IPKCOMP_GAIN4*/
+	{0x0000416C,	0,	8}, /*VMON_GAIN_OTP_VAL*/
+	{0x00004160,	0,	7}, /*VMON_OFFSET_OTP_VAL*/
+	{0x0000416C,	8,	8}, /*IMON_GAIN_OTP_VAL*/
+	{0x00004160,	16,	10}, /*IMON_OFFSET_OTP_VAL*/
+	{0x0000416C,	16,	12}, /*VMON_CM_GAIN_OTP_VAL*/
+	{0x0000416C,	28,	1}, /*VMON_CM_GAIN_SIGN_OTP_VAL*/
+	{0x00004170,	0,	6}, /*IMON_CAL_TEMPCO_OTP_VAL*/
+	{0x00004170,	6,	1}, /*IMON_CAL_TEMPCO_SIGN_OTP*/
+	{0x00004170,	8,	6}, /*IMON_CAL_TEMPCO2_OTP_VAL*/
+	{0x00004170,	14,	1}, /*IMON_CAL_TEMPCO2_DN_UPB_OTP_VAL*/
+	{0x00004170,	16,	9}, /*IMON_CAL_TEMPCO_TBASE_OTP_VAL*/
+	{0x00004360,	0,	5}, /*TEMP_GAIN_OTP_VAL*/
+	{0x00004360,	6,	9}, /*TEMP_OFFSET_OTP_VAL*/
+	{0x00004448,	0,	8}, /*VP_SARADC_OFFSET*/
+	{0x00004448,	8,	8}, /*VP_GAIN_INDEX*/
+	{0x00004448,	16,	8}, /*VBST_SARADC_OFFSET*/
+	{0x00004448,	24,	8}, /*VBST_GAIN_INDEX*/
+	{0x0000444C,	0,	3}, /*ANA_SELINVREF*/
+	{0x00006E30,	0,	5}, /*GAIN_ERR_COEFF_0*/
+	{0x00006E30,	8,	5}, /*GAIN_ERR_COEFF_1*/
+	{0x00006E30,	16,	5}, /*GAIN_ERR_COEFF_2*/
+	{0x00006E30,	24,	5}, /*GAIN_ERR_COEFF_3*/
+	{0x00006E34,	0,	5}, /*GAIN_ERR_COEFF_4*/
+	{0x00006E34,	8,	5}, /*GAIN_ERR_COEFF_5*/
+	{0x00006E34,	16,	5}, /*GAIN_ERR_COEFF_6*/
+	{0x00006E34,	24,	5}, /*GAIN_ERR_COEFF_7*/
+	{0x00006E38,	0,	5}, /*GAIN_ERR_COEFF_8*/
+	{0x00006E38,	8,	5}, /*GAIN_ERR_COEFF_9*/
+	{0x00006E38,	16,	5}, /*GAIN_ERR_COEFF_10*/
+	{0x00006E38,	24,	5}, /*GAIN_ERR_COEFF_11*/
+	{0x00006E3C,	0,	5}, /*GAIN_ERR_COEFF_12*/
+	{0x00006E3C,	8,	5}, /*GAIN_ERR_COEFF_13*/
+	{0x00006E3C,	16,	5}, /*GAIN_ERR_COEFF_14*/
+	{0x00006E3C,	24,	5}, /*GAIN_ERR_COEFF_15*/
+	{0x00006E40,	0,	5}, /*GAIN_ERR_COEFF_16*/
+	{0x00006E40,	8,	5}, /*GAIN_ERR_COEFF_17*/
+	{0x00006E40,	16,	5}, /*GAIN_ERR_COEFF_18*/
+	{0x00006E40,	24,	5}, /*GAIN_ERR_COEFF_19*/
+	{0x00006E44,	0,	5}, /*GAIN_ERR_COEFF_20*/
+	{0x00006E48,	0,	10}, /*VOFF_GAIN_0*/
+	{0x00006E48,	10,	10}, /*VOFF_GAIN_1*/
+	{0x00006E48,	20,	10}, /*VOFF_GAIN_2*/
+	{0x00006E4C,	0,	10}, /*VOFF_GAIN_3*/
+	{0x00006E4C,	10,	10}, /*VOFF_GAIN_4*/
+	{0x00006E4C,	20,	10}, /*VOFF_GAIN_5*/
+	{0x00006E50,	0,	10}, /*VOFF_GAIN_6*/
+	{0x00006E50,	10,	10}, /*VOFF_GAIN_7*/
+	{0x00006E50,	20,	10}, /*VOFF_GAIN_8*/
+	{0x00006E54,	0,	10}, /*VOFF_GAIN_9*/
+	{0x00006E54,	10,	10}, /*VOFF_GAIN_10*/
+	{0x00006E54,	20,	10}, /*VOFF_GAIN_11*/
+	{0x00006E58,	0,	10}, /*VOFF_GAIN_12*/
+	{0x00006E58,	10,	10}, /*VOFF_GAIN_13*/
+	{0x00006E58,	20,	10}, /*VOFF_GAIN_14*/
+	{0x00006E5C,	0,	10}, /*VOFF_GAIN_15*/
+	{0x00006E5C,	10,	10}, /*VOFF_GAIN_16*/
+	{0x00006E5C,	20,	10}, /*VOFF_GAIN_17*/
+	{0x00006E60,	0,	10}, /*VOFF_GAIN_18*/
+	{0x00006E60,	10,	10}, /*VOFF_GAIN_19*/
+	{0x00006E60,	20,	10}, /*VOFF_GAIN_20*/
+	{0x00006E64,	0,	10}, /*VOFF_INT1*/
+	{0x00007418,	7,	5}, /*DS_SPK_INT1_CAP_TRIM*/
+	{0x0000741C,	0,	5}, /*DS_SPK_INT2_CAP_TRIM*/
+	{0x0000741C,	11,	4}, /*DS_SPK_LPF_CAP_TRIM*/
+	{0x0000741C,	19,	4}, /*DS_SPK_QUAN_CAP_TRIM*/
+	{0x00007434,	17,	1}, /*FORCE_CAL*/
+	{0x00007434,	18,	7}, /*CAL_OVERRIDE*/
+	{0x00007068,	0,	9}, /*MODIX*/
+	{0x0000410C,	7,	1}, /*VIMON_DLY_NOT_COMB*/
+	{0x0000400C,	0,	7}, /*VIMON_DLY*/
+	{0x00000000,	0,	1}, /*extra bit*/
+	{0x00017040,	0,	8}, /*X_COORDINATE*/
+	{0x00017040,	8,	8}, /*Y_COORDINATE*/
+	{0x00017040,	16,	8}, /*WAFER_ID*/
+	{0x00017040,	24,	8}, /*DVS*/
+	{0x00017044,	0,	24}, /*LOT_NUMBER*/
+};
+
+static const struct cs35l41_otp_packed_element_t
+					otp_map_2[CS35L41_NUM_OTP_ELEM] = {
+	/* addr         shift   size */
+	{0x00002030,	0,	4}, /*TRIM_OSC_FREQ_TRIM*/
+	{0x00002030,	7,	1}, /*TRIM_OSC_TRIM_DONE*/
+	{0x0000208c,	24,	6}, /*TST_DIGREG_VREF_TRIM*/
+	{0x00002090,	14,	4}, /*TST_REF_TRIM*/
+	{0x00002090,	10,	4}, /*TST_REF_TEMPCO_TRIM*/
+	{0x0000300C,	11,	4}, /*PLL_LDOA_TST_VREF_TRIM*/
+	{0x0000394C,	23,	2}, /*BST_ATEST_CM_VOFF*/
+	{0x00003950,	0,	7}, /*BST_ATRIM_IADC_OFFSET*/
+	{0x00003950,	8,	7}, /*BST_ATRIM_IADC_GAIN1*/
+	{0x00003950,	16,	8}, /*BST_ATRIM_IPKCOMP_OFFSET1*/
+	{0x00003950,	24,	8}, /*BST_ATRIM_IPKCOMP_GAIN1*/
+	{0x00003954,	0,	7}, /*BST_ATRIM_IADC_OFFSET2*/
+	{0x00003954,	8,	7}, /*BST_ATRIM_IADC_GAIN2*/
+	{0x00003954,	16,	8}, /*BST_ATRIM_IPKCOMP_OFFSET2*/
+	{0x00003954,	24,	8}, /*BST_ATRIM_IPKCOMP_GAIN2*/
+	{0x00003958,	0,	7}, /*BST_ATRIM_IADC_OFFSET3*/
+	{0x00003958,	8,	7}, /*BST_ATRIM_IADC_GAIN3*/
+	{0x00003958,	16,	8}, /*BST_ATRIM_IPKCOMP_OFFSET3*/
+	{0x00003958,	24,	8}, /*BST_ATRIM_IPKCOMP_GAIN3*/
+	{0x0000395C,	0,	7}, /*BST_ATRIM_IADC_OFFSET4*/
+	{0x0000395C,	8,	7}, /*BST_ATRIM_IADC_GAIN4*/
+	{0x0000395C,	16,	8}, /*BST_ATRIM_IPKCOMP_OFFSET4*/
+	{0x0000395C,	24,	8}, /*BST_ATRIM_IPKCOMP_GAIN4*/
+	{0x0000416C,	0,	8}, /*VMON_GAIN_OTP_VAL*/
+	{0x00004160,	0,	7}, /*VMON_OFFSET_OTP_VAL*/
+	{0x0000416C,	8,	8}, /*IMON_GAIN_OTP_VAL*/
+	{0x00004160,	16,	10}, /*IMON_OFFSET_OTP_VAL*/
+	{0x0000416C,	16,	12}, /*VMON_CM_GAIN_OTP_VAL*/
+	{0x0000416C,	28,	1}, /*VMON_CM_GAIN_SIGN_OTP_VAL*/
+	{0x00004170,	0,	6}, /*IMON_CAL_TEMPCO_OTP_VAL*/
+	{0x00004170,	6,	1}, /*IMON_CAL_TEMPCO_SIGN_OTP*/
+	{0x00004170,	8,	6}, /*IMON_CAL_TEMPCO2_OTP_VAL*/
+	{0x00004170,	14,	1}, /*IMON_CAL_TEMPCO2_DN_UPB_OTP_VAL*/
+	{0x00004170,	16,	9}, /*IMON_CAL_TEMPCO_TBASE_OTP_VAL*/
+	{0x00004360,	0,	5}, /*TEMP_GAIN_OTP_VAL*/
+	{0x00004360,	6,	9}, /*TEMP_OFFSET_OTP_VAL*/
+	{0x00004448,	0,	8}, /*VP_SARADC_OFFSET*/
+	{0x00004448,	8,	8}, /*VP_GAIN_INDEX*/
+	{0x00004448,	16,	8}, /*VBST_SARADC_OFFSET*/
+	{0x00004448,	24,	8}, /*VBST_GAIN_INDEX*/
+	{0x0000444C,	0,	3}, /*ANA_SELINVREF*/
+	{0x00006E30,	0,	5}, /*GAIN_ERR_COEFF_0*/
+	{0x00006E30,	8,	5}, /*GAIN_ERR_COEFF_1*/
+	{0x00006E30,	16,	5}, /*GAIN_ERR_COEFF_2*/
+	{0x00006E30,	24,	5}, /*GAIN_ERR_COEFF_3*/
+	{0x00006E34,	0,	5}, /*GAIN_ERR_COEFF_4*/
+	{0x00006E34,	8,	5}, /*GAIN_ERR_COEFF_5*/
+	{0x00006E34,	16,	5}, /*GAIN_ERR_COEFF_6*/
+	{0x00006E34,	24,	5}, /*GAIN_ERR_COEFF_7*/
+	{0x00006E38,	0,	5}, /*GAIN_ERR_COEFF_8*/
+	{0x00006E38,	8,	5}, /*GAIN_ERR_COEFF_9*/
+	{0x00006E38,	16,	5}, /*GAIN_ERR_COEFF_10*/
+	{0x00006E38,	24,	5}, /*GAIN_ERR_COEFF_11*/
+	{0x00006E3C,	0,	5}, /*GAIN_ERR_COEFF_12*/
+	{0x00006E3C,	8,	5}, /*GAIN_ERR_COEFF_13*/
+	{0x00006E3C,	16,	5}, /*GAIN_ERR_COEFF_14*/
+	{0x00006E3C,	24,	5}, /*GAIN_ERR_COEFF_15*/
+	{0x00006E40,	0,	5}, /*GAIN_ERR_COEFF_16*/
+	{0x00006E40,	8,	5}, /*GAIN_ERR_COEFF_17*/
+	{0x00006E40,	16,	5}, /*GAIN_ERR_COEFF_18*/
+	{0x00006E40,	24,	5}, /*GAIN_ERR_COEFF_19*/
+	{0x00006E44,	0,	5}, /*GAIN_ERR_COEFF_20*/
+	{0x00006E48,	0,	10}, /*VOFF_GAIN_0*/
+	{0x00006E48,	10,	10}, /*VOFF_GAIN_1*/
+	{0x00006E48,	20,	10}, /*VOFF_GAIN_2*/
+	{0x00006E4C,	0,	10}, /*VOFF_GAIN_3*/
+	{0x00006E4C,	10,	10}, /*VOFF_GAIN_4*/
+	{0x00006E4C,	20,	10}, /*VOFF_GAIN_5*/
+	{0x00006E50,	0,	10}, /*VOFF_GAIN_6*/
+	{0x00006E50,	10,	10}, /*VOFF_GAIN_7*/
+	{0x00006E50,	20,	10}, /*VOFF_GAIN_8*/
+	{0x00006E54,	0,	10}, /*VOFF_GAIN_9*/
+	{0x00006E54,	10,	10}, /*VOFF_GAIN_10*/
+	{0x00006E54,	20,	10}, /*VOFF_GAIN_11*/
+	{0x00006E58,	0,	10}, /*VOFF_GAIN_12*/
+	{0x00006E58,	10,	10}, /*VOFF_GAIN_13*/
+	{0x00006E58,	20,	10}, /*VOFF_GAIN_14*/
+	{0x00006E5C,	0,	10}, /*VOFF_GAIN_15*/
+	{0x00006E5C,	10,	10}, /*VOFF_GAIN_16*/
+	{0x00006E5C,	20,	10}, /*VOFF_GAIN_17*/
+	{0x00006E60,	0,	10}, /*VOFF_GAIN_18*/
+	{0x00006E60,	10,	10}, /*VOFF_GAIN_19*/
+	{0x00006E60,	20,	10}, /*VOFF_GAIN_20*/
+	{0x00006E64,	0,	10}, /*VOFF_INT1*/
+	{0x00007418,	7,	5}, /*DS_SPK_INT1_CAP_TRIM*/
+	{0x0000741C,	0,	5}, /*DS_SPK_INT2_CAP_TRIM*/
+	{0x0000741C,	11,	4}, /*DS_SPK_LPF_CAP_TRIM*/
+	{0x0000741C,	19,	4}, /*DS_SPK_QUAN_CAP_TRIM*/
+	{0x00007434,	17,	1}, /*FORCE_CAL*/
+	{0x00007434,	18,	7}, /*CAL_OVERRIDE*/
+	{0x00007068,	0,	9}, /*MODIX*/
+	{0x0000410C,	7,	1}, /*VIMON_DLY_NOT_COMB*/
+	{0x0000400C,	0,	7}, /*VIMON_DLY*/
+	{0x00004000,	11,	1}, /*VMON_POL*/
+	{0x00017040,	0,	8}, /*X_COORDINATE*/
+	{0x00017040,	8,	8}, /*Y_COORDINATE*/
+	{0x00017040,	16,	8}, /*WAFER_ID*/
+	{0x00017040,	24,	8}, /*DVS*/
+	{0x00017044,	0,	24}, /*LOT_NUMBER*/
+};
+
+const struct cs35l41_otp_map_element_t
+				cs35l41_otp_map_map[CS35L41_NUM_OTP_MAPS] = {
+	{
+		.id = 0x01,
+		.map = otp_map_1,
+		.num_elements = CS35L41_NUM_OTP_ELEM,
+		.bit_offset = 16,
+		.word_offset = 2,
+	},
+	{
+		.id = 0x02,
+		.map = otp_map_2,
+		.num_elements = CS35L41_NUM_OTP_ELEM,
+		.bit_offset = 16,
+		.word_offset = 2,
+	},
+	{
+		.id = 0x03,
+		.map = otp_map_2,
+		.num_elements = CS35L41_NUM_OTP_ELEM,
+		.bit_offset = 16,
+		.word_offset = 2,
+	},
+	{
+		.id = 0x06,
+		.map = otp_map_2,
+		.num_elements = CS35L41_NUM_OTP_ELEM,
+		.bit_offset = 16,
+		.word_offset = 2,
+	},
+	{
+		.id = 0x08,
+		.map = otp_map_1,
+		.num_elements = CS35L41_NUM_OTP_ELEM,
+		.bit_offset = 16,
+		.word_offset = 2,
+	},
+};
+
+
+const unsigned int cs35l41_ctl_cache_regs[CS35L41_CTRL_CACHE_SIZE] = {
+	CS35L41_SP_FRAME_RX_SLOT,
+	CS35L41_DAC_PCM1_SRC,
+	CS35L41_DSP1_RX1_SRC,
+	CS35L41_DSP1_RX2_SRC,
+	CS35L41_ASP_TX1_SRC,
+	CS35L41_ASP_TX2_SRC,
+	CS35L41_ASP_TX3_SRC,
+	CS35L41_ASP_TX4_SRC,
+	CS35L41_SP_FRAME_TX_SLOT,
+	CS35L41_AMP_GAIN_CTRL,
+	CS35L41_AMP_DIG_VOL_CTRL,
+	CS35L41_PWR_CTRL1,
+	CS35L41_PWR_CTRL2,
+	CS35L41_BSTCVRT_VCTRL1,
+	CS35L41_BSTCVRT_VCTRL2,
+};
+
+const struct cs35l41_otp_trim_region_t
+			cs35l41_trim_cache_regs[CS35L41_TRIM_CACHE_REGIONS] = {
+	{0x00002030, 1},
+	{0x0000208c, 2},
+	{0x0000300C, 1},
+	{0x0000394C, 5},
+	{0x0000416C, 1},
+	{0x00004160, 1},
+	{0x00004170, 1},
+	{0x00004360, 1},
+	{0x00004448, 2},
+	{0x00006E30, 14},
+	{0x00007418, 2},
+	{0x00007434, 1},
+	{0x00007068, 1},
+	{0x0000410C, 1},
+	{0x0000400C, 1},
+	{0x00004000, 1},
+	{0x00017040, 2},
+};
diff -ruN a/sound/soc/codecs/nau8821.c b/sound/soc/codecs/nau8821.c
--- a/sound/soc/codecs/nau8821.c	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/codecs/nau8821.c	2022-07-08 01:12:12.000000000 +0200
@@ -29,14 +29,11 @@
 #define NAU_FVCO_MAX 100000000
 #define NAU_FVCO_MIN 90000000
 
-#define NAU8821_BUTTON SND_JACK_BTN_0
-
 /* the maximum frequency of CLK_ADC and CLK_DAC */
 #define CLK_DA_AD_MAX 6144000
 
 static int nau8821_configure_sysclk(struct nau8821 *nau8821,
 	int clk_id, unsigned int freq);
-static bool nau8821_is_jack_inserted(struct regmap *regmap);
 
 struct nau8821_fll {
 	int mclk_src;
@@ -384,7 +381,7 @@
 			speed_selection = dmic_speed_sel[i].val;
 			break;
 		}
-	if (i == 4)
+	if (speed_selection < 0)
 		return -EINVAL;
 
 	dev_dbg(nau8821->dev,
@@ -496,33 +493,7 @@
 	return 0;
 }
 
-static int system_clock_control(struct snd_soc_dapm_widget *w,
-				struct snd_kcontrol *k, int  event)
-{
-	struct snd_soc_component *component =
-		snd_soc_dapm_to_component(w->dapm);
-	struct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);
-
-	if (SND_SOC_DAPM_EVENT_OFF(event)) {
-		dev_dbg(nau8821->dev, "system clock control : POWER OFF\n");
-		/* Set clock source to disable or internal clock before the
-		 * playback or capture end. Codec needs clock for Jack
-		 * detection and button press if jack inserted; otherwise,
-		 * the clock should be closed.
-		 */
-		if (nau8821_is_jack_inserted(nau8821->regmap)) {
-			nau8821_configure_sysclk(nau8821,
-				NAU8821_CLK_INTERNAL, 0);
-		} else {
-			nau8821_configure_sysclk(nau8821, NAU8821_CLK_DIS, 0);
-		}
-	}
-	return 0;
-}
-
 static const struct snd_soc_dapm_widget nau8821_dapm_widgets[] = {
-	SND_SOC_DAPM_SUPPLY("System Clock", SND_SOC_NOPM, 0, 0,
-		system_clock_control, SND_SOC_DAPM_POST_PMD),
 	SND_SOC_DAPM_SUPPLY("MICBIAS", NAU8821_R74_MIC_BIAS,
 		NAU8821_MICBIAS_POWERUP_SFT, 0, NULL, 0),
 	SND_SOC_DAPM_SUPPLY("DMIC Clock", SND_SOC_NOPM, 0, 0,
@@ -634,9 +605,6 @@
 	{"AIFTX", NULL, "ADCL Digital path"},
 	{"AIFTX", NULL, "ADCR Digital path"},
 
-	{"AIFTX", NULL, "System Clock"},
-	{"AIFRX", NULL, "System Clock"},
-
 	{"DDACL", NULL, "AIFRX"},
 	{"DDACR", NULL, "AIFRX"},
 
@@ -670,40 +638,28 @@
 	{"HPOR", NULL, "Class G"},
 };
 
-static const struct nau8821_osr_attr *
-nau8821_get_osr(struct nau8821 *nau8821, int stream)
+static int nau8821_clock_check(struct nau8821 *nau8821,
+	int stream, int rate, int osr)
 {
-	unsigned int osr;
+	int osrate = 0;
 
 	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
-		regmap_read(nau8821->regmap, NAU8821_R2C_DAC_CTRL1, &osr);
-		osr &= NAU8821_DAC_OVERSAMPLE_MASK;
 		if (osr >= ARRAY_SIZE(osr_dac_sel))
-			return NULL;
-		return &osr_dac_sel[osr];
+			return -EINVAL;
+		osrate = osr_dac_sel[osr].osr;
 	} else {
-		regmap_read(nau8821->regmap, NAU8821_R2B_ADC_RATE, &osr);
-		osr &= NAU8821_ADC_SYNC_DOWN_MASK;
 		if (osr >= ARRAY_SIZE(osr_adc_sel))
-			return NULL;
-		return &osr_adc_sel[osr];
+			return -EINVAL;
+		osrate = osr_adc_sel[osr].osr;
 	}
-}
-
-static int nau8821_dai_startup(struct snd_pcm_substream *substream,
-			       struct snd_soc_dai *dai)
-{
-	struct snd_soc_component *component = dai->component;
-	struct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);
-	const struct nau8821_osr_attr *osr;
 
-	osr = nau8821_get_osr(nau8821, substream->stream);
-	if (!osr || !osr->osr)
+	if (!osrate || rate * osrate > CLK_DA_AD_MAX) {
+		dev_err(nau8821->dev,
+			"exceed the maximum frequency of CLK_ADC or CLK_DAC");
 		return -EINVAL;
+	}
 
-	return snd_pcm_hw_constraint_minmax(substream->runtime,
-					    SNDRV_PCM_HW_PARAM_RATE,
-					    0, CLK_DA_AD_MAX / osr->osr);
+	return 0;
 }
 
 static int nau8821_hw_params(struct snd_pcm_substream *substream,
@@ -711,8 +667,7 @@
 {
 	struct snd_soc_component *component = dai->component;
 	struct nau8821 *nau8821 = snd_soc_component_get_drvdata(component);
-	unsigned int val_len = 0, ctrl_val, bclk_fs, clk_div;
-	const struct nau8821_osr_attr *osr;
+	unsigned int val_len = 0, osr, ctrl_val, bclk_fs, clk_div;
 
 	nau8821->fs = params_rate(params);
 	/* CLK_DAC or CLK_ADC = OSR * FS
@@ -721,19 +676,27 @@
 	 * values must be selected such that the maximum frequency is less
 	 * than 6.144 MHz.
 	 */
-	osr = nau8821_get_osr(nau8821, substream->stream);
-	if (!osr || !osr->osr)
-		return -EINVAL;
-	if (nau8821->fs * osr->osr > CLK_DA_AD_MAX)
-		return -EINVAL;
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		regmap_read(nau8821->regmap, NAU8821_R2C_DAC_CTRL1, &osr);
+		osr &= NAU8821_DAC_OVERSAMPLE_MASK;
+		if (nau8821_clock_check(nau8821, substream->stream,
+			nau8821->fs, osr)) {
+			return -EINVAL;
+		}
 		regmap_update_bits(nau8821->regmap, NAU8821_R03_CLK_DIVIDER,
 			NAU8821_CLK_DAC_SRC_MASK,
-			osr->clk_src << NAU8821_CLK_DAC_SRC_SFT);
-	else
+			osr_dac_sel[osr].clk_src << NAU8821_CLK_DAC_SRC_SFT);
+	} else {
+		regmap_read(nau8821->regmap, NAU8821_R2B_ADC_RATE, &osr);
+		osr &= NAU8821_ADC_SYNC_DOWN_MASK;
+		if (nau8821_clock_check(nau8821, substream->stream,
+			nau8821->fs, osr)) {
+			return -EINVAL;
+		}
 		regmap_update_bits(nau8821->regmap, NAU8821_R03_CLK_DIVIDER,
 			NAU8821_CLK_ADC_SRC_MASK,
-			osr->clk_src << NAU8821_CLK_ADC_SRC_SFT);
+			osr_adc_sel[osr].clk_src << NAU8821_CLK_ADC_SRC_SFT);
+	}
 
 	/* make BCLK and LRC divde configuration if the codec as master. */
 	regmap_read(nau8821->regmap, NAU8821_R1D_I2S_PCM_CTRL2, &ctrl_val);
@@ -848,7 +811,6 @@
 }
 
 static const struct snd_soc_dai_ops nau8821_dai_ops = {
-	.startup = nau8821_dai_startup,
 	.hw_params = nau8821_hw_params,
 	.set_fmt = nau8821_set_dai_fmt,
 	.mute_stream = nau8821_digital_mute,
@@ -949,20 +911,6 @@
 	/* Recover to normal channel input */
 	regmap_update_bits(regmap, NAU8821_R2B_ADC_RATE,
 			NAU8821_ADC_R_SRC_EN, 0);
-	if (nau8821->key_enable) {
-		regmap_update_bits(regmap, NAU8821_R0F_INTERRUPT_MASK,
-			NAU8821_IRQ_KEY_RELEASE_EN |
-			NAU8821_IRQ_KEY_PRESS_EN,
-			NAU8821_IRQ_KEY_RELEASE_EN |
-			NAU8821_IRQ_KEY_PRESS_EN);
-		regmap_update_bits(regmap,
-			NAU8821_R12_INTERRUPT_DIS_CTRL,
-			NAU8821_IRQ_KEY_RELEASE_DIS |
-			NAU8821_IRQ_KEY_PRESS_DIS,
-			NAU8821_IRQ_KEY_RELEASE_DIS |
-			NAU8821_IRQ_KEY_PRESS_DIS);
-	}
-
 }
 
 static void nau8821_jdet_work(struct work_struct *work)
@@ -992,15 +940,6 @@
 		 */
 		regmap_update_bits(regmap, NAU8821_R2B_ADC_RATE,
 			NAU8821_ADC_R_SRC_EN, NAU8821_ADC_R_SRC_EN);
-		if (nau8821->key_enable) {
-			regmap_update_bits(regmap, NAU8821_R0F_INTERRUPT_MASK,
-				NAU8821_IRQ_KEY_RELEASE_EN |
-				NAU8821_IRQ_KEY_PRESS_EN, 0);
-			regmap_update_bits(regmap,
-				NAU8821_R12_INTERRUPT_DIS_CTRL,
-				NAU8821_IRQ_KEY_RELEASE_DIS |
-				NAU8821_IRQ_KEY_PRESS_DIS, 0);
-		}
 	} else {
 		dev_dbg(nau8821->dev, "Headphone connected\n");
 		event |= SND_JACK_HEADPHONE;
@@ -1060,13 +999,6 @@
 		nau8821_eject_jack(nau8821);
 		event_mask |= SND_JACK_HEADSET;
 		clear_irq = NAU8821_JACK_EJECT_IRQ_MASK;
-	} else if (active_irq & NAU8821_KEY_SHORT_PRESS_IRQ) {
-		event |= NAU8821_BUTTON;
-		event_mask |= NAU8821_BUTTON;
-		clear_irq = NAU8821_KEY_SHORT_PRESS_IRQ;
-	} else if (active_irq & NAU8821_KEY_RELEASE_IRQ) {
-		event_mask = NAU8821_BUTTON;
-		clear_irq = NAU8821_KEY_RELEASE_IRQ;
 	} else if ((active_irq & NAU8821_JACK_INSERT_IRQ_MASK) ==
 		NAU8821_JACK_INSERT_DETECTED) {
 		regmap_update_bits(regmap, NAU8821_R71_ANALOG_ADC_1,
@@ -1247,9 +1179,7 @@
 
 /**
  * nau8821_set_fll - FLL configuration of nau8821
- * @component:  codec component
- * @pll_id:  PLL requested
- * @source:  clock source
+ * @codec:  codec component
  * @freq_in:  frequency of input clock source
  * @freq_out:  must be 256*Fs in order to achieve the best performance
  *
@@ -1557,7 +1488,6 @@
 		nau8821->jack_eject_debounce);
 	dev_dbg(dev, "dmic-clk-threshold:       %d\n",
 		nau8821->dmic_clk_threshold);
-	dev_dbg(dev, "key_enable:       %d\n", nau8821->key_enable);
 }
 
 static int nau8821_read_device_properties(struct device *dev,
@@ -1571,8 +1501,6 @@
 		"nuvoton,jkdet-pull-enable");
 	nau8821->jkdet_pull_up = device_property_read_bool(dev,
 		"nuvoton,jkdet-pull-up");
-	nau8821->key_enable = device_property_read_bool(dev,
-		"nuvoton,key-enable");
 	ret = device_property_read_u32(dev, "nuvoton,jkdet-polarity",
 		&nau8821->jkdet_polarity);
 	if (ret)
@@ -1696,7 +1624,8 @@
 	return 0;
 }
 
-static int nau8821_i2c_probe(struct i2c_client *i2c)
+static int nau8821_i2c_probe(struct i2c_client *i2c,
+	const struct i2c_device_id *id)
 {
 	struct device *dev = &i2c->dev;
 	struct nau8821 *nau8821 = dev_get_platdata(&i2c->dev);
@@ -1735,6 +1664,15 @@
 	return ret;
 }
 
+static int nau8821_i2c_remove(struct i2c_client *i2c_client)
+{
+	struct nau8821 *nau8821 = i2c_get_clientdata(i2c_client);
+
+	devm_free_irq(nau8821->dev, nau8821->irq, nau8821);
+
+	return 0;
+}
+
 static const struct i2c_device_id nau8821_i2c_ids[] = {
 	{ "nau8821", 0 },
 	{ }
@@ -1763,7 +1701,8 @@
 		.of_match_table = of_match_ptr(nau8821_of_ids),
 		.acpi_match_table = ACPI_PTR(nau8821_acpi_match),
 	},
-	.probe_new = nau8821_i2c_probe,
+	.probe = nau8821_i2c_probe,
+	.remove = nau8821_i2c_remove,
 	.id_table = nau8821_i2c_ids,
 };
 module_i2c_driver(nau8821_driver);
diff -ruN a/sound/soc/codecs/nau8821.h b/sound/soc/codecs/nau8821.h
--- a/sound/soc/codecs/nau8821.h	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/codecs/nau8821.h	2022-07-08 01:12:12.000000000 +0200
@@ -525,7 +525,6 @@
 	int jack_eject_debounce;
 	int fs;
 	int dmic_clk_threshold;
-	int key_enable;
 };
 
 int nau8821_enable_jack_detect(struct snd_soc_component *component,
diff -ruN a/sound/soc/codecs/wm_adsp.c b/sound/soc/codecs/wm_adsp.c
--- a/sound/soc/codecs/wm_adsp.c	2023-02-15 21:20:01.000000000 +0100
+++ b/sound/soc/codecs/wm_adsp.c	2022-07-08 01:12:12.000000000 +0200
@@ -19,6 +19,7 @@
 #include <linux/regmap.h>
 #include <linux/regulator/consumer.h>
 #include <linux/slab.h>
+#include <linux/vmalloc.h>
 #include <linux/workqueue.h>
 #include <linux/debugfs.h>
 #include <sound/core.h>
@@ -32,15 +33,15 @@
 #include "wm_adsp.h"
 
 #define adsp_crit(_dsp, fmt, ...) \
-	dev_crit(_dsp->cs_dsp.dev, "%s: " fmt, _dsp->cs_dsp.name, ##__VA_ARGS__)
+	dev_crit(_dsp->dev, "%s: " fmt, _dsp->name, ##__VA_ARGS__)
 #define adsp_err(_dsp, fmt, ...) \
-	dev_err(_dsp->cs_dsp.dev, "%s: " fmt, _dsp->cs_dsp.name, ##__VA_ARGS__)
+	dev_err(_dsp->dev, "%s: " fmt, _dsp->name, ##__VA_ARGS__)
 #define adsp_warn(_dsp, fmt, ...) \
-	dev_warn(_dsp->cs_dsp.dev, "%s: " fmt, _dsp->cs_dsp.name, ##__VA_ARGS__)
+	dev_warn(_dsp->dev, "%s: " fmt, _dsp->name, ##__VA_ARGS__)
 #define adsp_info(_dsp, fmt, ...) \
-	dev_info(_dsp->cs_dsp.dev, "%s: " fmt, _dsp->cs_dsp.name, ##__VA_ARGS__)
+	dev_info(_dsp->dev, "%s: " fmt, _dsp->name, ##__VA_ARGS__)
 #define adsp_dbg(_dsp, fmt, ...) \
-	dev_dbg(_dsp->cs_dsp.dev, "%s: " fmt, _dsp->cs_dsp.name, ##__VA_ARGS__)
+	dev_dbg(_dsp->dev, "%s: " fmt, _dsp->name, ##__VA_ARGS__)
 
 #define compr_err(_obj, fmt, ...) \
 	adsp_err(_obj->dsp, "%s: " fmt, _obj->name ? _obj->name : "legacy", \
@@ -49,10 +50,300 @@
 	adsp_dbg(_obj->dsp, "%s: " fmt, _obj->name ? _obj->name : "legacy", \
 		 ##__VA_ARGS__)
 
+#define ADSP1_CONTROL_1                   0x00
+#define ADSP1_CONTROL_2                   0x02
+#define ADSP1_CONTROL_3                   0x03
+#define ADSP1_CONTROL_4                   0x04
+#define ADSP1_CONTROL_5                   0x06
+#define ADSP1_CONTROL_6                   0x07
+#define ADSP1_CONTROL_7                   0x08
+#define ADSP1_CONTROL_8                   0x09
+#define ADSP1_CONTROL_9                   0x0A
+#define ADSP1_CONTROL_10                  0x0B
+#define ADSP1_CONTROL_11                  0x0C
+#define ADSP1_CONTROL_12                  0x0D
+#define ADSP1_CONTROL_13                  0x0F
+#define ADSP1_CONTROL_14                  0x10
+#define ADSP1_CONTROL_15                  0x11
+#define ADSP1_CONTROL_16                  0x12
+#define ADSP1_CONTROL_17                  0x13
+#define ADSP1_CONTROL_18                  0x14
+#define ADSP1_CONTROL_19                  0x16
+#define ADSP1_CONTROL_20                  0x17
+#define ADSP1_CONTROL_21                  0x18
+#define ADSP1_CONTROL_22                  0x1A
+#define ADSP1_CONTROL_23                  0x1B
+#define ADSP1_CONTROL_24                  0x1C
+#define ADSP1_CONTROL_25                  0x1E
+#define ADSP1_CONTROL_26                  0x20
+#define ADSP1_CONTROL_27                  0x21
+#define ADSP1_CONTROL_28                  0x22
+#define ADSP1_CONTROL_29                  0x23
+#define ADSP1_CONTROL_30                  0x24
+#define ADSP1_CONTROL_31                  0x26
+
+/*
+ * ADSP1 Control 19
+ */
+#define ADSP1_WDMA_BUFFER_LENGTH_MASK     0x00FF  /* DSP1_WDMA_BUFFER_LENGTH - [7:0] */
+#define ADSP1_WDMA_BUFFER_LENGTH_SHIFT         0  /* DSP1_WDMA_BUFFER_LENGTH - [7:0] */
+#define ADSP1_WDMA_BUFFER_LENGTH_WIDTH         8  /* DSP1_WDMA_BUFFER_LENGTH - [7:0] */
+
+
+/*
+ * ADSP1 Control 30
+ */
+#define ADSP1_DBG_CLK_ENA                 0x0008  /* DSP1_DBG_CLK_ENA */
+#define ADSP1_DBG_CLK_ENA_MASK            0x0008  /* DSP1_DBG_CLK_ENA */
+#define ADSP1_DBG_CLK_ENA_SHIFT                3  /* DSP1_DBG_CLK_ENA */
+#define ADSP1_DBG_CLK_ENA_WIDTH                1  /* DSP1_DBG_CLK_ENA */
+#define ADSP1_SYS_ENA                     0x0004  /* DSP1_SYS_ENA */
+#define ADSP1_SYS_ENA_MASK                0x0004  /* DSP1_SYS_ENA */
+#define ADSP1_SYS_ENA_SHIFT                    2  /* DSP1_SYS_ENA */
+#define ADSP1_SYS_ENA_WIDTH                    1  /* DSP1_SYS_ENA */
+#define ADSP1_CORE_ENA                    0x0002  /* DSP1_CORE_ENA */
+#define ADSP1_CORE_ENA_MASK               0x0002  /* DSP1_CORE_ENA */
+#define ADSP1_CORE_ENA_SHIFT                   1  /* DSP1_CORE_ENA */
+#define ADSP1_CORE_ENA_WIDTH                   1  /* DSP1_CORE_ENA */
+#define ADSP1_START                       0x0001  /* DSP1_START */
+#define ADSP1_START_MASK                  0x0001  /* DSP1_START */
+#define ADSP1_START_SHIFT                      0  /* DSP1_START */
+#define ADSP1_START_WIDTH                      1  /* DSP1_START */
+
+/*
+ * ADSP1 Control 31
+ */
+#define ADSP1_CLK_SEL_MASK                0x0007  /* CLK_SEL_ENA */
+#define ADSP1_CLK_SEL_SHIFT                    0  /* CLK_SEL_ENA */
+#define ADSP1_CLK_SEL_WIDTH                    3  /* CLK_SEL_ENA */
+
+#define ADSP2_CONTROL                     0x0
+#define ADSP2_CLOCKING                    0x1
+#define ADSP2V2_CLOCKING                  0x2
+#define ADSP2_STATUS1                     0x4
+#define ADSP2_WDMA_CONFIG_1               0x30
+#define ADSP2_WDMA_CONFIG_2               0x31
+#define ADSP2V2_WDMA_CONFIG_2             0x32
+#define ADSP2_RDMA_CONFIG_1               0x34
+
+#define ADSP2_SCRATCH0                    0x40
+#define ADSP2_SCRATCH1                    0x41
+#define ADSP2_SCRATCH2                    0x42
+#define ADSP2_SCRATCH3                    0x43
+
+#define ADSP2V2_SCRATCH0_1                0x40
+#define ADSP2V2_SCRATCH2_3                0x42
+
+/*
+ * ADSP2 Control
+ */
+
+#define ADSP2_MEM_ENA                     0x0010  /* DSP1_MEM_ENA */
+#define ADSP2_MEM_ENA_MASK                0x0010  /* DSP1_MEM_ENA */
+#define ADSP2_MEM_ENA_SHIFT                    4  /* DSP1_MEM_ENA */
+#define ADSP2_MEM_ENA_WIDTH                    1  /* DSP1_MEM_ENA */
+#define ADSP2_SYS_ENA                     0x0004  /* DSP1_SYS_ENA */
+#define ADSP2_SYS_ENA_MASK                0x0004  /* DSP1_SYS_ENA */
+#define ADSP2_SYS_ENA_SHIFT                    2  /* DSP1_SYS_ENA */
+#define ADSP2_SYS_ENA_WIDTH                    1  /* DSP1_SYS_ENA */
+#define ADSP2_CORE_ENA                    0x0002  /* DSP1_CORE_ENA */
+#define ADSP2_CORE_ENA_MASK               0x0002  /* DSP1_CORE_ENA */
+#define ADSP2_CORE_ENA_SHIFT                   1  /* DSP1_CORE_ENA */
+#define ADSP2_CORE_ENA_WIDTH                   1  /* DSP1_CORE_ENA */
+#define ADSP2_START                       0x0001  /* DSP1_START */
+#define ADSP2_START_MASK                  0x0001  /* DSP1_START */
+#define ADSP2_START_SHIFT                      0  /* DSP1_START */
+#define ADSP2_START_WIDTH                      1  /* DSP1_START */
+
+/*
+ * ADSP2 clocking
+ */
+#define ADSP2_CLK_SEL_MASK                0x0007  /* CLK_SEL_ENA */
+#define ADSP2_CLK_SEL_SHIFT                    0  /* CLK_SEL_ENA */
+#define ADSP2_CLK_SEL_WIDTH                    3  /* CLK_SEL_ENA */
+
+/*
+ * ADSP2V2 clocking
+ */
+#define ADSP2V2_CLK_SEL_MASK             0x70000  /* CLK_SEL_ENA */
+#define ADSP2V2_CLK_SEL_SHIFT                 16  /* CLK_SEL_ENA */
+#define ADSP2V2_CLK_SEL_WIDTH                  3  /* CLK_SEL_ENA */
+
+#define ADSP2V2_RATE_MASK                 0x7800  /* DSP_RATE */
+#define ADSP2V2_RATE_SHIFT                    11  /* DSP_RATE */
+#define ADSP2V2_RATE_WIDTH                     4  /* DSP_RATE */
+
+/*
+ * ADSP2 Status 1
+ */
+#define ADSP2_RAM_RDY                     0x0001
+#define ADSP2_RAM_RDY_MASK                0x0001
+#define ADSP2_RAM_RDY_SHIFT                    0
+#define ADSP2_RAM_RDY_WIDTH                    1
+
+/*
+ * ADSP2 Lock support
+ */
+#define ADSP2_LOCK_CODE_0                    0x5555
+#define ADSP2_LOCK_CODE_1                    0xAAAA
+
+#define ADSP2_WATCHDOG                       0x0A
+#define ADSP2_BUS_ERR_ADDR                   0x52
+#define ADSP2_REGION_LOCK_STATUS             0x64
+#define ADSP2_LOCK_REGION_1_LOCK_REGION_0    0x66
+#define ADSP2_LOCK_REGION_3_LOCK_REGION_2    0x68
+#define ADSP2_LOCK_REGION_5_LOCK_REGION_4    0x6A
+#define ADSP2_LOCK_REGION_7_LOCK_REGION_6    0x6C
+#define ADSP2_LOCK_REGION_9_LOCK_REGION_8    0x6E
+#define ADSP2_LOCK_REGION_CTRL               0x7A
+#define ADSP2_PMEM_ERR_ADDR_XMEM_ERR_ADDR    0x7C
+
+#define ADSP2_REGION_LOCK_ERR_MASK           0x8000
+#define ADSP2_ADDR_ERR_MASK                  0x4000
+#define ADSP2_WDT_TIMEOUT_STS_MASK           0x2000
+#define ADSP2_CTRL_ERR_PAUSE_ENA             0x0002
+#define ADSP2_CTRL_ERR_EINT                  0x0001
+
+#define ADSP2_BUS_ERR_ADDR_MASK              0x00FFFFFF
+#define ADSP2_XMEM_ERR_ADDR_MASK             0x0000FFFF
+#define ADSP2_PMEM_ERR_ADDR_MASK             0x7FFF0000
+#define ADSP2_PMEM_ERR_ADDR_SHIFT            16
+#define ADSP2_WDT_ENA_MASK                   0xFFFFFFFD
+
+#define ADSP2_LOCK_REGION_SHIFT              16
+
 #define ADSP_MAX_STD_CTRL_SIZE               512
 
-static const struct cs_dsp_client_ops wm_adsp1_client_ops;
-static const struct cs_dsp_client_ops wm_adsp2_client_ops;
+#define WM_ADSP_ACKED_CTL_TIMEOUT_MS         100
+#define WM_ADSP_ACKED_CTL_N_QUICKPOLLS       10
+#define WM_ADSP_ACKED_CTL_MIN_VALUE          0
+#define WM_ADSP_ACKED_CTL_MAX_VALUE          0xFFFFFF
+
+/*
+ * Event control messages
+ */
+#define WM_ADSP_FW_EVENT_SHUTDOWN            0x000001
+
+/*
+ * HALO system info
+ */
+#define HALO_AHBM_WINDOW_DEBUG_0             0x02040
+#define HALO_AHBM_WINDOW_DEBUG_1             0x02044
+
+/*
+ * HALO core
+ */
+#define HALO_SCRATCH1                        0x005c0
+#define HALO_SCRATCH2                        0x005c8
+#define HALO_SCRATCH3                        0x005d0
+#define HALO_SCRATCH4                        0x005d8
+#define HALO_CCM_CORE_CONTROL                0x41000
+#define HALO_CORE_SOFT_RESET                 0x00010
+#define HALO_WDT_CONTROL                     0x47000
+
+/*
+ * HALO MPU banks
+ */
+#define HALO_MPU_XMEM_ACCESS_0               0x43000
+#define HALO_MPU_YMEM_ACCESS_0               0x43004
+#define HALO_MPU_WINDOW_ACCESS_0             0x43008
+#define HALO_MPU_XREG_ACCESS_0               0x4300C
+#define HALO_MPU_YREG_ACCESS_0               0x43014
+#define HALO_MPU_XMEM_ACCESS_1               0x43018
+#define HALO_MPU_YMEM_ACCESS_1               0x4301C
+#define HALO_MPU_WINDOW_ACCESS_1             0x43020
+#define HALO_MPU_XREG_ACCESS_1               0x43024
+#define HALO_MPU_YREG_ACCESS_1               0x4302C
+#define HALO_MPU_XMEM_ACCESS_2               0x43030
+#define HALO_MPU_YMEM_ACCESS_2               0x43034
+#define HALO_MPU_WINDOW_ACCESS_2             0x43038
+#define HALO_MPU_XREG_ACCESS_2               0x4303C
+#define HALO_MPU_YREG_ACCESS_2               0x43044
+#define HALO_MPU_XMEM_ACCESS_3               0x43048
+#define HALO_MPU_YMEM_ACCESS_3               0x4304C
+#define HALO_MPU_WINDOW_ACCESS_3             0x43050
+#define HALO_MPU_XREG_ACCESS_3               0x43054
+#define HALO_MPU_YREG_ACCESS_3               0x4305C
+#define HALO_MPU_XM_VIO_ADDR                 0x43100
+#define HALO_MPU_XM_VIO_STATUS               0x43104
+#define HALO_MPU_YM_VIO_ADDR                 0x43108
+#define HALO_MPU_YM_VIO_STATUS               0x4310C
+#define HALO_MPU_PM_VIO_ADDR                 0x43110
+#define HALO_MPU_PM_VIO_STATUS               0x43114
+#define HALO_MPU_LOCK_CONFIG                 0x43140
+
+/*
+ * HALO_AHBM_WINDOW_DEBUG_1
+ */
+#define HALO_AHBM_CORE_ERR_ADDR_MASK         0x0fffff00
+#define HALO_AHBM_CORE_ERR_ADDR_SHIFT                 8
+#define HALO_AHBM_FLAGS_ERR_MASK             0x000000ff
+
+/*
+ * HALO_CCM_CORE_CONTROL
+ */
+#define HALO_CORE_EN                        0x00000001
+
+/*
+ * HALO_CORE_SOFT_RESET
+ */
+#define HALO_CORE_SOFT_RESET_MASK           0x00000001
+
+/*
+ * HALO_WDT_CONTROL
+ */
+#define HALO_WDT_EN_MASK                    0x00000001
+
+/*
+ * HALO_MPU_?M_VIO_STATUS
+ */
+#define HALO_MPU_VIO_STS_MASK               0x007e0000
+#define HALO_MPU_VIO_STS_SHIFT                      17
+#define HALO_MPU_VIO_ERR_WR_MASK            0x00008000
+#define HALO_MPU_VIO_ERR_SRC_MASK           0x00007fff
+#define HALO_MPU_VIO_ERR_SRC_SHIFT                   0
+
+static struct wm_adsp_ops wm_adsp1_ops;
+static struct wm_adsp_ops wm_adsp2_ops[];
+static struct wm_adsp_ops wm_halo_ops;
+
+struct wm_adsp_buf {
+	struct list_head list;
+	void *buf;
+};
+
+static struct wm_adsp_buf *wm_adsp_buf_alloc(const void *src, size_t len,
+					     struct list_head *list)
+{
+	struct wm_adsp_buf *buf = kzalloc(sizeof(*buf), GFP_KERNEL);
+
+	if (buf == NULL)
+		return NULL;
+
+	buf->buf = vmalloc(len);
+	if (!buf->buf) {
+		kfree(buf);
+		return NULL;
+	}
+	memcpy(buf->buf, src, len);
+
+	if (list)
+		list_add_tail(&buf->list, list);
+
+	return buf;
+}
+
+static void wm_adsp_buf_free(struct list_head *list)
+{
+	while (!list_empty(list)) {
+		struct wm_adsp_buf *buf = list_first_entry(list,
+							   struct wm_adsp_buf,
+							   list);
+		list_del(&buf->list);
+		vfree(buf->buf);
+		kfree(buf);
+	}
+}
 
 #define WM_ADSP_FW_MBC_VSS  0
 #define WM_ADSP_FW_HIFI     1
@@ -178,10 +469,12 @@
 	const char *name;
 };
 
+#define WM_ADSP_DATA_WORD_SIZE         3
+
 #define WM_ADSP_MIN_FRAGMENTS          1
 #define WM_ADSP_MAX_FRAGMENTS          256
-#define WM_ADSP_MIN_FRAGMENT_SIZE      (64 * CS_DSP_DATA_WORD_SIZE)
-#define WM_ADSP_MAX_FRAGMENT_SIZE      (4096 * CS_DSP_DATA_WORD_SIZE)
+#define WM_ADSP_MIN_FRAGMENT_SIZE      (64 * WM_ADSP_DATA_WORD_SIZE)
+#define WM_ADSP_MAX_FRAGMENT_SIZE      (4096 * WM_ADSP_DATA_WORD_SIZE)
 
 #define WM_ADSP_ALG_XM_STRUCT_MAGIC    0x49aec7
 
@@ -304,11 +597,182 @@
 
 struct wm_coeff_ctl {
 	const char *name;
-	struct cs_dsp_coeff_ctl *cs_ctl;
+	const char *fw_name;
+	/* Subname is needed to match with firmware */
+	const char *subname;
+	unsigned int subname_len;
+	struct wm_adsp_alg_region alg_region;
+	struct wm_adsp *dsp;
+	unsigned int enabled:1;
+	struct list_head list;
+	void *cache;
+	unsigned int offset;
+	size_t len;
+	unsigned int set:1;
 	struct soc_bytes_ext bytes_ext;
-	struct work_struct work;
+	unsigned int flags;
+	snd_ctl_elem_type_t type;
 };
 
+static const char *wm_adsp_mem_region_name(unsigned int type)
+{
+	switch (type) {
+	case WMFW_ADSP1_PM:
+		return "PM";
+	case WMFW_HALO_PM_PACKED:
+		return "PM_PACKED";
+	case WMFW_ADSP1_DM:
+		return "DM";
+	case WMFW_ADSP2_XM:
+		return "XM";
+	case WMFW_HALO_XM_PACKED:
+		return "XM_PACKED";
+	case WMFW_ADSP2_YM:
+		return "YM";
+	case WMFW_HALO_YM_PACKED:
+		return "YM_PACKED";
+	case WMFW_ADSP1_ZM:
+		return "ZM";
+	default:
+		return NULL;
+	}
+}
+
+#ifdef CONFIG_DEBUG_FS
+static void wm_adsp_debugfs_save_wmfwname(struct wm_adsp *dsp, const char *s)
+{
+	char *tmp = kasprintf(GFP_KERNEL, "%s\n", s);
+
+	kfree(dsp->wmfw_file_name);
+	dsp->wmfw_file_name = tmp;
+}
+
+static void wm_adsp_debugfs_save_binname(struct wm_adsp *dsp, const char *s)
+{
+	char *tmp = kasprintf(GFP_KERNEL, "%s\n", s);
+
+	kfree(dsp->bin_file_name);
+	dsp->bin_file_name = tmp;
+}
+
+static void wm_adsp_debugfs_clear(struct wm_adsp *dsp)
+{
+	kfree(dsp->wmfw_file_name);
+	kfree(dsp->bin_file_name);
+	dsp->wmfw_file_name = NULL;
+	dsp->bin_file_name = NULL;
+}
+
+static ssize_t wm_adsp_debugfs_wmfw_read(struct file *file,
+					 char __user *user_buf,
+					 size_t count, loff_t *ppos)
+{
+	struct wm_adsp *dsp = file->private_data;
+	ssize_t ret;
+
+	mutex_lock(&dsp->pwr_lock);
+
+	if (!dsp->wmfw_file_name || !dsp->booted)
+		ret = 0;
+	else
+		ret = simple_read_from_buffer(user_buf, count, ppos,
+					      dsp->wmfw_file_name,
+					      strlen(dsp->wmfw_file_name));
+
+	mutex_unlock(&dsp->pwr_lock);
+	return ret;
+}
+
+static ssize_t wm_adsp_debugfs_bin_read(struct file *file,
+					char __user *user_buf,
+					size_t count, loff_t *ppos)
+{
+	struct wm_adsp *dsp = file->private_data;
+	ssize_t ret;
+
+	mutex_lock(&dsp->pwr_lock);
+
+	if (!dsp->bin_file_name || !dsp->booted)
+		ret = 0;
+	else
+		ret = simple_read_from_buffer(user_buf, count, ppos,
+					      dsp->bin_file_name,
+					      strlen(dsp->bin_file_name));
+
+	mutex_unlock(&dsp->pwr_lock);
+	return ret;
+}
+
+static const struct {
+	const char *name;
+	const struct file_operations fops;
+} wm_adsp_debugfs_fops[] = {
+	{
+		.name = "wmfw_file_name",
+		.fops = {
+			.open = simple_open,
+			.read = wm_adsp_debugfs_wmfw_read,
+		},
+	},
+	{
+		.name = "bin_file_name",
+		.fops = {
+			.open = simple_open,
+			.read = wm_adsp_debugfs_bin_read,
+		},
+	},
+};
+
+static void wm_adsp2_init_debugfs(struct wm_adsp *dsp,
+				  struct snd_soc_component *component)
+{
+	struct dentry *root = NULL;
+	int i;
+
+	root = debugfs_create_dir(dsp->name, component->debugfs_root);
+
+	debugfs_create_bool("booted", 0444, root, &dsp->booted);
+	debugfs_create_bool("running", 0444, root, &dsp->running);
+	debugfs_create_x32("fw_id", 0444, root, &dsp->fw_id);
+	debugfs_create_x32("fw_version", 0444, root, &dsp->fw_id_version);
+
+	for (i = 0; i < ARRAY_SIZE(wm_adsp_debugfs_fops); ++i)
+		debugfs_create_file(wm_adsp_debugfs_fops[i].name, 0444, root,
+				    dsp, &wm_adsp_debugfs_fops[i].fops);
+
+	dsp->debugfs_root = root;
+}
+
+static void wm_adsp2_cleanup_debugfs(struct wm_adsp *dsp)
+{
+	wm_adsp_debugfs_clear(dsp);
+	debugfs_remove_recursive(dsp->debugfs_root);
+}
+#else
+static inline void wm_adsp2_init_debugfs(struct wm_adsp *dsp,
+					 struct snd_soc_component *component)
+{
+}
+
+static inline void wm_adsp2_cleanup_debugfs(struct wm_adsp *dsp)
+{
+}
+
+static inline void wm_adsp_debugfs_save_wmfwname(struct wm_adsp *dsp,
+						 const char *s)
+{
+}
+
+static inline void wm_adsp_debugfs_save_binname(struct wm_adsp *dsp,
+						const char *s)
+{
+}
+
+static inline void wm_adsp_debugfs_clear(struct wm_adsp *dsp)
+{
+}
+#endif
+
 int wm_adsp_fw_get(struct snd_kcontrol *kcontrol,
 		   struct snd_ctl_elem_value *ucontrol)
 {
@@ -328,7 +792,7 @@
 	struct snd_soc_component *component = snd_soc_kcontrol_component(kcontrol);
 	struct soc_enum *e = (struct soc_enum *)kcontrol->private_value;
 	struct wm_adsp *dsp = snd_soc_component_get_drvdata(component);
-	int ret = 1;
+	int ret = 0;
 
 	if (ucontrol->value.enumerated.item[0] == dsp[e->shift_l].fw)
 		return 0;
@@ -336,14 +800,14 @@
 	if (ucontrol->value.enumerated.item[0] >= WM_ADSP_NUM_FW)
 		return -EINVAL;
 
-	mutex_lock(&dsp[e->shift_l].cs_dsp.pwr_lock);
+	mutex_lock(&dsp[e->shift_l].pwr_lock);
 
-	if (dsp[e->shift_l].cs_dsp.booted || !list_empty(&dsp[e->shift_l].compr_list))
+	if (dsp[e->shift_l].booted || !list_empty(&dsp[e->shift_l].compr_list))
 		ret = -EBUSY;
 	else
 		dsp[e->shift_l].fw = ucontrol->value.enumerated.item[0];
 
-	mutex_unlock(&dsp[e->shift_l].cs_dsp.pwr_lock);
+	mutex_unlock(&dsp[e->shift_l].pwr_lock);
 
 	return ret;
 }
@@ -360,49 +824,270 @@
 };
 EXPORT_SYMBOL_GPL(wm_adsp_fw_enum);
 
+static struct wm_adsp_region const *wm_adsp_find_region(struct wm_adsp *dsp,
+							int type)
+{
+	int i;
+
+	for (i = 0; i < dsp->num_mems; i++)
+		if (dsp->mem[i].type == type)
+			return &dsp->mem[i];
+
+	return NULL;
+}
+
+static unsigned int wm_adsp_region_to_reg(struct wm_adsp_region const *mem,
+					  unsigned int offset)
+{
+	switch (mem->type) {
+	case WMFW_ADSP1_PM:
+		return mem->base + (offset * 3);
+	case WMFW_ADSP1_DM:
+	case WMFW_ADSP2_XM:
+	case WMFW_ADSP2_YM:
+	case WMFW_ADSP1_ZM:
+		return mem->base + (offset * 2);
+	default:
+		WARN(1, "Unknown memory region type");
+		return offset;
+	}
+}
+
+static unsigned int wm_halo_region_to_reg(struct wm_adsp_region const *mem,
+					  unsigned int offset)
+{
+	switch (mem->type) {
+	case WMFW_ADSP2_XM:
+	case WMFW_ADSP2_YM:
+		return mem->base + (offset * 4);
+	case WMFW_HALO_XM_PACKED:
+	case WMFW_HALO_YM_PACKED:
+		return (mem->base + (offset * 3)) & ~0x3;
+	case WMFW_HALO_PM_PACKED:
+		return mem->base + (offset * 5);
+	default:
+		WARN(1, "Unknown memory region type");
+		return offset;
+	}
+}
+
+static void wm_adsp_read_fw_status(struct wm_adsp *dsp,
+				   int noffs, unsigned int *offs)
+{
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < noffs; ++i) {
+		ret = regmap_read(dsp->regmap, dsp->base + offs[i], &offs[i]);
+		if (ret) {
+			adsp_err(dsp, "Failed to read SCRATCH%u: %d\n", i, ret);
+			return;
+		}
+	}
+}
+
+static void wm_adsp2_show_fw_status(struct wm_adsp *dsp)
+{
+	unsigned int offs[] = {
+		ADSP2_SCRATCH0, ADSP2_SCRATCH1, ADSP2_SCRATCH2, ADSP2_SCRATCH3,
+	};
+
+	wm_adsp_read_fw_status(dsp, ARRAY_SIZE(offs), offs);
+
+	adsp_dbg(dsp, "FW SCRATCH 0:0x%x 1:0x%x 2:0x%x 3:0x%x\n",
+		 offs[0], offs[1], offs[2], offs[3]);
+}
+
+static void wm_adsp2v2_show_fw_status(struct wm_adsp *dsp)
+{
+	unsigned int offs[] = { ADSP2V2_SCRATCH0_1, ADSP2V2_SCRATCH2_3 };
+
+	wm_adsp_read_fw_status(dsp, ARRAY_SIZE(offs), offs);
+
+	adsp_dbg(dsp, "FW SCRATCH 0:0x%x 1:0x%x 2:0x%x 3:0x%x\n",
+		 offs[0] & 0xFFFF, offs[0] >> 16,
+		 offs[1] & 0xFFFF, offs[1] >> 16);
+}
+
+static void wm_halo_show_fw_status(struct wm_adsp *dsp)
+{
+	unsigned int offs[] = {
+		HALO_SCRATCH1, HALO_SCRATCH2, HALO_SCRATCH3, HALO_SCRATCH4,
+	};
+
+	wm_adsp_read_fw_status(dsp, ARRAY_SIZE(offs), offs);
+
+	adsp_dbg(dsp, "FW SCRATCH 0:0x%x 1:0x%x 2:0x%x 3:0x%x\n",
+		 offs[0], offs[1], offs[2], offs[3]);
+}
+
 static inline struct wm_coeff_ctl *bytes_ext_to_ctl(struct soc_bytes_ext *ext)
 {
 	return container_of(ext, struct wm_coeff_ctl, bytes_ext);
 }
 
+static int wm_coeff_base_reg(struct wm_coeff_ctl *ctl, unsigned int *reg)
+{
+	const struct wm_adsp_alg_region *alg_region = &ctl->alg_region;
+	struct wm_adsp *dsp = ctl->dsp;
+	const struct wm_adsp_region *mem;
+
+	mem = wm_adsp_find_region(dsp, alg_region->type);
+	if (!mem) {
+		adsp_err(dsp, "No base for region %x\n",
+			 alg_region->type);
+		return -EINVAL;
+	}
+
+	*reg = dsp->ops->region_to_reg(mem, ctl->alg_region.base + ctl->offset);
+
+	return 0;
+}
+
 static int wm_coeff_info(struct snd_kcontrol *kctl,
 			 struct snd_ctl_elem_info *uinfo)
 {
 	struct soc_bytes_ext *bytes_ext =
 		(struct soc_bytes_ext *)kctl->private_value;
 	struct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);
-	struct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;
 
-	switch (cs_ctl->type) {
+	switch (ctl->type) {
 	case WMFW_CTL_TYPE_ACKED:
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
-		uinfo->value.integer.min = CS_DSP_ACKED_CTL_MIN_VALUE;
-		uinfo->value.integer.max = CS_DSP_ACKED_CTL_MAX_VALUE;
+		uinfo->value.integer.min = WM_ADSP_ACKED_CTL_MIN_VALUE;
+		uinfo->value.integer.max = WM_ADSP_ACKED_CTL_MAX_VALUE;
 		uinfo->value.integer.step = 1;
 		uinfo->count = 1;
 		break;
 	default:
 		uinfo->type = SNDRV_CTL_ELEM_TYPE_BYTES;
-		uinfo->count = cs_ctl->len;
+		uinfo->count = ctl->len;
 		break;
 	}
 
 	return 0;
 }
 
+static int wm_coeff_write_acked_control(struct wm_coeff_ctl *ctl,
+					unsigned int event_id)
+{
+	struct wm_adsp *dsp = ctl->dsp;
+	__be32 val = cpu_to_be32(event_id);
+	unsigned int reg;
+	int i, ret;
+
+	ret = wm_coeff_base_reg(ctl, &reg);
+	if (ret)
+		return ret;
+
+	adsp_dbg(dsp, "Sending 0x%x to acked control alg 0x%x %s:0x%x\n",
+		 event_id, ctl->alg_region.alg,
+		 wm_adsp_mem_region_name(ctl->alg_region.type), ctl->offset);
+
+	ret = regmap_raw_write(dsp->regmap, reg, &val, sizeof(val));
+	if (ret) {
+		adsp_err(dsp, "Failed to write %x: %d\n", reg, ret);
+		return ret;
+	}
+
+	/*
+	 * Poll for ack, we initially poll at ~1ms intervals for firmwares
+	 * that respond quickly, then go to ~10ms polls. A firmware is unlikely
+	 * to ack instantly so we do the first 1ms delay before reading the
+	 * control to avoid a pointless bus transaction
+	 */
+	for (i = 0; i < WM_ADSP_ACKED_CTL_TIMEOUT_MS;) {
+		switch (i) {
+		case 0 ... WM_ADSP_ACKED_CTL_N_QUICKPOLLS - 1:
+			usleep_range(1000, 2000);
+			i++;
+			break;
+		default:
+			usleep_range(10000, 20000);
+			i += 10;
+			break;
+		}
+
+		ret = regmap_raw_read(dsp->regmap, reg, &val, sizeof(val));
+		if (ret) {
+			adsp_err(dsp, "Failed to read %x: %d\n", reg, ret);
+			return ret;
+		}
+
+		if (val == 0) {
+			adsp_dbg(dsp, "Acked control ACKED at poll %u\n", i);
+			return 0;
+		}
+	}
+
+	adsp_warn(dsp, "Acked control @0x%x alg:0x%x %s:0x%x timed out\n",
+		  reg, ctl->alg_region.alg,
+		  wm_adsp_mem_region_name(ctl->alg_region.type),
+		  ctl->offset);
+
+	return -ETIMEDOUT;
+}
+
+static int wm_coeff_write_ctrl_raw(struct wm_coeff_ctl *ctl,
+				   const void *buf, size_t len)
+{
+	struct wm_adsp *dsp = ctl->dsp;
+	void *scratch;
+	int ret;
+	unsigned int reg;
+
+	ret = wm_coeff_base_reg(ctl, &reg);
+	if (ret)
+		return ret;
+
+	scratch = kmemdup(buf, len, GFP_KERNEL | GFP_DMA);
+	if (!scratch)
+		return -ENOMEM;
+
+	ret = regmap_raw_write(dsp->regmap, reg, scratch,
+			       len);
+	if (ret) {
+		adsp_err(dsp, "Failed to write %zu bytes to %x: %d\n",
+			 len, reg, ret);
+		kfree(scratch);
+		return ret;
+	}
+	adsp_dbg(dsp, "Wrote %zu bytes to %x\n", len, reg);
+
+	kfree(scratch);
+
+	return 0;
+}
+
+static int wm_coeff_write_ctrl(struct wm_coeff_ctl *ctl,
+			       const void *buf, size_t len)
+{
+	int ret = 0;
+
+	if (ctl->flags & WMFW_CTL_FLAG_VOLATILE)
+		ret = -EPERM;
+	else if (buf != ctl->cache)
+		memcpy(ctl->cache, buf, len);
+
+	ctl->set = 1;
+	if (ctl->enabled && ctl->dsp->running)
+		ret = wm_coeff_write_ctrl_raw(ctl, buf, len);
+
+	return ret;
+}
+
 static int wm_coeff_put(struct snd_kcontrol *kctl,
 			struct snd_ctl_elem_value *ucontrol)
 {
 	struct soc_bytes_ext *bytes_ext =
 		(struct soc_bytes_ext *)kctl->private_value;
 	struct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);
-	struct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;
 	char *p = ucontrol->value.bytes.data;
 	int ret = 0;
 
-	mutex_lock(&cs_ctl->dsp->pwr_lock);
-	ret = cs_dsp_coeff_write_ctrl(cs_ctl, 0, p, cs_ctl->len);
-	mutex_unlock(&cs_ctl->dsp->pwr_lock);
+	mutex_lock(&ctl->dsp->pwr_lock);
+	ret = wm_coeff_write_ctrl(ctl, p, ctl->len);
+	mutex_unlock(&ctl->dsp->pwr_lock);
 
 	return ret;
 }
@@ -413,17 +1098,16 @@
 	struct soc_bytes_ext *bytes_ext =
 		(struct soc_bytes_ext *)kctl->private_value;
 	struct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);
-	struct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;
 	int ret = 0;
 
-	mutex_lock(&cs_ctl->dsp->pwr_lock);
+	mutex_lock(&ctl->dsp->pwr_lock);
 
-	if (copy_from_user(cs_ctl->cache, bytes, size))
+	if (copy_from_user(ctl->cache, bytes, size))
 		ret = -EFAULT;
 	else
-		ret = cs_dsp_coeff_write_ctrl(cs_ctl, 0, cs_ctl->cache, size);
+		ret = wm_coeff_write_ctrl(ctl, ctl->cache, size);
 
-	mutex_unlock(&cs_ctl->dsp->pwr_lock);
+	mutex_unlock(&ctl->dsp->pwr_lock);
 
 	return ret;
 }
@@ -434,21 +1118,71 @@
 	struct soc_bytes_ext *bytes_ext =
 		(struct soc_bytes_ext *)kctl->private_value;
 	struct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);
-	struct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;
 	unsigned int val = ucontrol->value.integer.value[0];
 	int ret;
 
 	if (val == 0)
 		return 0;	/* 0 means no event */
 
-	mutex_lock(&cs_ctl->dsp->pwr_lock);
+	mutex_lock(&ctl->dsp->pwr_lock);
 
-	if (cs_ctl->enabled)
-		ret = cs_dsp_coeff_write_acked_control(cs_ctl, val);
+	if (ctl->enabled && ctl->dsp->running)
+		ret = wm_coeff_write_acked_control(ctl, val);
 	else
 		ret = -EPERM;
 
-	mutex_unlock(&cs_ctl->dsp->pwr_lock);
+	mutex_unlock(&ctl->dsp->pwr_lock);
+
+	return ret;
+}
+
+static int wm_coeff_read_ctrl_raw(struct wm_coeff_ctl *ctl,
+				  void *buf, size_t len)
+{
+	struct wm_adsp *dsp = ctl->dsp;
+	void *scratch;
+	int ret;
+	unsigned int reg;
+
+	ret = wm_coeff_base_reg(ctl, &reg);
+	if (ret)
+		return ret;
+
+	scratch = kmalloc(len, GFP_KERNEL | GFP_DMA);
+	if (!scratch)
+		return -ENOMEM;
+
+	ret = regmap_raw_read(dsp->regmap, reg, scratch, len);
+	if (ret) {
+		adsp_err(dsp, "Failed to read %zu bytes from %x: %d\n",
+			 len, reg, ret);
+		kfree(scratch);
+		return ret;
+	}
+	adsp_dbg(dsp, "Read %zu bytes from %x\n", len, reg);
+
+	memcpy(buf, scratch, len);
+	kfree(scratch);
+
+	return 0;
+}
+
+static int wm_coeff_read_ctrl(struct wm_coeff_ctl *ctl, void *buf, size_t len)
+{
+	int ret = 0;
+
+	if (ctl->flags & WMFW_CTL_FLAG_VOLATILE) {
+		if (ctl->enabled && ctl->dsp->running)
+			return wm_coeff_read_ctrl_raw(ctl, buf, len);
+		else
+			return -EPERM;
+	} else {
+		if (!ctl->flags && ctl->enabled && ctl->dsp->running)
+			ret = wm_coeff_read_ctrl_raw(ctl, ctl->cache, ctl->len);
+
+		if (buf != ctl->cache)
+			memcpy(buf, ctl->cache, len);
+	}
 
 	return ret;
 }
@@ -459,13 +1193,12 @@
 	struct soc_bytes_ext *bytes_ext =
 		(struct soc_bytes_ext *)kctl->private_value;
 	struct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);
-	struct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;
 	char *p = ucontrol->value.bytes.data;
 	int ret;
 
-	mutex_lock(&cs_ctl->dsp->pwr_lock);
-	ret = cs_dsp_coeff_read_ctrl(cs_ctl, 0, p, cs_ctl->len);
-	mutex_unlock(&cs_ctl->dsp->pwr_lock);
+	mutex_lock(&ctl->dsp->pwr_lock);
+	ret = wm_coeff_read_ctrl(ctl, p, ctl->len);
+	mutex_unlock(&ctl->dsp->pwr_lock);
 
 	return ret;
 }
@@ -476,17 +1209,16 @@
 	struct soc_bytes_ext *bytes_ext =
 		(struct soc_bytes_ext *)kctl->private_value;
 	struct wm_coeff_ctl *ctl = bytes_ext_to_ctl(bytes_ext);
-	struct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;
 	int ret = 0;
 
-	mutex_lock(&cs_ctl->dsp->pwr_lock);
+	mutex_lock(&ctl->dsp->pwr_lock);
 
-	ret = cs_dsp_coeff_read_ctrl(cs_ctl, 0, cs_ctl->cache, size);
+	ret = wm_coeff_read_ctrl_raw(ctl, ctl->cache, size);
 
-	if (!ret && copy_to_user(bytes, cs_ctl->cache, size))
+	if (!ret && copy_to_user(bytes, ctl->cache, size))
 		ret = -EFAULT;
 
-	mutex_unlock(&cs_ctl->dsp->pwr_lock);
+	mutex_unlock(&ctl->dsp->pwr_lock);
 
 	return ret;
 }
@@ -506,6 +1238,12 @@
 	return 0;
 }
 
+struct wmfw_ctl_work {
+	struct wm_adsp *dsp;
+	struct wm_coeff_ctl *ctl;
+	struct work_struct work;
+};
+
 static unsigned int wmfw_convert_flags(unsigned int in, unsigned int len)
 {
 	unsigned int out, rd, wr, vol;
@@ -537,36 +1275,33 @@
 	return out;
 }
 
-static void wm_adsp_ctl_work(struct work_struct *work)
+static int wmfw_add_ctl(struct wm_adsp *dsp, struct wm_coeff_ctl *ctl)
 {
-	struct wm_coeff_ctl *ctl = container_of(work,
-						struct wm_coeff_ctl,
-						work);
-	struct cs_dsp_coeff_ctl *cs_ctl = ctl->cs_ctl;
-	struct wm_adsp *dsp = container_of(cs_ctl->dsp,
-					   struct wm_adsp,
-					   cs_dsp);
 	struct snd_kcontrol_new *kcontrol;
+	int ret;
+
+	if (!ctl || !ctl->name)
+		return -EINVAL;
 
 	kcontrol = kzalloc(sizeof(*kcontrol), GFP_KERNEL);
 	if (!kcontrol)
-		return;
+		return -ENOMEM;
 
 	kcontrol->name = ctl->name;
 	kcontrol->info = wm_coeff_info;
 	kcontrol->iface = SNDRV_CTL_ELEM_IFACE_MIXER;
 	kcontrol->tlv.c = snd_soc_bytes_tlv_callback;
 	kcontrol->private_value = (unsigned long)&ctl->bytes_ext;
-	kcontrol->access = wmfw_convert_flags(cs_ctl->flags, cs_ctl->len);
+	kcontrol->access = wmfw_convert_flags(ctl->flags, ctl->len);
 
-	switch (cs_ctl->type) {
+	switch (ctl->type) {
 	case WMFW_CTL_TYPE_ACKED:
 		kcontrol->get = wm_coeff_get_acked;
 		kcontrol->put = wm_coeff_put_acked;
 		break;
 	default:
 		if (kcontrol->access & SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK) {
-			ctl->bytes_ext.max = cs_ctl->len;
+			ctl->bytes_ext.max = ctl->len;
 			ctl->bytes_ext.get = wm_coeff_tlv_get;
 			ctl->bytes_ext.put = wm_coeff_tlv_put;
 		} else {
@@ -576,49 +1311,141 @@
 		break;
 	}
 
-	snd_soc_add_component_controls(dsp->component, kcontrol, 1);
+	ret = snd_soc_add_component_controls(dsp->component, kcontrol, 1);
+	if (ret < 0)
+		goto err_kcontrol;
+
+	kfree(kcontrol);
+
+	return 0;
 
+err_kcontrol:
 	kfree(kcontrol);
+	return ret;
 }
 
-static int wm_adsp_control_add(struct cs_dsp_coeff_ctl *cs_ctl)
+static int wm_coeff_init_control_caches(struct wm_adsp *dsp)
 {
-	struct wm_adsp *dsp = container_of(cs_ctl->dsp, struct wm_adsp, cs_dsp);
-	struct cs_dsp *cs_dsp = &dsp->cs_dsp;
 	struct wm_coeff_ctl *ctl;
+	int ret;
+
+	list_for_each_entry(ctl, &dsp->ctl_list, list) {
+		if (!ctl->enabled || ctl->set)
+			continue;
+		if (ctl->flags & WMFW_CTL_FLAG_VOLATILE)
+			continue;
+
+		/*
+		 * For readable controls populate the cache from the DSP memory.
+		 * For non-readable controls the cache was zero-filled when
+		 * created so we don't need to do anything.
+		 */
+		if (!ctl->flags || (ctl->flags & WMFW_CTL_FLAG_READABLE)) {
+			ret = wm_coeff_read_ctrl_raw(ctl, ctl->cache, ctl->len);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+static int wm_coeff_sync_controls(struct wm_adsp *dsp)
+{
+	struct wm_coeff_ctl *ctl;
+	int ret;
+
+	list_for_each_entry(ctl, &dsp->ctl_list, list) {
+		if (!ctl->enabled)
+			continue;
+		if (ctl->set && !(ctl->flags & WMFW_CTL_FLAG_VOLATILE)) {
+			ret = wm_coeff_write_ctrl_raw(ctl, ctl->cache,
+						      ctl->len);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+static void wm_adsp_signal_event_controls(struct wm_adsp *dsp,
+					  unsigned int event)
+{
+	struct wm_coeff_ctl *ctl;
+	int ret;
+
+	list_for_each_entry(ctl, &dsp->ctl_list, list) {
+		if (ctl->type != WMFW_CTL_TYPE_HOSTEVENT)
+			continue;
+
+		if (!ctl->enabled)
+			continue;
+
+		ret = wm_coeff_write_acked_control(ctl, event);
+		if (ret)
+			adsp_warn(dsp,
+				  "Failed to send 0x%x event to alg 0x%x (%d)\n",
+				  event, ctl->alg_region.alg, ret);
+	}
+}
+
+static void wm_adsp_ctl_work(struct work_struct *work)
+{
+	struct wmfw_ctl_work *ctl_work = container_of(work,
+						      struct wmfw_ctl_work,
+						      work);
+
+	wmfw_add_ctl(ctl_work->dsp, ctl_work->ctl);
+	kfree(ctl_work);
+}
+
+static void wm_adsp_free_ctl_blk(struct wm_coeff_ctl *ctl)
+{
+	kfree(ctl->cache);
+	kfree(ctl->name);
+	kfree(ctl->subname);
+	kfree(ctl);
+}
+
+static int wm_adsp_create_control(struct wm_adsp *dsp,
+				  const struct wm_adsp_alg_region *alg_region,
+				  unsigned int offset, unsigned int len,
+				  const char *subname, unsigned int subname_len,
+				  unsigned int flags, snd_ctl_elem_type_t type)
+{
+	struct wm_coeff_ctl *ctl;
+	struct wmfw_ctl_work *ctl_work;
 	char name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
 	const char *region_name;
 	int ret;
 
-	if (cs_ctl->flags & WMFW_CTL_FLAG_SYS)
-		return 0;
-
-	region_name = cs_dsp_mem_region_name(cs_ctl->alg_region.type);
+	region_name = wm_adsp_mem_region_name(alg_region->type);
 	if (!region_name) {
-		adsp_err(dsp, "Unknown region type: %d\n", cs_ctl->alg_region.type);
+		adsp_err(dsp, "Unknown region type: %d\n", alg_region->type);
 		return -EINVAL;
 	}
 
-	switch (cs_dsp->fw_ver) {
+	switch (dsp->fw_ver) {
 	case 0:
 	case 1:
-		ret = scnprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN,
-				"%s %s %x", cs_dsp->name, region_name,
-				cs_ctl->alg_region.alg);
+		snprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN, "%s %s %x",
+			 dsp->name, region_name, alg_region->alg);
+		subname = NULL; /* don't append subname */
 		break;
 	case 2:
 		ret = scnprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN,
-				"%s%c %.12s %x", cs_dsp->name, *region_name,
-				wm_adsp_fw_text[dsp->fw], cs_ctl->alg_region.alg);
+				"%s%c %.12s %x", dsp->name, *region_name,
+				wm_adsp_fw_text[dsp->fw], alg_region->alg);
 		break;
 	default:
 		ret = scnprintf(name, SNDRV_CTL_ELEM_ID_NAME_MAXLEN,
-				"%s %.12s %x", cs_dsp->name,
-				wm_adsp_fw_text[dsp->fw], cs_ctl->alg_region.alg);
+				"%s %.12s %x", dsp->name,
+				wm_adsp_fw_text[dsp->fw], alg_region->alg);
 		break;
 	}
 
-	if (cs_ctl->subname) {
+	if (subname) {
 		int avail = SNDRV_CTL_ELEM_ID_NAME_MAXLEN - ret - 2;
 		int skip = 0;
 
@@ -626,70 +1453,614 @@
 			avail -= strlen(dsp->component->name_prefix) + 1;
 
 		/* Truncate the subname from the start if it is too long */
-		if (cs_ctl->subname_len > avail)
-			skip = cs_ctl->subname_len - avail;
+		if (subname_len > avail)
+			skip = subname_len - avail;
 
 		snprintf(name + ret, SNDRV_CTL_ELEM_ID_NAME_MAXLEN - ret,
-			 " %.*s", cs_ctl->subname_len - skip, cs_ctl->subname + skip);
+			 " %.*s", subname_len - skip, subname + skip);
+	}
+
+	list_for_each_entry(ctl, &dsp->ctl_list, list) {
+		if (!strcmp(ctl->name, name)) {
+			if (!ctl->enabled)
+				ctl->enabled = 1;
+			return 0;
+		}
 	}
 
 	ctl = kzalloc(sizeof(*ctl), GFP_KERNEL);
 	if (!ctl)
 		return -ENOMEM;
-	ctl->cs_ctl = cs_ctl;
-
+	ctl->fw_name = wm_adsp_fw_text[dsp->fw];
+	ctl->alg_region = *alg_region;
 	ctl->name = kmemdup(name, strlen(name) + 1, GFP_KERNEL);
 	if (!ctl->name) {
 		ret = -ENOMEM;
 		goto err_ctl;
 	}
+	if (subname) {
+		ctl->subname_len = subname_len;
+		ctl->subname = kmemdup(subname,
+				       strlen(subname) + 1, GFP_KERNEL);
+		if (!ctl->subname) {
+			ret = -ENOMEM;
+			goto err_ctl_name;
+		}
+	}
+	ctl->enabled = 1;
+	ctl->set = 0;
+	ctl->dsp = dsp;
+
+	ctl->flags = flags;
+	ctl->type = type;
+	ctl->offset = offset;
+	ctl->len = len;
+	ctl->cache = kzalloc(ctl->len, GFP_KERNEL);
+	if (!ctl->cache) {
+		ret = -ENOMEM;
+		goto err_ctl_subname;
+	}
 
-	cs_ctl->priv = ctl;
+	list_add(&ctl->list, &dsp->ctl_list);
+
+	if (flags & WMFW_CTL_FLAG_SYS)
+		return 0;
+
+	ctl_work = kzalloc(sizeof(*ctl_work), GFP_KERNEL);
+	if (!ctl_work) {
+		ret = -ENOMEM;
+		goto err_list_del;
+	}
 
-	INIT_WORK(&ctl->work, wm_adsp_ctl_work);
-	schedule_work(&ctl->work);
+	ctl_work->dsp = dsp;
+	ctl_work->ctl = ctl;
+	INIT_WORK(&ctl_work->work, wm_adsp_ctl_work);
+	schedule_work(&ctl_work->work);
 
 	return 0;
 
+err_list_del:
+	list_del(&ctl->list);
+	kfree(ctl->cache);
+err_ctl_subname:
+	kfree(ctl->subname);
+err_ctl_name:
+	kfree(ctl->name);
 err_ctl:
 	kfree(ctl);
 
 	return ret;
 }
 
-static void wm_adsp_control_remove(struct cs_dsp_coeff_ctl *cs_ctl)
+struct wm_coeff_parsed_alg {
+	int id;
+	const u8 *name;
+	int name_len;
+	int ncoeff;
+};
+
+struct wm_coeff_parsed_coeff {
+	int offset;
+	int mem_type;
+	const u8 *name;
+	int name_len;
+	snd_ctl_elem_type_t ctl_type;
+	int flags;
+	int len;
+};
+
+static int wm_coeff_parse_string(int bytes, const u8 **pos, const u8 **str)
 {
-	struct wm_coeff_ctl *ctl = cs_ctl->priv;
+	int length;
 
-	cancel_work_sync(&ctl->work);
+	switch (bytes) {
+	case 1:
+		length = **pos;
+		break;
+	case 2:
+		length = le16_to_cpu(*((__le16 *)*pos));
+		break;
+	default:
+		return 0;
+	}
 
-	kfree(ctl->name);
-	kfree(ctl);
+	if (str)
+		*str = *pos + bytes;
+
+	*pos += ((length + bytes) + 3) & ~0x03;
+
+	return length;
+}
+
+static int wm_coeff_parse_int(int bytes, const u8 **pos)
+{
+	int val = 0;
+
+	switch (bytes) {
+	case 2:
+		val = le16_to_cpu(*((__le16 *)*pos));
+		break;
+	case 4:
+		val = le32_to_cpu(*((__le32 *)*pos));
+		break;
+	default:
+		break;
+	}
+
+	*pos += bytes;
+
+	return val;
+}
+
+static inline void wm_coeff_parse_alg(struct wm_adsp *dsp, const u8 **data,
+				      struct wm_coeff_parsed_alg *blk)
+{
+	const struct wmfw_adsp_alg_data *raw;
+
+	switch (dsp->fw_ver) {
+	case 0:
+	case 1:
+		raw = (const struct wmfw_adsp_alg_data *)*data;
+		*data = raw->data;
+
+		blk->id = le32_to_cpu(raw->id);
+		blk->name = raw->name;
+		blk->name_len = strlen(raw->name);
+		blk->ncoeff = le32_to_cpu(raw->ncoeff);
+		break;
+	default:
+		blk->id = wm_coeff_parse_int(sizeof(raw->id), data);
+		blk->name_len = wm_coeff_parse_string(sizeof(u8), data,
+						      &blk->name);
+		wm_coeff_parse_string(sizeof(u16), data, NULL);
+		blk->ncoeff = wm_coeff_parse_int(sizeof(raw->ncoeff), data);
+		break;
+	}
+
+	adsp_dbg(dsp, "Algorithm ID: %#x\n", blk->id);
+	adsp_dbg(dsp, "Algorithm name: %.*s\n", blk->name_len, blk->name);
+	adsp_dbg(dsp, "# of coefficient descriptors: %#x\n", blk->ncoeff);
+}
+
+static inline void wm_coeff_parse_coeff(struct wm_adsp *dsp, const u8 **data,
+					struct wm_coeff_parsed_coeff *blk)
+{
+	const struct wmfw_adsp_coeff_data *raw;
+	const u8 *tmp;
+	int length;
+
+	switch (dsp->fw_ver) {
+	case 0:
+	case 1:
+		raw = (const struct wmfw_adsp_coeff_data *)*data;
+		*data = *data + sizeof(raw->hdr) + le32_to_cpu(raw->hdr.size);
+
+		blk->offset = le16_to_cpu(raw->hdr.offset);
+		blk->mem_type = le16_to_cpu(raw->hdr.type);
+		blk->name = raw->name;
+		blk->name_len = strlen(raw->name);
+		blk->ctl_type = (__force snd_ctl_elem_type_t)le16_to_cpu(raw->ctl_type);
+		blk->flags = le16_to_cpu(raw->flags);
+		blk->len = le32_to_cpu(raw->len);
+		break;
+	default:
+		tmp = *data;
+		blk->offset = wm_coeff_parse_int(sizeof(raw->hdr.offset), &tmp);
+		blk->mem_type = wm_coeff_parse_int(sizeof(raw->hdr.type), &tmp);
+		length = wm_coeff_parse_int(sizeof(raw->hdr.size), &tmp);
+		blk->name_len = wm_coeff_parse_string(sizeof(u8), &tmp,
+						      &blk->name);
+		wm_coeff_parse_string(sizeof(u8), &tmp, NULL);
+		wm_coeff_parse_string(sizeof(u16), &tmp, NULL);
+		blk->ctl_type =
+			(__force snd_ctl_elem_type_t)wm_coeff_parse_int(sizeof(raw->ctl_type),
+									&tmp);
+		blk->flags = wm_coeff_parse_int(sizeof(raw->flags), &tmp);
+		blk->len = wm_coeff_parse_int(sizeof(raw->len), &tmp);
+
+		*data = *data + sizeof(raw->hdr) + length;
+		break;
+	}
+
+	adsp_dbg(dsp, "\tCoefficient type: %#x\n", blk->mem_type);
+	adsp_dbg(dsp, "\tCoefficient offset: %#x\n", blk->offset);
+	adsp_dbg(dsp, "\tCoefficient name: %.*s\n", blk->name_len, blk->name);
+	adsp_dbg(dsp, "\tCoefficient flags: %#x\n", blk->flags);
+	adsp_dbg(dsp, "\tALSA control type: %#x\n", blk->ctl_type);
+	adsp_dbg(dsp, "\tALSA control len: %#x\n", blk->len);
+}
+
+static int wm_adsp_check_coeff_flags(struct wm_adsp *dsp,
+				const struct wm_coeff_parsed_coeff *coeff_blk,
+				unsigned int f_required,
+				unsigned int f_illegal)
+{
+	if ((coeff_blk->flags & f_illegal) ||
+	    ((coeff_blk->flags & f_required) != f_required)) {
+		adsp_err(dsp, "Illegal flags 0x%x for control type 0x%x\n",
+			 coeff_blk->flags, coeff_blk->ctl_type);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int wm_adsp_parse_coeff(struct wm_adsp *dsp,
+			       const struct wmfw_region *region)
+{
+	struct wm_adsp_alg_region alg_region = {};
+	struct wm_coeff_parsed_alg alg_blk;
+	struct wm_coeff_parsed_coeff coeff_blk;
+	const u8 *data = region->data;
+	int i, ret;
+
+	wm_coeff_parse_alg(dsp, &data, &alg_blk);
+	for (i = 0; i < alg_blk.ncoeff; i++) {
+		wm_coeff_parse_coeff(dsp, &data, &coeff_blk);
+
+		switch (coeff_blk.ctl_type) {
+		case SNDRV_CTL_ELEM_TYPE_BYTES:
+			break;
+		case WMFW_CTL_TYPE_ACKED:
+			if (coeff_blk.flags & WMFW_CTL_FLAG_SYS)
+				continue;	/* ignore */
+
+			ret = wm_adsp_check_coeff_flags(dsp, &coeff_blk,
+						WMFW_CTL_FLAG_VOLATILE |
+						WMFW_CTL_FLAG_WRITEABLE |
+						WMFW_CTL_FLAG_READABLE,
+						0);
+			if (ret)
+				return -EINVAL;
+			break;
+		case WMFW_CTL_TYPE_HOSTEVENT:
+			ret = wm_adsp_check_coeff_flags(dsp, &coeff_blk,
+						WMFW_CTL_FLAG_SYS |
+						WMFW_CTL_FLAG_VOLATILE |
+						WMFW_CTL_FLAG_WRITEABLE |
+						WMFW_CTL_FLAG_READABLE,
+						0);
+			if (ret)
+				return -EINVAL;
+			break;
+		case WMFW_CTL_TYPE_HOST_BUFFER:
+			ret = wm_adsp_check_coeff_flags(dsp, &coeff_blk,
+						WMFW_CTL_FLAG_SYS |
+						WMFW_CTL_FLAG_VOLATILE |
+						WMFW_CTL_FLAG_READABLE,
+						0);
+			if (ret)
+				return -EINVAL;
+			break;
+		default:
+			adsp_err(dsp, "Unknown control type: %d\n",
+				 coeff_blk.ctl_type);
+			return -EINVAL;
+		}
+
+		alg_region.type = coeff_blk.mem_type;
+		alg_region.alg = alg_blk.id;
+
+		ret = wm_adsp_create_control(dsp, &alg_region,
+					     coeff_blk.offset,
+					     coeff_blk.len,
+					     coeff_blk.name,
+					     coeff_blk.name_len,
+					     coeff_blk.flags,
+					     coeff_blk.ctl_type);
+		if (ret < 0)
+			adsp_err(dsp, "Failed to create control: %.*s, %d\n",
+				 coeff_blk.name_len, coeff_blk.name, ret);
+	}
+
+	return 0;
+}
+
+static unsigned int wm_adsp1_parse_sizes(struct wm_adsp *dsp,
+					 const char * const file,
+					 unsigned int pos,
+					 const struct firmware *firmware)
+{
+	const struct wmfw_adsp1_sizes *adsp1_sizes;
+
+	adsp1_sizes = (void *)&firmware->data[pos];
+
+	adsp_dbg(dsp, "%s: %d DM, %d PM, %d ZM\n", file,
+		 le32_to_cpu(adsp1_sizes->dm), le32_to_cpu(adsp1_sizes->pm),
+		 le32_to_cpu(adsp1_sizes->zm));
+
+	return pos + sizeof(*adsp1_sizes);
+}
+
+static unsigned int wm_adsp2_parse_sizes(struct wm_adsp *dsp,
+					 const char * const file,
+					 unsigned int pos,
+					 const struct firmware *firmware)
+{
+	const struct wmfw_adsp2_sizes *adsp2_sizes;
+
+	adsp2_sizes = (void *)&firmware->data[pos];
+
+	adsp_dbg(dsp, "%s: %d XM, %d YM %d PM, %d ZM\n", file,
+		 le32_to_cpu(adsp2_sizes->xm), le32_to_cpu(adsp2_sizes->ym),
+		 le32_to_cpu(adsp2_sizes->pm), le32_to_cpu(adsp2_sizes->zm));
+
+	return pos + sizeof(*adsp2_sizes);
+}
+
+static bool wm_adsp_validate_version(struct wm_adsp *dsp, unsigned int version)
+{
+	switch (version) {
+	case 0:
+		adsp_warn(dsp, "Deprecated file format %d\n", version);
+		return true;
+	case 1:
+	case 2:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool wm_halo_validate_version(struct wm_adsp *dsp, unsigned int version)
+{
+	switch (version) {
+	case 3:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static int wm_adsp_load(struct wm_adsp *dsp)
+{
+	LIST_HEAD(buf_list);
+	const struct firmware *firmware;
+	struct regmap *regmap = dsp->regmap;
+	unsigned int pos = 0;
+	const struct wmfw_header *header;
+	const struct wmfw_adsp1_sizes *adsp1_sizes;
+	const struct wmfw_footer *footer;
+	const struct wmfw_region *region;
+	const struct wm_adsp_region *mem;
+	const char *region_name;
+	char *file, *text = NULL;
+	struct wm_adsp_buf *buf;
+	unsigned int reg;
+	int regions = 0;
+	int ret, offset, type;
+
+	file = kzalloc(PAGE_SIZE, GFP_KERNEL);
+	if (file == NULL)
+		return -ENOMEM;
+
+	snprintf(file, PAGE_SIZE, "%s-%s-%s.wmfw", dsp->part, dsp->fwf_name,
+		 wm_adsp_fw[dsp->fw].file);
+	file[PAGE_SIZE - 1] = '\0';
+
+	ret = request_firmware(&firmware, file, dsp->dev);
+	if (ret != 0) {
+		adsp_err(dsp, "Failed to request '%s'\n", file);
+		goto out;
+	}
+	ret = -EINVAL;
+
+	pos = sizeof(*header) + sizeof(*adsp1_sizes) + sizeof(*footer);
+	if (pos >= firmware->size) {
+		adsp_err(dsp, "%s: file too short, %zu bytes\n",
+			 file, firmware->size);
+		goto out_fw;
+	}
+
+	header = (void *)&firmware->data[0];
+
+	if (memcmp(&header->magic[0], "WMFW", 4) != 0) {
+		adsp_err(dsp, "%s: invalid magic\n", file);
+		goto out_fw;
+	}
+
+	if (!dsp->ops->validate_version(dsp, header->ver)) {
+		adsp_err(dsp, "%s: unknown file format %d\n",
+			 file, header->ver);
+		goto out_fw;
+	}
+
+	adsp_info(dsp, "Firmware version: %d\n", header->ver);
+	dsp->fw_ver = header->ver;
+
+	if (header->core != dsp->type) {
+		adsp_err(dsp, "%s: invalid core %d != %d\n",
+			 file, header->core, dsp->type);
+		goto out_fw;
+	}
+
+	pos = sizeof(*header);
+	pos = dsp->ops->parse_sizes(dsp, file, pos, firmware);
+
+	footer = (void *)&firmware->data[pos];
+	pos += sizeof(*footer);
+
+	if (le32_to_cpu(header->len) != pos) {
+		adsp_err(dsp, "%s: unexpected header length %d\n",
+			 file, le32_to_cpu(header->len));
+		goto out_fw;
+	}
+
+	adsp_dbg(dsp, "%s: timestamp %llu\n", file,
+		 le64_to_cpu(footer->timestamp));
+
+	while (pos < firmware->size &&
+	       sizeof(*region) < firmware->size - pos) {
+		region = (void *)&(firmware->data[pos]);
+		region_name = "Unknown";
+		reg = 0;
+		text = NULL;
+		offset = le32_to_cpu(region->offset) & 0xffffff;
+		type = be32_to_cpu(region->type) & 0xff;
+
+		switch (type) {
+		case WMFW_NAME_TEXT:
+			region_name = "Firmware name";
+			text = kzalloc(le32_to_cpu(region->len) + 1,
+				       GFP_KERNEL);
+			break;
+		case WMFW_ALGORITHM_DATA:
+			region_name = "Algorithm";
+			ret = wm_adsp_parse_coeff(dsp, region);
+			if (ret != 0)
+				goto out_fw;
+			break;
+		case WMFW_INFO_TEXT:
+			region_name = "Information";
+			text = kzalloc(le32_to_cpu(region->len) + 1,
+				       GFP_KERNEL);
+			break;
+		case WMFW_ABSOLUTE:
+			region_name = "Absolute";
+			reg = offset;
+			break;
+		case WMFW_ADSP1_PM:
+		case WMFW_ADSP1_DM:
+		case WMFW_ADSP2_XM:
+		case WMFW_ADSP2_YM:
+		case WMFW_ADSP1_ZM:
+		case WMFW_HALO_PM_PACKED:
+		case WMFW_HALO_XM_PACKED:
+		case WMFW_HALO_YM_PACKED:
+			mem = wm_adsp_find_region(dsp, type);
+			if (!mem) {
+				adsp_err(dsp, "No region of type: %x\n", type);
+				ret = -EINVAL;
+				goto out_fw;
+			}
+
+			region_name = wm_adsp_mem_region_name(type);
+			reg = dsp->ops->region_to_reg(mem, offset);
+			break;
+		default:
+			adsp_warn(dsp,
+				  "%s.%d: Unknown region type %x at %d(%x)\n",
+				  file, regions, type, pos, pos);
+			break;
+		}
+
+		adsp_dbg(dsp, "%s.%d: %d bytes at %d in %s\n", file,
+			 regions, le32_to_cpu(region->len), offset,
+			 region_name);
+
+		if (le32_to_cpu(region->len) >
+		    firmware->size - pos - sizeof(*region)) {
+			adsp_err(dsp,
+				 "%s.%d: %s region len %d bytes exceeds file length %zu\n",
+				 file, regions, region_name,
+				 le32_to_cpu(region->len), firmware->size);
+			ret = -EINVAL;
+			goto out_fw;
+		}
+
+		if (text) {
+			memcpy(text, region->data, le32_to_cpu(region->len));
+			adsp_info(dsp, "%s: %s\n", file, text);
+			kfree(text);
+			text = NULL;
+		}
+
+		if (reg) {
+			buf = wm_adsp_buf_alloc(region->data,
+						le32_to_cpu(region->len),
+						&buf_list);
+			if (!buf) {
+				adsp_err(dsp, "Out of memory\n");
+				ret = -ENOMEM;
+				goto out_fw;
+			}
+
+			ret = regmap_raw_write_async(regmap, reg, buf->buf,
+						     le32_to_cpu(region->len));
+			if (ret != 0) {
+				adsp_err(dsp,
+					"%s.%d: Failed to write %d bytes at %d in %s: %d\n",
+					file, regions,
+					le32_to_cpu(region->len), offset,
+					region_name, ret);
+				goto out_fw;
+			}
+		}
+
+		pos += le32_to_cpu(region->len) + sizeof(*region);
+		regions++;
+	}
+
+	ret = regmap_async_complete(regmap);
+	if (ret != 0) {
+		adsp_err(dsp, "Failed to complete async write: %d\n", ret);
+		goto out_fw;
+	}
+
+	if (pos > firmware->size)
+		adsp_warn(dsp, "%s.%d: %zu bytes at end of file\n",
+			  file, regions, pos - firmware->size);
+
+	wm_adsp_debugfs_save_wmfwname(dsp, file);
+
+out_fw:
+	regmap_async_complete(regmap);
+	wm_adsp_buf_free(&buf_list);
+	release_firmware(firmware);
+	kfree(text);
+out:
+	kfree(file);
+
+	return ret;
+}
+
+/*
+ * Find wm_coeff_ctl with input name as its subname
+ * If not found, return NULL
+ */
+static struct wm_coeff_ctl *wm_adsp_get_ctl(struct wm_adsp *dsp,
+					     const char *name, int type,
+					     unsigned int alg)
+{
+	struct wm_coeff_ctl *pos, *rslt = NULL;
+	const char *fw_txt = wm_adsp_fw_text[dsp->fw];
+
+	list_for_each_entry(pos, &dsp->ctl_list, list) {
+		if (!pos->subname)
+			continue;
+		if (strncmp(pos->subname, name, pos->subname_len) == 0 &&
+		    strncmp(pos->fw_name, fw_txt,
+			    SNDRV_CTL_ELEM_ID_NAME_MAXLEN) == 0 &&
+				pos->alg_region.alg == alg &&
+				pos->alg_region.type == type) {
+			rslt = pos;
+			break;
+		}
+	}
+
+	return rslt;
 }
 
 int wm_adsp_write_ctl(struct wm_adsp *dsp, const char *name, int type,
 		      unsigned int alg, void *buf, size_t len)
 {
-	struct cs_dsp_coeff_ctl *cs_ctl;
 	struct wm_coeff_ctl *ctl;
 	struct snd_kcontrol *kcontrol;
 	char ctl_name[SNDRV_CTL_ELEM_ID_NAME_MAXLEN];
 	int ret;
 
-	cs_ctl = cs_dsp_get_ctl(&dsp->cs_dsp, name, type, alg);
-	if (!cs_ctl)
+	ctl = wm_adsp_get_ctl(dsp, name, type, alg);
+	if (!ctl)
 		return -EINVAL;
 
-	ctl = cs_ctl->priv;
-
-	if (len > cs_ctl->len)
+	if (len > ctl->len)
 		return -EINVAL;
 
-	ret = cs_dsp_coeff_write_ctrl(cs_ctl, 0, buf, len);
+	ret = wm_coeff_write_ctrl(ctl, buf, len);
 	if (ret)
 		return ret;
 
-	if (cs_ctl->flags & WMFW_CTL_FLAG_SYS)
+	if (ctl->flags & WMFW_CTL_FLAG_SYS)
 		return 0;
 
 	if (dsp->component->name_prefix)
@@ -715,158 +2086,683 @@
 int wm_adsp_read_ctl(struct wm_adsp *dsp, const char *name, int type,
 		     unsigned int alg, void *buf, size_t len)
 {
-	struct cs_dsp_coeff_ctl *cs_ctl;
+	struct wm_coeff_ctl *ctl;
 
-	cs_ctl = cs_dsp_get_ctl(&dsp->cs_dsp, name, type, alg);
-	if (!cs_ctl)
+	ctl = wm_adsp_get_ctl(dsp, name, type, alg);
+	if (!ctl)
 		return -EINVAL;
 
-	if (len > cs_ctl->len)
+	if (len > ctl->len)
 		return -EINVAL;
 
-	return cs_dsp_coeff_read_ctrl(cs_ctl, 0, buf, len);
+	return wm_coeff_read_ctrl(ctl, buf, len);
 }
 EXPORT_SYMBOL_GPL(wm_adsp_read_ctl);
 
-static void wm_adsp_release_firmware_files(struct wm_adsp *dsp,
-					   const struct firmware *wmfw_firmware,
-					   char *wmfw_filename,
-					   const struct firmware *coeff_firmware,
-					   char *coeff_filename)
-{
-	if (wmfw_firmware)
-		release_firmware(wmfw_firmware);
-	kfree(wmfw_filename);
-
-	if (coeff_firmware)
-		release_firmware(coeff_firmware);
-	kfree(coeff_filename);
-}
-
-static int wm_adsp_request_firmware_file(struct wm_adsp *dsp,
-					 const struct firmware **firmware, char **filename,
-					 const char *dir, const char *system_name,
-					 const char *asoc_component_prefix,
-					 const char *filetype)
+static void wm_adsp_ctl_fixup_base(struct wm_adsp *dsp,
+				  const struct wm_adsp_alg_region *alg_region)
 {
-	struct cs_dsp *cs_dsp = &dsp->cs_dsp;
-	char *s, c;
-	int ret = 0;
+	struct wm_coeff_ctl *ctl;
 
-	if (system_name && asoc_component_prefix)
-		*filename = kasprintf(GFP_KERNEL, "%s%s-%s-%s-%s-%s.%s", dir, dsp->part,
-				      dsp->fwf_name, wm_adsp_fw[dsp->fw].file, system_name,
-				      asoc_component_prefix, filetype);
-	else if (system_name)
-		*filename = kasprintf(GFP_KERNEL, "%s%s-%s-%s-%s.%s", dir, dsp->part,
-				      dsp->fwf_name, wm_adsp_fw[dsp->fw].file, system_name,
-				      filetype);
-	else
-		*filename = kasprintf(GFP_KERNEL, "%s%s-%s-%s.%s", dir, dsp->part, dsp->fwf_name,
-				      wm_adsp_fw[dsp->fw].file, filetype);
+	list_for_each_entry(ctl, &dsp->ctl_list, list) {
+		if (ctl->fw_name == wm_adsp_fw_text[dsp->fw] &&
+		    alg_region->alg == ctl->alg_region.alg &&
+		    alg_region->type == ctl->alg_region.type) {
+			ctl->alg_region.base = alg_region->base;
+		}
+	}
+}
 
-	if (*filename == NULL)
-		return -ENOMEM;
+static void *wm_adsp_read_algs(struct wm_adsp *dsp, size_t n_algs,
+			       const struct wm_adsp_region *mem,
+			       unsigned int pos, unsigned int len)
+{
+	void *alg;
+	unsigned int reg;
+	int ret;
+	__be32 val;
 
-	/*
-	 * Make sure that filename is lower-case and any non alpha-numeric
-	 * characters except full stop and forward slash are replaced with
-	 * hyphens.
-	 */
-	s = *filename;
-	while (*s) {
-		c = *s;
-		if (isalnum(c))
-			*s = tolower(c);
-		else if ((c != '.') && (c != '/'))
-			*s = '-';
-		s++;
+	if (n_algs == 0) {
+		adsp_err(dsp, "No algorithms\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	if (n_algs > 1024) {
+		adsp_err(dsp, "Algorithm count %zx excessive\n", n_algs);
+		return ERR_PTR(-EINVAL);
 	}
 
-	ret = firmware_request_nowarn(firmware, *filename, cs_dsp->dev);
+	/* Read the terminator first to validate the length */
+	reg = dsp->ops->region_to_reg(mem, pos + len);
+
+	ret = regmap_raw_read(dsp->regmap, reg, &val, sizeof(val));
 	if (ret != 0) {
-		adsp_dbg(dsp, "Failed to request '%s'\n", *filename);
-		kfree(*filename);
-		*filename = NULL;
+		adsp_err(dsp, "Failed to read algorithm list end: %d\n",
+			ret);
+		return ERR_PTR(ret);
 	}
 
-	return ret;
+	if (be32_to_cpu(val) != 0xbedead)
+		adsp_warn(dsp, "Algorithm list end %x 0x%x != 0xbedead\n",
+			  reg, be32_to_cpu(val));
+
+	/* Convert length from DSP words to bytes */
+	len *= sizeof(u32);
+
+	alg = kzalloc(len, GFP_KERNEL | GFP_DMA);
+	if (!alg)
+		return ERR_PTR(-ENOMEM);
+
+	reg = dsp->ops->region_to_reg(mem, pos);
+
+	ret = regmap_raw_read(dsp->regmap, reg, alg, len);
+	if (ret != 0) {
+		adsp_err(dsp, "Failed to read algorithm list: %d\n", ret);
+		kfree(alg);
+		return ERR_PTR(ret);
+	}
+
+	return alg;
 }
 
-static const char *cirrus_dir = "cirrus/";
-static int wm_adsp_request_firmware_files(struct wm_adsp *dsp,
-					  const struct firmware **wmfw_firmware,
-					  char **wmfw_filename,
-					  const struct firmware **coeff_firmware,
-					  char **coeff_filename)
+static struct wm_adsp_alg_region *
+	wm_adsp_find_alg_region(struct wm_adsp *dsp, int type, unsigned int id)
 {
-	const char *system_name = dsp->system_name;
-	const char *asoc_component_prefix = dsp->component->name_prefix;
-	int ret = 0;
+	struct wm_adsp_alg_region *alg_region;
 
-	if (system_name && asoc_component_prefix) {
-		if (!wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename,
-						   cirrus_dir, system_name,
-						   asoc_component_prefix, "wmfw")) {
-			adsp_dbg(dsp, "Found '%s'\n", *wmfw_filename);
-			wm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,
-						      cirrus_dir, system_name,
-						      asoc_component_prefix, "bin");
-			return 0;
+	list_for_each_entry(alg_region, &dsp->alg_regions, list) {
+		if (id == alg_region->alg && type == alg_region->type)
+			return alg_region;
+	}
+
+	return NULL;
+}
+
+static struct wm_adsp_alg_region *wm_adsp_create_region(struct wm_adsp *dsp,
+							int type, __be32 id,
+							__be32 base)
+{
+	struct wm_adsp_alg_region *alg_region;
+
+	alg_region = kzalloc(sizeof(*alg_region), GFP_KERNEL);
+	if (!alg_region)
+		return ERR_PTR(-ENOMEM);
+
+	alg_region->type = type;
+	alg_region->alg = be32_to_cpu(id);
+	alg_region->base = be32_to_cpu(base);
+
+	list_add_tail(&alg_region->list, &dsp->alg_regions);
+
+	if (dsp->fw_ver > 0)
+		wm_adsp_ctl_fixup_base(dsp, alg_region);
+
+	return alg_region;
+}
+
+static void wm_adsp_free_alg_regions(struct wm_adsp *dsp)
+{
+	struct wm_adsp_alg_region *alg_region;
+
+	while (!list_empty(&dsp->alg_regions)) {
+		alg_region = list_first_entry(&dsp->alg_regions,
+					      struct wm_adsp_alg_region,
+					      list);
+		list_del(&alg_region->list);
+		kfree(alg_region);
+	}
+}
+
+static void wmfw_parse_id_header(struct wm_adsp *dsp,
+				 struct wmfw_id_hdr *fw, int nalgs)
+{
+	dsp->fw_id = be32_to_cpu(fw->id);
+	dsp->fw_id_version = be32_to_cpu(fw->ver);
+
+	adsp_info(dsp, "Firmware: %x v%d.%d.%d, %d algorithms\n",
+		  dsp->fw_id, (dsp->fw_id_version & 0xff0000) >> 16,
+		  (dsp->fw_id_version & 0xff00) >> 8, dsp->fw_id_version & 0xff,
+		  nalgs);
+}
+
+static void wmfw_v3_parse_id_header(struct wm_adsp *dsp,
+				    struct wmfw_v3_id_hdr *fw, int nalgs)
+{
+	dsp->fw_id = be32_to_cpu(fw->id);
+	dsp->fw_id_version = be32_to_cpu(fw->ver);
+	dsp->fw_vendor_id = be32_to_cpu(fw->vendor_id);
+
+	adsp_info(dsp, "Firmware: %x vendor: 0x%x v%d.%d.%d, %d algorithms\n",
+		  dsp->fw_id, dsp->fw_vendor_id,
+		  (dsp->fw_id_version & 0xff0000) >> 16,
+		  (dsp->fw_id_version & 0xff00) >> 8, dsp->fw_id_version & 0xff,
+		  nalgs);
+}
+
+static int wm_adsp_create_regions(struct wm_adsp *dsp, __be32 id, int nregions,
+				int *type, __be32 *base)
+{
+	struct wm_adsp_alg_region *alg_region;
+	int i;
+
+	for (i = 0; i < nregions; i++) {
+		alg_region = wm_adsp_create_region(dsp, type[i], id, base[i]);
+		if (IS_ERR(alg_region))
+			return PTR_ERR(alg_region);
+	}
+
+	return 0;
+}
+
+static int wm_adsp1_setup_algs(struct wm_adsp *dsp)
+{
+	struct wmfw_adsp1_id_hdr adsp1_id;
+	struct wmfw_adsp1_alg_hdr *adsp1_alg;
+	struct wm_adsp_alg_region *alg_region;
+	const struct wm_adsp_region *mem;
+	unsigned int pos, len;
+	size_t n_algs;
+	int i, ret;
+
+	mem = wm_adsp_find_region(dsp, WMFW_ADSP1_DM);
+	if (WARN_ON(!mem))
+		return -EINVAL;
+
+	ret = regmap_raw_read(dsp->regmap, mem->base, &adsp1_id,
+			      sizeof(adsp1_id));
+	if (ret != 0) {
+		adsp_err(dsp, "Failed to read algorithm info: %d\n",
+			 ret);
+		return ret;
+	}
+
+	n_algs = be32_to_cpu(adsp1_id.n_algs);
+
+	wmfw_parse_id_header(dsp, &adsp1_id.fw, n_algs);
+
+	alg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_ZM,
+					   adsp1_id.fw.id, adsp1_id.zm);
+	if (IS_ERR(alg_region))
+		return PTR_ERR(alg_region);
+
+	alg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_DM,
+					   adsp1_id.fw.id, adsp1_id.dm);
+	if (IS_ERR(alg_region))
+		return PTR_ERR(alg_region);
+
+	/* Calculate offset and length in DSP words */
+	pos = sizeof(adsp1_id) / sizeof(u32);
+	len = (sizeof(*adsp1_alg) * n_algs) / sizeof(u32);
+
+	adsp1_alg = wm_adsp_read_algs(dsp, n_algs, mem, pos, len);
+	if (IS_ERR(adsp1_alg))
+		return PTR_ERR(adsp1_alg);
+
+	for (i = 0; i < n_algs; i++) {
+		adsp_info(dsp, "%d: ID %x v%d.%d.%d DM@%x ZM@%x\n",
+			  i, be32_to_cpu(adsp1_alg[i].alg.id),
+			  (be32_to_cpu(adsp1_alg[i].alg.ver) & 0xff0000) >> 16,
+			  (be32_to_cpu(adsp1_alg[i].alg.ver) & 0xff00) >> 8,
+			  be32_to_cpu(adsp1_alg[i].alg.ver) & 0xff,
+			  be32_to_cpu(adsp1_alg[i].dm),
+			  be32_to_cpu(adsp1_alg[i].zm));
+
+		alg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_DM,
+						   adsp1_alg[i].alg.id,
+						   adsp1_alg[i].dm);
+		if (IS_ERR(alg_region)) {
+			ret = PTR_ERR(alg_region);
+			goto out;
+		}
+		if (dsp->fw_ver == 0) {
+			if (i + 1 < n_algs) {
+				len = be32_to_cpu(adsp1_alg[i + 1].dm);
+				len -= be32_to_cpu(adsp1_alg[i].dm);
+				len *= 4;
+				wm_adsp_create_control(dsp, alg_region, 0,
+						     len, NULL, 0, 0,
+						     SNDRV_CTL_ELEM_TYPE_BYTES);
+			} else {
+				adsp_warn(dsp, "Missing length info for region DM with ID %x\n",
+					  be32_to_cpu(adsp1_alg[i].alg.id));
+			}
+		}
+
+		alg_region = wm_adsp_create_region(dsp, WMFW_ADSP1_ZM,
+						   adsp1_alg[i].alg.id,
+						   adsp1_alg[i].zm);
+		if (IS_ERR(alg_region)) {
+			ret = PTR_ERR(alg_region);
+			goto out;
+		}
+		if (dsp->fw_ver == 0) {
+			if (i + 1 < n_algs) {
+				len = be32_to_cpu(adsp1_alg[i + 1].zm);
+				len -= be32_to_cpu(adsp1_alg[i].zm);
+				len *= 4;
+				wm_adsp_create_control(dsp, alg_region, 0,
+						     len, NULL, 0, 0,
+						     SNDRV_CTL_ELEM_TYPE_BYTES);
+			} else {
+				adsp_warn(dsp, "Missing length info for region ZM with ID %x\n",
+					  be32_to_cpu(adsp1_alg[i].alg.id));
+			}
 		}
 	}
 
-	if (system_name) {
-		if (!wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename,
-						   cirrus_dir, system_name,
-						   NULL, "wmfw")) {
-			adsp_dbg(dsp, "Found '%s'\n", *wmfw_filename);
-			if (asoc_component_prefix)
-				wm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,
-							      cirrus_dir, system_name,
-							      asoc_component_prefix, "bin");
-
-			if (!*coeff_firmware)
-				wm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,
-							      cirrus_dir, system_name,
-							      NULL, "bin");
-			return 0;
+out:
+	kfree(adsp1_alg);
+	return ret;
+}
+
+static int wm_adsp2_setup_algs(struct wm_adsp *dsp)
+{
+	struct wmfw_adsp2_id_hdr adsp2_id;
+	struct wmfw_adsp2_alg_hdr *adsp2_alg;
+	struct wm_adsp_alg_region *alg_region;
+	const struct wm_adsp_region *mem;
+	unsigned int pos, len;
+	size_t n_algs;
+	int i, ret;
+
+	mem = wm_adsp_find_region(dsp, WMFW_ADSP2_XM);
+	if (WARN_ON(!mem))
+		return -EINVAL;
+
+	ret = regmap_raw_read(dsp->regmap, mem->base, &adsp2_id,
+			      sizeof(adsp2_id));
+	if (ret != 0) {
+		adsp_err(dsp, "Failed to read algorithm info: %d\n",
+			 ret);
+		return ret;
+	}
+
+	n_algs = be32_to_cpu(adsp2_id.n_algs);
+
+	wmfw_parse_id_header(dsp, &adsp2_id.fw, n_algs);
+
+	alg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_XM,
+					   adsp2_id.fw.id, adsp2_id.xm);
+	if (IS_ERR(alg_region))
+		return PTR_ERR(alg_region);
+
+	alg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_YM,
+					   adsp2_id.fw.id, adsp2_id.ym);
+	if (IS_ERR(alg_region))
+		return PTR_ERR(alg_region);
+
+	alg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_ZM,
+					   adsp2_id.fw.id, adsp2_id.zm);
+	if (IS_ERR(alg_region))
+		return PTR_ERR(alg_region);
+
+	/* Calculate offset and length in DSP words */
+	pos = sizeof(adsp2_id) / sizeof(u32);
+	len = (sizeof(*adsp2_alg) * n_algs) / sizeof(u32);
+
+	adsp2_alg = wm_adsp_read_algs(dsp, n_algs, mem, pos, len);
+	if (IS_ERR(adsp2_alg))
+		return PTR_ERR(adsp2_alg);
+
+	for (i = 0; i < n_algs; i++) {
+		adsp_info(dsp,
+			  "%d: ID %x v%d.%d.%d XM@%x YM@%x ZM@%x\n",
+			  i, be32_to_cpu(adsp2_alg[i].alg.id),
+			  (be32_to_cpu(adsp2_alg[i].alg.ver) & 0xff0000) >> 16,
+			  (be32_to_cpu(adsp2_alg[i].alg.ver) & 0xff00) >> 8,
+			  be32_to_cpu(adsp2_alg[i].alg.ver) & 0xff,
+			  be32_to_cpu(adsp2_alg[i].xm),
+			  be32_to_cpu(adsp2_alg[i].ym),
+			  be32_to_cpu(adsp2_alg[i].zm));
+
+		alg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_XM,
+						   adsp2_alg[i].alg.id,
+						   adsp2_alg[i].xm);
+		if (IS_ERR(alg_region)) {
+			ret = PTR_ERR(alg_region);
+			goto out;
+		}
+		if (dsp->fw_ver == 0) {
+			if (i + 1 < n_algs) {
+				len = be32_to_cpu(adsp2_alg[i + 1].xm);
+				len -= be32_to_cpu(adsp2_alg[i].xm);
+				len *= 4;
+				wm_adsp_create_control(dsp, alg_region, 0,
+						     len, NULL, 0, 0,
+						     SNDRV_CTL_ELEM_TYPE_BYTES);
+			} else {
+				adsp_warn(dsp, "Missing length info for region XM with ID %x\n",
+					  be32_to_cpu(adsp2_alg[i].alg.id));
+			}
+		}
+
+		alg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_YM,
+						   adsp2_alg[i].alg.id,
+						   adsp2_alg[i].ym);
+		if (IS_ERR(alg_region)) {
+			ret = PTR_ERR(alg_region);
+			goto out;
+		}
+		if (dsp->fw_ver == 0) {
+			if (i + 1 < n_algs) {
+				len = be32_to_cpu(adsp2_alg[i + 1].ym);
+				len -= be32_to_cpu(adsp2_alg[i].ym);
+				len *= 4;
+				wm_adsp_create_control(dsp, alg_region, 0,
+						     len, NULL, 0, 0,
+						     SNDRV_CTL_ELEM_TYPE_BYTES);
+			} else {
+				adsp_warn(dsp, "Missing length info for region YM with ID %x\n",
+					  be32_to_cpu(adsp2_alg[i].alg.id));
+			}
+		}
+
+		alg_region = wm_adsp_create_region(dsp, WMFW_ADSP2_ZM,
+						   adsp2_alg[i].alg.id,
+						   adsp2_alg[i].zm);
+		if (IS_ERR(alg_region)) {
+			ret = PTR_ERR(alg_region);
+			goto out;
+		}
+		if (dsp->fw_ver == 0) {
+			if (i + 1 < n_algs) {
+				len = be32_to_cpu(adsp2_alg[i + 1].zm);
+				len -= be32_to_cpu(adsp2_alg[i].zm);
+				len *= 4;
+				wm_adsp_create_control(dsp, alg_region, 0,
+						     len, NULL, 0, 0,
+						     SNDRV_CTL_ELEM_TYPE_BYTES);
+			} else {
+				adsp_warn(dsp, "Missing length info for region ZM with ID %x\n",
+					  be32_to_cpu(adsp2_alg[i].alg.id));
+			}
 		}
 	}
 
-	if (!wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename,
-					   "", NULL, NULL, "wmfw")) {
-		adsp_dbg(dsp, "Found '%s'\n", *wmfw_filename);
-		wm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,
-					      "", NULL, NULL, "bin");
-		return 0;
+out:
+	kfree(adsp2_alg);
+	return ret;
+}
+
+static int wm_halo_create_regions(struct wm_adsp *dsp, __be32 id,
+				  __be32 xm_base, __be32 ym_base)
+{
+	int types[] = {
+		WMFW_ADSP2_XM, WMFW_HALO_XM_PACKED,
+		WMFW_ADSP2_YM, WMFW_HALO_YM_PACKED
+	};
+	__be32 bases[] = { xm_base, xm_base, ym_base, ym_base };
+
+	return wm_adsp_create_regions(dsp, id, ARRAY_SIZE(types), types, bases);
+}
+
+static int wm_halo_setup_algs(struct wm_adsp *dsp)
+{
+	struct wmfw_halo_id_hdr halo_id;
+	struct wmfw_halo_alg_hdr *halo_alg;
+	const struct wm_adsp_region *mem;
+	unsigned int pos, len;
+	size_t n_algs;
+	int i, ret;
+
+	mem = wm_adsp_find_region(dsp, WMFW_ADSP2_XM);
+	if (WARN_ON(!mem))
+		return -EINVAL;
+
+	ret = regmap_raw_read(dsp->regmap, mem->base, &halo_id,
+			      sizeof(halo_id));
+	if (ret != 0) {
+		adsp_err(dsp, "Failed to read algorithm info: %d\n",
+			 ret);
+		return ret;
 	}
 
-	ret = wm_adsp_request_firmware_file(dsp, wmfw_firmware, wmfw_filename,
-					    cirrus_dir, NULL, NULL, "wmfw");
-	if (!ret) {
-		adsp_dbg(dsp, "Found '%s'\n", *wmfw_filename);
-		wm_adsp_request_firmware_file(dsp, coeff_firmware, coeff_filename,
-					      cirrus_dir, NULL, NULL, "bin");
-		return 0;
+	n_algs = be32_to_cpu(halo_id.n_algs);
+
+	wmfw_v3_parse_id_header(dsp, &halo_id.fw, n_algs);
+
+	ret = wm_halo_create_regions(dsp, halo_id.fw.id,
+				     halo_id.xm_base, halo_id.ym_base);
+	if (ret)
+		return ret;
+
+	/* Calculate offset and length in DSP words */
+	pos = sizeof(halo_id) / sizeof(u32);
+	len = (sizeof(*halo_alg) * n_algs) / sizeof(u32);
+
+	halo_alg = wm_adsp_read_algs(dsp, n_algs, mem, pos, len);
+	if (IS_ERR(halo_alg))
+		return PTR_ERR(halo_alg);
+
+	for (i = 0; i < n_algs; i++) {
+		adsp_info(dsp,
+			  "%d: ID %x v%d.%d.%d XM@%x YM@%x\n",
+			  i, be32_to_cpu(halo_alg[i].alg.id),
+			  (be32_to_cpu(halo_alg[i].alg.ver) & 0xff0000) >> 16,
+			  (be32_to_cpu(halo_alg[i].alg.ver) & 0xff00) >> 8,
+			  be32_to_cpu(halo_alg[i].alg.ver) & 0xff,
+			  be32_to_cpu(halo_alg[i].xm_base),
+			  be32_to_cpu(halo_alg[i].ym_base));
+
+		ret = wm_halo_create_regions(dsp, halo_alg[i].alg.id,
+					     halo_alg[i].xm_base,
+					     halo_alg[i].ym_base);
+		if (ret)
+			goto out;
+	}
+
+out:
+	kfree(halo_alg);
+	return ret;
+}
+
+static int wm_adsp_load_coeff(struct wm_adsp *dsp)
+{
+	LIST_HEAD(buf_list);
+	struct regmap *regmap = dsp->regmap;
+	struct wmfw_coeff_hdr *hdr;
+	struct wmfw_coeff_item *blk;
+	const struct firmware *firmware;
+	const struct wm_adsp_region *mem;
+	struct wm_adsp_alg_region *alg_region;
+	const char *region_name;
+	int ret, pos, blocks, type, offset, reg;
+	char *file;
+	struct wm_adsp_buf *buf;
+
+	file = kzalloc(PAGE_SIZE, GFP_KERNEL);
+	if (file == NULL)
+		return -ENOMEM;
+
+	snprintf(file, PAGE_SIZE, "%s-%s-%s.bin", dsp->part, dsp->fwf_name,
+		 wm_adsp_fw[dsp->fw].file);
+	file[PAGE_SIZE - 1] = '\0';
+
+	ret = request_firmware(&firmware, file, dsp->dev);
+	if (ret != 0) {
+		adsp_warn(dsp, "Failed to request '%s'\n", file);
+		ret = 0;
+		goto out;
+	}
+	ret = -EINVAL;
+
+	if (sizeof(*hdr) >= firmware->size) {
+		adsp_err(dsp, "%s: file too short, %zu bytes\n",
+			file, firmware->size);
+		goto out_fw;
+	}
+
+	hdr = (void *)&firmware->data[0];
+	if (memcmp(hdr->magic, "WMDR", 4) != 0) {
+		adsp_err(dsp, "%s: invalid magic\n", file);
+		goto out_fw;
+	}
+
+	switch (be32_to_cpu(hdr->rev) & 0xff) {
+	case 1:
+		break;
+	default:
+		adsp_err(dsp, "%s: Unsupported coefficient file format %d\n",
+			 file, be32_to_cpu(hdr->rev) & 0xff);
+		ret = -EINVAL;
+		goto out_fw;
+	}
+
+	adsp_dbg(dsp, "%s: v%d.%d.%d\n", file,
+		(le32_to_cpu(hdr->ver) >> 16) & 0xff,
+		(le32_to_cpu(hdr->ver) >>  8) & 0xff,
+		le32_to_cpu(hdr->ver) & 0xff);
+
+	pos = le32_to_cpu(hdr->len);
+
+	blocks = 0;
+	while (pos < firmware->size &&
+	       sizeof(*blk) < firmware->size - pos) {
+		blk = (void *)(&firmware->data[pos]);
+
+		type = le16_to_cpu(blk->type);
+		offset = le16_to_cpu(blk->offset);
+
+		adsp_dbg(dsp, "%s.%d: %x v%d.%d.%d\n",
+			 file, blocks, le32_to_cpu(blk->id),
+			 (le32_to_cpu(blk->ver) >> 16) & 0xff,
+			 (le32_to_cpu(blk->ver) >>  8) & 0xff,
+			 le32_to_cpu(blk->ver) & 0xff);
+		adsp_dbg(dsp, "%s.%d: %d bytes at 0x%x in %x\n",
+			 file, blocks, le32_to_cpu(blk->len), offset, type);
+
+		reg = 0;
+		region_name = "Unknown";
+		switch (type) {
+		case (WMFW_NAME_TEXT << 8):
+		case (WMFW_INFO_TEXT << 8):
+		case (WMFW_METADATA << 8):
+			break;
+		case (WMFW_ABSOLUTE << 8):
+			/*
+			 * Old files may use this for global
+			 * coefficients.
+			 */
+			if (le32_to_cpu(blk->id) == dsp->fw_id &&
+			    offset == 0) {
+				region_name = "global coefficients";
+				mem = wm_adsp_find_region(dsp, type);
+				if (!mem) {
+					adsp_err(dsp, "No ZM\n");
+					break;
+				}
+				reg = dsp->ops->region_to_reg(mem, 0);
+
+			} else {
+				region_name = "register";
+				reg = offset;
+			}
+			break;
+
+		case WMFW_ADSP1_DM:
+		case WMFW_ADSP1_ZM:
+		case WMFW_ADSP2_XM:
+		case WMFW_ADSP2_YM:
+		case WMFW_HALO_XM_PACKED:
+		case WMFW_HALO_YM_PACKED:
+		case WMFW_HALO_PM_PACKED:
+			adsp_dbg(dsp, "%s.%d: %d bytes in %x for %x\n",
+				 file, blocks, le32_to_cpu(blk->len),
+				 type, le32_to_cpu(blk->id));
+
+			mem = wm_adsp_find_region(dsp, type);
+			if (!mem) {
+				adsp_err(dsp, "No base for region %x\n", type);
+				break;
+			}
+
+			alg_region = wm_adsp_find_alg_region(dsp, type,
+						le32_to_cpu(blk->id));
+			if (alg_region) {
+				reg = alg_region->base;
+				reg = dsp->ops->region_to_reg(mem, reg);
+				reg += offset;
+			} else {
+				adsp_err(dsp, "No %x for algorithm %x\n",
+					 type, le32_to_cpu(blk->id));
+			}
+			break;
+
+		default:
+			adsp_err(dsp, "%s.%d: Unknown region type %x at %d\n",
+				 file, blocks, type, pos);
+			break;
+		}
+
+		if (reg) {
+			if (le32_to_cpu(blk->len) >
+			    firmware->size - pos - sizeof(*blk)) {
+				adsp_err(dsp,
+					 "%s.%d: %s region len %d bytes exceeds file length %zu\n",
+					 file, blocks, region_name,
+					 le32_to_cpu(blk->len),
+					 firmware->size);
+				ret = -EINVAL;
+				goto out_fw;
+			}
+
+			buf = wm_adsp_buf_alloc(blk->data,
+						le32_to_cpu(blk->len),
+						&buf_list);
+			if (!buf) {
+				adsp_err(dsp, "Out of memory\n");
+				ret = -ENOMEM;
+				goto out_fw;
+			}
+
+			adsp_dbg(dsp, "%s.%d: Writing %d bytes at %x\n",
+				 file, blocks, le32_to_cpu(blk->len),
+				 reg);
+			ret = regmap_raw_write_async(regmap, reg, buf->buf,
+						     le32_to_cpu(blk->len));
+			if (ret != 0) {
+				adsp_err(dsp,
+					"%s.%d: Failed to write to %x in %s: %d\n",
+					file, blocks, reg, region_name, ret);
+			}
+		}
+
+		pos += (le32_to_cpu(blk->len) + sizeof(*blk) + 3) & ~0x03;
+		blocks++;
 	}
 
-	adsp_err(dsp, "Failed to request firmware <%s>%s-%s-%s<-%s<%s>>.wmfw\n",
-		 cirrus_dir, dsp->part, dsp->fwf_name, wm_adsp_fw[dsp->fw].file,
-		 system_name, asoc_component_prefix);
+	ret = regmap_async_complete(regmap);
+	if (ret != 0)
+		adsp_err(dsp, "Failed to complete async write: %d\n", ret);
+
+	if (pos > firmware->size)
+		adsp_warn(dsp, "%s.%d: %zu bytes at end of file\n",
+			  file, blocks, pos - firmware->size);
 
-	return -ENOENT;
+	wm_adsp_debugfs_save_binname(dsp, file);
+
+out_fw:
+	regmap_async_complete(regmap);
+	release_firmware(firmware);
+	wm_adsp_buf_free(&buf_list);
+out:
+	kfree(file);
+	return ret;
 }
 
-static int wm_adsp_common_init(struct wm_adsp *dsp)
+static int wm_adsp_create_name(struct wm_adsp *dsp)
 {
 	char *p;
 
-	INIT_LIST_HEAD(&dsp->compr_list);
-	INIT_LIST_HEAD(&dsp->buffer_list);
+	if (!dsp->name) {
+		dsp->name = devm_kasprintf(dsp->dev, GFP_KERNEL, "DSP%d",
+					   dsp->num);
+		if (!dsp->name)
+			return -ENOMEM;
+	}
 
 	if (!dsp->fwf_name) {
-		p = devm_kstrdup(dsp->cs_dsp.dev, dsp->cs_dsp.name, GFP_KERNEL);
+		p = devm_kstrdup(dsp->dev, dsp->name, GFP_KERNEL);
 		if (!p)
 			return -ENOMEM;
 
@@ -878,16 +2774,28 @@
 	return 0;
 }
 
-int wm_adsp1_init(struct wm_adsp *dsp)
+static int wm_adsp_common_init(struct wm_adsp *dsp)
 {
 	int ret;
 
-	dsp->cs_dsp.client_ops = &wm_adsp1_client_ops;
-
-	ret = cs_dsp_adsp1_init(&dsp->cs_dsp);
+	ret = wm_adsp_create_name(dsp);
 	if (ret)
 		return ret;
 
+	INIT_LIST_HEAD(&dsp->alg_regions);
+	INIT_LIST_HEAD(&dsp->ctl_list);
+	INIT_LIST_HEAD(&dsp->compr_list);
+	INIT_LIST_HEAD(&dsp->buffer_list);
+
+	mutex_init(&dsp->pwr_lock);
+
+	return 0;
+}
+
+int wm_adsp1_init(struct wm_adsp *dsp)
+{
+	dsp->ops = &wm_adsp1_ops;
+
 	return wm_adsp_common_init(dsp);
 }
 EXPORT_SYMBOL_GPL(wm_adsp1_init);
@@ -899,49 +2807,314 @@
 	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
 	struct wm_adsp *dsps = snd_soc_component_get_drvdata(component);
 	struct wm_adsp *dsp = &dsps[w->shift];
-	int ret = 0;
-	char *wmfw_filename = NULL;
-	const struct firmware *wmfw_firmware = NULL;
-	char *coeff_filename = NULL;
-	const struct firmware *coeff_firmware = NULL;
+	struct wm_coeff_ctl *ctl;
+	int ret;
+	unsigned int val;
 
 	dsp->component = component;
 
+	mutex_lock(&dsp->pwr_lock);
+
 	switch (event) {
 	case SND_SOC_DAPM_POST_PMU:
-		ret = wm_adsp_request_firmware_files(dsp,
-						     &wmfw_firmware, &wmfw_filename,
-						     &coeff_firmware, &coeff_filename);
-		if (ret)
-			break;
+		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
+				   ADSP1_SYS_ENA, ADSP1_SYS_ENA);
+
+		/*
+		 * For simplicity set the DSP clock rate to be the
+		 * SYSCLK rate rather than making it configurable.
+		 */
+		if (dsp->sysclk_reg) {
+			ret = regmap_read(dsp->regmap, dsp->sysclk_reg, &val);
+			if (ret != 0) {
+				adsp_err(dsp, "Failed to read SYSCLK state: %d\n",
+				ret);
+				goto err_mutex;
+			}
+
+			val = (val & dsp->sysclk_mask) >> dsp->sysclk_shift;
 
-		ret = cs_dsp_adsp1_power_up(&dsp->cs_dsp,
-					    wmfw_firmware, wmfw_filename,
-					    coeff_firmware, coeff_filename,
-					    wm_adsp_fw_text[dsp->fw]);
-
-		wm_adsp_release_firmware_files(dsp,
-					       wmfw_firmware, wmfw_filename,
-					       coeff_firmware, coeff_filename);
+			ret = regmap_update_bits(dsp->regmap,
+						 dsp->base + ADSP1_CONTROL_31,
+						 ADSP1_CLK_SEL_MASK, val);
+			if (ret != 0) {
+				adsp_err(dsp, "Failed to set clock rate: %d\n",
+					 ret);
+				goto err_mutex;
+			}
+		}
+
+		ret = wm_adsp_load(dsp);
+		if (ret != 0)
+			goto err_ena;
+
+		ret = wm_adsp1_setup_algs(dsp);
+		if (ret != 0)
+			goto err_ena;
+
+		ret = wm_adsp_load_coeff(dsp);
+		if (ret != 0)
+			goto err_ena;
+
+		/* Initialize caches for enabled and unset controls */
+		ret = wm_coeff_init_control_caches(dsp);
+		if (ret != 0)
+			goto err_ena;
+
+		/* Sync set controls */
+		ret = wm_coeff_sync_controls(dsp);
+		if (ret != 0)
+			goto err_ena;
+
+		dsp->booted = true;
+
+		/* Start the core running */
+		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
+				   ADSP1_CORE_ENA | ADSP1_START,
+				   ADSP1_CORE_ENA | ADSP1_START);
+
+		dsp->running = true;
 		break;
+
 	case SND_SOC_DAPM_PRE_PMD:
-		cs_dsp_adsp1_power_down(&dsp->cs_dsp);
+		dsp->running = false;
+		dsp->booted = false;
+
+		/* Halt the core */
+		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
+				   ADSP1_CORE_ENA | ADSP1_START, 0);
+
+		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_19,
+				   ADSP1_WDMA_BUFFER_LENGTH_MASK, 0);
+
+		regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
+				   ADSP1_SYS_ENA, 0);
+
+		list_for_each_entry(ctl, &dsp->ctl_list, list)
+			ctl->enabled = 0;
+
+
+		wm_adsp_free_alg_regions(dsp);
 		break;
+
 	default:
 		break;
 	}
 
+	mutex_unlock(&dsp->pwr_lock);
+
+	return 0;
+
+err_ena:
+	regmap_update_bits(dsp->regmap, dsp->base + ADSP1_CONTROL_30,
+			   ADSP1_SYS_ENA, 0);
+err_mutex:
+	mutex_unlock(&dsp->pwr_lock);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(wm_adsp1_event);
 
+static int wm_adsp2v2_enable_core(struct wm_adsp *dsp)
+{
+	unsigned int val;
+	int ret, count;
+
+	/* Wait for the RAM to start, should be near instantaneous */
+	for (count = 0; count < 10; ++count) {
+		ret = regmap_read(dsp->regmap, dsp->base + ADSP2_STATUS1, &val);
+		if (ret != 0)
+			return ret;
+
+		if (val & ADSP2_RAM_RDY)
+			break;
+
+		usleep_range(250, 500);
+	}
+
+	if (!(val & ADSP2_RAM_RDY)) {
+		adsp_err(dsp, "Failed to start DSP RAM\n");
+		return -EBUSY;
+	}
+
+	adsp_dbg(dsp, "RAM ready after %d polls\n", count);
+
+	return 0;
+}
+
+static int wm_adsp2_enable_core(struct wm_adsp *dsp)
+{
+	int ret;
+
+	ret = regmap_update_bits_async(dsp->regmap, dsp->base + ADSP2_CONTROL,
+				       ADSP2_SYS_ENA, ADSP2_SYS_ENA);
+	if (ret != 0)
+		return ret;
+
+	return wm_adsp2v2_enable_core(dsp);
+}
+
+static int wm_adsp2_lock(struct wm_adsp *dsp, unsigned int lock_regions)
+{
+	struct regmap *regmap = dsp->regmap;
+	unsigned int code0, code1, lock_reg;
+
+	if (!(lock_regions & WM_ADSP2_REGION_ALL))
+		return 0;
+
+	lock_regions &= WM_ADSP2_REGION_ALL;
+	lock_reg = dsp->base + ADSP2_LOCK_REGION_1_LOCK_REGION_0;
+
+	while (lock_regions) {
+		code0 = code1 = 0;
+		if (lock_regions & BIT(0)) {
+			code0 = ADSP2_LOCK_CODE_0;
+			code1 = ADSP2_LOCK_CODE_1;
+		}
+		if (lock_regions & BIT(1)) {
+			code0 |= ADSP2_LOCK_CODE_0 << ADSP2_LOCK_REGION_SHIFT;
+			code1 |= ADSP2_LOCK_CODE_1 << ADSP2_LOCK_REGION_SHIFT;
+		}
+		regmap_write(regmap, lock_reg, code0);
+		regmap_write(regmap, lock_reg, code1);
+		lock_regions >>= 2;
+		lock_reg += 2;
+	}
+
+	return 0;
+}
+
+static int wm_adsp2_enable_memory(struct wm_adsp *dsp)
+{
+	return regmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,
+				  ADSP2_MEM_ENA, ADSP2_MEM_ENA);
+}
+
+static void wm_adsp2_disable_memory(struct wm_adsp *dsp)
+{
+	regmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,
+			   ADSP2_MEM_ENA, 0);
+}
+
+static void wm_adsp2_disable_core(struct wm_adsp *dsp)
+{
+	regmap_write(dsp->regmap, dsp->base + ADSP2_RDMA_CONFIG_1, 0);
+	regmap_write(dsp->regmap, dsp->base + ADSP2_WDMA_CONFIG_1, 0);
+	regmap_write(dsp->regmap, dsp->base + ADSP2_WDMA_CONFIG_2, 0);
+
+	regmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,
+			   ADSP2_SYS_ENA, 0);
+}
+
+static void wm_adsp2v2_disable_core(struct wm_adsp *dsp)
+{
+	regmap_write(dsp->regmap, dsp->base + ADSP2_RDMA_CONFIG_1, 0);
+	regmap_write(dsp->regmap, dsp->base + ADSP2_WDMA_CONFIG_1, 0);
+	regmap_write(dsp->regmap, dsp->base + ADSP2V2_WDMA_CONFIG_2, 0);
+}
+
+static void wm_adsp_boot_work(struct work_struct *work)
+{
+	struct wm_adsp *dsp = container_of(work,
+					   struct wm_adsp,
+					   boot_work);
+	int ret;
+
+	mutex_lock(&dsp->pwr_lock);
+
+	if (dsp->ops->enable_memory) {
+		ret = dsp->ops->enable_memory(dsp);
+		if (ret != 0)
+			goto err_mutex;
+	}
+
+	if (dsp->ops->enable_core) {
+		ret = dsp->ops->enable_core(dsp);
+		if (ret != 0)
+			goto err_mem;
+	}
+
+	ret = wm_adsp_load(dsp);
+	if (ret != 0)
+		goto err_ena;
+
+	ret = dsp->ops->setup_algs(dsp);
+	if (ret != 0)
+		goto err_ena;
+
+	ret = wm_adsp_load_coeff(dsp);
+	if (ret != 0)
+		goto err_ena;
+
+	/* Initialize caches for enabled and unset controls */
+	ret = wm_coeff_init_control_caches(dsp);
+	if (ret != 0)
+		goto err_ena;
+
+	if (dsp->ops->disable_core)
+		dsp->ops->disable_core(dsp);
+
+	dsp->booted = true;
+
+	mutex_unlock(&dsp->pwr_lock);
+
+	return;
+
+err_ena:
+	if (dsp->ops->disable_core)
+		dsp->ops->disable_core(dsp);
+err_mem:
+	if (dsp->ops->disable_memory)
+		dsp->ops->disable_memory(dsp);
+err_mutex:
+	mutex_unlock(&dsp->pwr_lock);
+}
+
+static int wm_halo_configure_mpu(struct wm_adsp *dsp, unsigned int lock_regions)
+{
+	struct reg_sequence config[] = {
+		{ dsp->base + HALO_MPU_LOCK_CONFIG,     0x5555 },
+		{ dsp->base + HALO_MPU_LOCK_CONFIG,     0xAAAA },
+		{ dsp->base + HALO_MPU_XMEM_ACCESS_0,   0xFFFFFFFF },
+		{ dsp->base + HALO_MPU_YMEM_ACCESS_0,   0xFFFFFFFF },
+		{ dsp->base + HALO_MPU_WINDOW_ACCESS_0, lock_regions },
+		{ dsp->base + HALO_MPU_XREG_ACCESS_0,   lock_regions },
+		{ dsp->base + HALO_MPU_YREG_ACCESS_0,   lock_regions },
+		{ dsp->base + HALO_MPU_XMEM_ACCESS_1,   0xFFFFFFFF },
+		{ dsp->base + HALO_MPU_YMEM_ACCESS_1,   0xFFFFFFFF },
+		{ dsp->base + HALO_MPU_WINDOW_ACCESS_1, lock_regions },
+		{ dsp->base + HALO_MPU_XREG_ACCESS_1,   lock_regions },
+		{ dsp->base + HALO_MPU_YREG_ACCESS_1,   lock_regions },
+		{ dsp->base + HALO_MPU_XMEM_ACCESS_2,   0xFFFFFFFF },
+		{ dsp->base + HALO_MPU_YMEM_ACCESS_2,   0xFFFFFFFF },
+		{ dsp->base + HALO_MPU_WINDOW_ACCESS_2, lock_regions },
+		{ dsp->base + HALO_MPU_XREG_ACCESS_2,   lock_regions },
+		{ dsp->base + HALO_MPU_YREG_ACCESS_2,   lock_regions },
+		{ dsp->base + HALO_MPU_XMEM_ACCESS_3,   0xFFFFFFFF },
+		{ dsp->base + HALO_MPU_YMEM_ACCESS_3,   0xFFFFFFFF },
+		{ dsp->base + HALO_MPU_WINDOW_ACCESS_3, lock_regions },
+		{ dsp->base + HALO_MPU_XREG_ACCESS_3,   lock_regions },
+		{ dsp->base + HALO_MPU_YREG_ACCESS_3,   lock_regions },
+		{ dsp->base + HALO_MPU_LOCK_CONFIG,     0 },
+	};
+
+	return regmap_multi_reg_write(dsp->regmap, config, ARRAY_SIZE(config));
+}
+
 int wm_adsp2_set_dspclk(struct snd_soc_dapm_widget *w, unsigned int freq)
 {
 	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
 	struct wm_adsp *dsps = snd_soc_component_get_drvdata(component);
 	struct wm_adsp *dsp = &dsps[w->shift];
+	int ret;
+
+	ret = regmap_update_bits(dsp->regmap, dsp->base + ADSP2_CLOCKING,
+				 ADSP2_CLK_SEL_MASK,
+				 freq << ADSP2_CLK_SEL_SHIFT);
+	if (ret)
+		adsp_err(dsp, "Failed to set clock rate: %d\n", ret);
 
-	return cs_dsp_set_dspclk(&dsp->cs_dsp, freq);
+	return ret;
 }
 EXPORT_SYMBOL_GPL(wm_adsp2_set_dspclk);
 
@@ -971,12 +3144,11 @@
 	struct wm_adsp *dsp = &dsps[mc->shift - 1];
 	char preload[32];
 
-	if (dsp->preloaded == ucontrol->value.integer.value[0])
-		return 0;
+	snprintf(preload, ARRAY_SIZE(preload), "%s Preload", dsp->name);
 
-	snprintf(preload, ARRAY_SIZE(preload), "%s Preload", dsp->cs_dsp.name);
+	dsp->preloaded = ucontrol->value.integer.value[0];
 
-	if (ucontrol->value.integer.value[0] || dsp->toggle_preload)
+	if (ucontrol->value.integer.value[0])
 		snd_soc_component_force_enable_pin(component, preload);
 	else
 		snd_soc_component_disable_pin(component, preload);
@@ -985,42 +3157,20 @@
 
 	flush_work(&dsp->boot_work);
 
-	dsp->preloaded = ucontrol->value.integer.value[0];
-
-	if (dsp->toggle_preload) {
-		snd_soc_component_disable_pin(component, preload);
-		snd_soc_dapm_sync(dapm);
-	}
-
 	return 0;
 }
 EXPORT_SYMBOL_GPL(wm_adsp2_preloader_put);
 
-static void wm_adsp_boot_work(struct work_struct *work)
+static void wm_adsp_stop_watchdog(struct wm_adsp *dsp)
 {
-	struct wm_adsp *dsp = container_of(work,
-					   struct wm_adsp,
-					   boot_work);
-	int ret = 0;
-	char *wmfw_filename = NULL;
-	const struct firmware *wmfw_firmware = NULL;
-	char *coeff_filename = NULL;
-	const struct firmware *coeff_firmware = NULL;
-
-	ret = wm_adsp_request_firmware_files(dsp,
-					     &wmfw_firmware, &wmfw_filename,
-					     &coeff_firmware, &coeff_filename);
-	if (ret)
-		return;
+	regmap_update_bits(dsp->regmap, dsp->base + ADSP2_WATCHDOG,
+			   ADSP2_WDT_ENA_MASK, 0);
+}
 
-	cs_dsp_power_up(&dsp->cs_dsp,
-			wmfw_firmware, wmfw_filename,
-			coeff_firmware, coeff_filename,
-			wm_adsp_fw_text[dsp->fw]);
-
-	wm_adsp_release_firmware_files(dsp,
-				       wmfw_firmware, wmfw_filename,
-				       coeff_firmware, coeff_filename);
+static void wm_halo_stop_watchdog(struct wm_adsp *dsp)
+{
+	regmap_update_bits(dsp->regmap, dsp->base + HALO_WDT_CONTROL,
+			   HALO_WDT_EN_MASK, 0);
 }
 
 int wm_adsp_early_event(struct snd_soc_dapm_widget *w,
@@ -1029,13 +3179,33 @@
 	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
 	struct wm_adsp *dsps = snd_soc_component_get_drvdata(component);
 	struct wm_adsp *dsp = &dsps[w->shift];
+	struct wm_coeff_ctl *ctl;
 
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
 		queue_work(system_unbound_wq, &dsp->boot_work);
 		break;
 	case SND_SOC_DAPM_PRE_PMD:
-		cs_dsp_power_down(&dsp->cs_dsp);
+		mutex_lock(&dsp->pwr_lock);
+
+		wm_adsp_debugfs_clear(dsp);
+
+		dsp->fw_id = 0;
+		dsp->fw_id_version = 0;
+
+		dsp->booted = false;
+
+		if (dsp->ops->disable_memory)
+			dsp->ops->disable_memory(dsp);
+
+		list_for_each_entry(ctl, &dsp->ctl_list, list)
+			ctl->enabled = 0;
+
+		wm_adsp_free_alg_regions(dsp);
+
+		mutex_unlock(&dsp->pwr_lock);
+
+		adsp_dbg(dsp, "Shutdown complete\n");
 		break;
 	default:
 		break;
@@ -1045,24 +3215,17 @@
 }
 EXPORT_SYMBOL_GPL(wm_adsp_early_event);
 
-static int wm_adsp_event_post_run(struct cs_dsp *cs_dsp)
+static int wm_adsp2_start_core(struct wm_adsp *dsp)
 {
-	struct wm_adsp *dsp = container_of(cs_dsp, struct wm_adsp, cs_dsp);
-
-	if (wm_adsp_fw[dsp->fw].num_caps != 0)
-		return wm_adsp_buffer_init(dsp);
-
-	return 0;
+	return regmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,
+				 ADSP2_CORE_ENA | ADSP2_START,
+				 ADSP2_CORE_ENA | ADSP2_START);
 }
 
-static void wm_adsp_event_post_stop(struct cs_dsp *cs_dsp)
+static void wm_adsp2_stop_core(struct wm_adsp *dsp)
 {
-	struct wm_adsp *dsp = container_of(cs_dsp, struct wm_adsp, cs_dsp);
-
-	if (wm_adsp_fw[dsp->fw].num_caps != 0)
-		wm_adsp_buffer_free(dsp);
-
-	dsp->fatal_error = false;
+	regmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,
+			   ADSP2_CORE_ENA | ADSP2_START, 0);
 }
 
 int wm_adsp_event(struct snd_soc_dapm_widget *w,
@@ -1071,32 +3234,126 @@
 	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
 	struct wm_adsp *dsps = snd_soc_component_get_drvdata(component);
 	struct wm_adsp *dsp = &dsps[w->shift];
-	int ret = 0;
+	int ret;
 
 	switch (event) {
 	case SND_SOC_DAPM_POST_PMU:
 		flush_work(&dsp->boot_work);
-		ret = cs_dsp_run(&dsp->cs_dsp);
+
+		mutex_lock(&dsp->pwr_lock);
+
+		if (!dsp->booted) {
+			ret = -EIO;
+			goto err;
+		}
+
+		if (dsp->ops->enable_core) {
+			ret = dsp->ops->enable_core(dsp);
+			if (ret != 0)
+				goto err;
+		}
+
+		/* Sync set controls */
+		ret = wm_coeff_sync_controls(dsp);
+		if (ret != 0)
+			goto err;
+
+		if (dsp->ops->lock_memory) {
+			ret = dsp->ops->lock_memory(dsp, dsp->lock_regions);
+			if (ret != 0) {
+				adsp_err(dsp, "Error configuring MPU: %d\n",
+					 ret);
+				goto err;
+			}
+		}
+
+		if (dsp->ops->start_core) {
+			ret = dsp->ops->start_core(dsp);
+			if (ret != 0)
+				goto err;
+		}
+
+		if (wm_adsp_fw[dsp->fw].num_caps != 0) {
+			ret = wm_adsp_buffer_init(dsp);
+			if (ret < 0)
+				goto err;
+		}
+
+		dsp->running = true;
+
+		mutex_unlock(&dsp->pwr_lock);
 		break;
+
 	case SND_SOC_DAPM_PRE_PMD:
-		cs_dsp_stop(&dsp->cs_dsp);
+		/* Tell the firmware to cleanup */
+		wm_adsp_signal_event_controls(dsp, WM_ADSP_FW_EVENT_SHUTDOWN);
+
+		if (dsp->ops->stop_watchdog)
+			dsp->ops->stop_watchdog(dsp);
+
+		/* Log firmware state, it can be useful for analysis */
+		if (dsp->ops->show_fw_status)
+			dsp->ops->show_fw_status(dsp);
+
+		mutex_lock(&dsp->pwr_lock);
+
+		dsp->running = false;
+
+		if (dsp->ops->stop_core)
+			dsp->ops->stop_core(dsp);
+		if (dsp->ops->disable_core)
+			dsp->ops->disable_core(dsp);
+
+		if (wm_adsp_fw[dsp->fw].num_caps != 0)
+			wm_adsp_buffer_free(dsp);
+
+		dsp->fatal_error = false;
+
+		mutex_unlock(&dsp->pwr_lock);
+
+		adsp_dbg(dsp, "Execution stopped\n");
 		break;
+
 	default:
 		break;
 	}
 
+	return 0;
+err:
+	if (dsp->ops->stop_core)
+		dsp->ops->stop_core(dsp);
+	if (dsp->ops->disable_core)
+		dsp->ops->disable_core(dsp);
+	mutex_unlock(&dsp->pwr_lock);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(wm_adsp_event);
 
+static int wm_halo_start_core(struct wm_adsp *dsp)
+{
+	return regmap_update_bits(dsp->regmap,
+				  dsp->base + HALO_CCM_CORE_CONTROL,
+				  HALO_CORE_EN, HALO_CORE_EN);
+}
+
+static void wm_halo_stop_core(struct wm_adsp *dsp)
+{
+	regmap_update_bits(dsp->regmap, dsp->base + HALO_CCM_CORE_CONTROL,
+			   HALO_CORE_EN, 0);
+
+	/* reset halo core with CORE_SOFT_RESET */
+	regmap_update_bits(dsp->regmap, dsp->base + HALO_CORE_SOFT_RESET,
+			   HALO_CORE_SOFT_RESET_MASK, 1);
+}
+
 int wm_adsp2_component_probe(struct wm_adsp *dsp, struct snd_soc_component *component)
 {
 	char preload[32];
 
-	snprintf(preload, ARRAY_SIZE(preload), "%s Preload", dsp->cs_dsp.name);
+	snprintf(preload, ARRAY_SIZE(preload), "%s Preload", dsp->name);
 	snd_soc_component_disable_pin(component, preload);
 
-	cs_dsp_init_debugfs(&dsp->cs_dsp, component->debugfs_root);
+	wm_adsp2_init_debugfs(dsp, component);
 
 	dsp->component = component;
 
@@ -1106,7 +3363,7 @@
 
 int wm_adsp2_component_remove(struct wm_adsp *dsp, struct snd_soc_component *component)
 {
-	cs_dsp_cleanup_debugfs(&dsp->cs_dsp);
+	wm_adsp2_cleanup_debugfs(dsp);
 
 	return 0;
 }
@@ -1116,16 +3373,37 @@
 {
 	int ret;
 
-	INIT_WORK(&dsp->boot_work, wm_adsp_boot_work);
-
-	dsp->sys_config_size = sizeof(struct wm_adsp_system_config_xm_hdr);
-	dsp->cs_dsp.client_ops = &wm_adsp2_client_ops;
-
-	ret = cs_dsp_adsp2_init(&dsp->cs_dsp);
+	ret = wm_adsp_common_init(dsp);
 	if (ret)
 		return ret;
 
-	return wm_adsp_common_init(dsp);
+	switch (dsp->rev) {
+	case 0:
+		/*
+		 * Disable the DSP memory by default when in reset for a small
+		 * power saving.
+		 */
+		ret = regmap_update_bits(dsp->regmap, dsp->base + ADSP2_CONTROL,
+					 ADSP2_MEM_ENA, 0);
+		if (ret) {
+			adsp_err(dsp,
+				 "Failed to clear memory retention: %d\n", ret);
+			return ret;
+		}
+
+		dsp->ops = &wm_adsp2_ops[0];
+		break;
+	case 1:
+		dsp->ops = &wm_adsp2_ops[1];
+		break;
+	default:
+		dsp->ops = &wm_adsp2_ops[2];
+		break;
+	}
+
+	INIT_WORK(&dsp->boot_work, wm_adsp_boot_work);
+
+	return 0;
 }
 EXPORT_SYMBOL_GPL(wm_adsp2_init);
 
@@ -1133,22 +3411,28 @@
 {
 	int ret;
 
-	INIT_WORK(&dsp->boot_work, wm_adsp_boot_work);
-
-	dsp->sys_config_size = sizeof(struct wm_halo_system_config_xm_hdr);
-	dsp->cs_dsp.client_ops = &wm_adsp2_client_ops;
-
-	ret = cs_dsp_halo_init(&dsp->cs_dsp);
+	ret = wm_adsp_common_init(dsp);
 	if (ret)
 		return ret;
 
-	return wm_adsp_common_init(dsp);
+	dsp->ops = &wm_halo_ops;
+
+	INIT_WORK(&dsp->boot_work, wm_adsp_boot_work);
+
+	return 0;
 }
 EXPORT_SYMBOL_GPL(wm_halo_init);
 
 void wm_adsp2_remove(struct wm_adsp *dsp)
 {
-	cs_dsp_remove(&dsp->cs_dsp);
+	struct wm_coeff_ctl *ctl;
+
+	while (!list_empty(&dsp->ctl_list)) {
+		ctl = list_first_entry(&dsp->ctl_list, struct wm_coeff_ctl,
+					list);
+		list_del(&ctl->list);
+		wm_adsp_free_ctl_blk(ctl);
+	}
 }
 EXPORT_SYMBOL_GPL(wm_adsp2_remove);
 
@@ -1201,7 +3485,7 @@
 	struct snd_soc_pcm_runtime *rtd = stream->private_data;
 	int ret = 0;
 
-	mutex_lock(&dsp->cs_dsp.pwr_lock);
+	mutex_lock(&dsp->pwr_lock);
 
 	if (wm_adsp_fw[dsp->fw].num_caps == 0) {
 		adsp_err(dsp, "%s: Firmware does not support compressed API\n",
@@ -1241,7 +3525,7 @@
 	stream->runtime->private_data = compr;
 
 out:
-	mutex_unlock(&dsp->cs_dsp.pwr_lock);
+	mutex_unlock(&dsp->pwr_lock);
 
 	return ret;
 }
@@ -1253,7 +3537,7 @@
 	struct wm_adsp_compr *compr = stream->runtime->private_data;
 	struct wm_adsp *dsp = compr->dsp;
 
-	mutex_lock(&dsp->cs_dsp.pwr_lock);
+	mutex_lock(&dsp->pwr_lock);
 
 	wm_adsp_compr_detach(compr);
 	list_del(&compr->list);
@@ -1261,7 +3545,7 @@
 	kfree(compr->raw_buf);
 	kfree(compr);
 
-	mutex_unlock(&dsp->cs_dsp.pwr_lock);
+	mutex_unlock(&dsp->pwr_lock);
 
 	return 0;
 }
@@ -1280,7 +3564,7 @@
 	    params->buffer.fragment_size > WM_ADSP_MAX_FRAGMENT_SIZE ||
 	    params->buffer.fragments < WM_ADSP_MIN_FRAGMENTS ||
 	    params->buffer.fragments > WM_ADSP_MAX_FRAGMENTS ||
-	    params->buffer.fragment_size % CS_DSP_DATA_WORD_SIZE) {
+	    params->buffer.fragment_size % WM_ADSP_DATA_WORD_SIZE) {
 		compr_err(compr, "Invalid buffer fragsize=%d fragments=%d\n",
 			  params->buffer.fragment_size,
 			  params->buffer.fragments);
@@ -1319,7 +3603,7 @@
 
 static inline unsigned int wm_adsp_compr_frag_words(struct wm_adsp_compr *compr)
 {
-	return compr->size.fragment_size / CS_DSP_DATA_WORD_SIZE;
+	return compr->size.fragment_size / WM_ADSP_DATA_WORD_SIZE;
 }
 
 int wm_adsp_compr_set_params(struct snd_soc_component *component,
@@ -1375,19 +3659,88 @@
 }
 EXPORT_SYMBOL_GPL(wm_adsp_compr_get_caps);
 
+static int wm_adsp_read_raw_data_block(struct wm_adsp *dsp, int mem_type,
+				       unsigned int mem_addr,
+				       unsigned int num_words, __be32 *data)
+{
+	struct wm_adsp_region const *mem = wm_adsp_find_region(dsp, mem_type);
+	unsigned int reg;
+	int ret;
+
+	if (!mem)
+		return -EINVAL;
+
+	reg = dsp->ops->region_to_reg(mem, mem_addr);
+
+	ret = regmap_raw_read(dsp->regmap, reg, data,
+			      sizeof(*data) * num_words);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static inline int wm_adsp_read_data_word(struct wm_adsp *dsp, int mem_type,
+					 unsigned int mem_addr, u32 *data)
+{
+	__be32 raw;
+	int ret;
+
+	ret = wm_adsp_read_raw_data_block(dsp, mem_type, mem_addr, 1, &raw);
+	if (ret < 0)
+		return ret;
+
+	*data = be32_to_cpu(raw) & 0x00ffffffu;
+
+	return 0;
+}
+
+static int wm_adsp_write_data_word(struct wm_adsp *dsp, int mem_type,
+				   unsigned int mem_addr, u32 data)
+{
+	struct wm_adsp_region const *mem = wm_adsp_find_region(dsp, mem_type);
+	__be32 val = cpu_to_be32(data & 0x00ffffffu);
+	unsigned int reg;
+
+	if (!mem)
+		return -EINVAL;
+
+	reg = dsp->ops->region_to_reg(mem, mem_addr);
+
+	return regmap_raw_write(dsp->regmap, reg, &val, sizeof(val));
+}
+
 static inline int wm_adsp_buffer_read(struct wm_adsp_compr_buf *buf,
 				      unsigned int field_offset, u32 *data)
 {
-	return cs_dsp_read_data_word(&buf->dsp->cs_dsp, buf->host_buf_mem_type,
-				     buf->host_buf_ptr + field_offset, data);
+	return wm_adsp_read_data_word(buf->dsp, buf->host_buf_mem_type,
+				      buf->host_buf_ptr + field_offset, data);
 }
 
 static inline int wm_adsp_buffer_write(struct wm_adsp_compr_buf *buf,
 				       unsigned int field_offset, u32 data)
 {
-	return cs_dsp_write_data_word(&buf->dsp->cs_dsp, buf->host_buf_mem_type,
-				      buf->host_buf_ptr + field_offset,
-				      data);
+	return wm_adsp_write_data_word(buf->dsp, buf->host_buf_mem_type,
+				       buf->host_buf_ptr + field_offset, data);
+}
+
+static void wm_adsp_remove_padding(u32 *buf, int nwords)
+{
+	const __be32 *pack_in = (__be32 *)buf;
+	u8 *pack_out = (u8 *)buf;
+	int i;
+
+	/*
+	 * DSP words from the register map have pad bytes and the data bytes
+	 * are in swapped order. This swaps back to the original little-endian
+	 * order and strips the pad bytes.
+	 */
+	for (i = 0; i < nwords; i++) {
+		u32 word = be32_to_cpu(*pack_in++);
+		*pack_out++ = (u8)word;
+		*pack_out++ = (u8)(word >> 8);
+		*pack_out++ = (u8)(word >> 16);
+	}
 }
 
 static int wm_adsp_buffer_populate(struct wm_adsp_compr_buf *buf)
@@ -1455,12 +3808,12 @@
 
 static int wm_adsp_buffer_parse_legacy(struct wm_adsp *dsp)
 {
-	struct cs_dsp_alg_region *alg_region;
+	struct wm_adsp_alg_region *alg_region;
 	struct wm_adsp_compr_buf *buf;
 	u32 xmalg, addr, magic;
 	int i, ret;
 
-	alg_region = cs_dsp_find_alg_region(&dsp->cs_dsp, WMFW_ADSP2_XM, dsp->cs_dsp.fw_id);
+	alg_region = wm_adsp_find_alg_region(dsp, WMFW_ADSP2_XM, dsp->fw_id);
 	if (!alg_region) {
 		adsp_err(dsp, "No algorithm region found\n");
 		return -EINVAL;
@@ -1470,10 +3823,10 @@
 	if (!buf)
 		return -ENOMEM;
 
-	xmalg = dsp->sys_config_size / sizeof(__be32);
+	xmalg = dsp->ops->sys_config_size / sizeof(__be32);
 
 	addr = alg_region->base + xmalg + ALG_XM_FIELD(magic);
-	ret = cs_dsp_read_data_word(&dsp->cs_dsp, WMFW_ADSP2_XM, addr, &magic);
+	ret = wm_adsp_read_data_word(dsp, WMFW_ADSP2_XM, addr, &magic);
 	if (ret < 0)
 		return ret;
 
@@ -1482,8 +3835,8 @@
 
 	addr = alg_region->base + xmalg + ALG_XM_FIELD(host_buf_ptr);
 	for (i = 0; i < 5; ++i) {
-		ret = cs_dsp_read_data_word(&dsp->cs_dsp, WMFW_ADSP2_XM, addr,
-					    &buf->host_buf_ptr);
+		ret = wm_adsp_read_data_word(dsp, WMFW_ADSP2_XM, addr,
+					     &buf->host_buf_ptr);
 		if (ret < 0)
 			return ret;
 
@@ -1507,37 +3860,40 @@
 	return 0;
 }
 
-static int wm_adsp_buffer_parse_coeff(struct cs_dsp_coeff_ctl *cs_ctl)
+static int wm_adsp_buffer_parse_coeff(struct wm_coeff_ctl *ctl)
 {
 	struct wm_adsp_host_buf_coeff_v1 coeff_v1;
 	struct wm_adsp_compr_buf *buf;
-	struct wm_adsp *dsp = container_of(cs_ctl->dsp, struct wm_adsp, cs_dsp);
-	unsigned int version;
+	unsigned int reg, version;
+	__be32 bufp;
 	int ret, i;
 
+	ret = wm_coeff_base_reg(ctl, &reg);
+	if (ret)
+		return ret;
+
 	for (i = 0; i < 5; ++i) {
-		ret = cs_dsp_coeff_read_ctrl(cs_ctl, 0, &coeff_v1,
-					     min(cs_ctl->len, sizeof(coeff_v1)));
+		ret = regmap_raw_read(ctl->dsp->regmap, reg, &bufp, sizeof(bufp));
 		if (ret < 0)
 			return ret;
 
-		if (coeff_v1.host_buf_ptr)
+		if (bufp)
 			break;
 
 		usleep_range(1000, 2000);
 	}
 
-	if (!coeff_v1.host_buf_ptr) {
-		adsp_err(dsp, "Failed to acquire host buffer\n");
+	if (!bufp) {
+		adsp_err(ctl->dsp, "Failed to acquire host buffer\n");
 		return -EIO;
 	}
 
-	buf = wm_adsp_buffer_alloc(dsp);
+	buf = wm_adsp_buffer_alloc(ctl->dsp);
 	if (!buf)
 		return -ENOMEM;
 
-	buf->host_buf_mem_type = cs_ctl->alg_region.type;
-	buf->host_buf_ptr = be32_to_cpu(coeff_v1.host_buf_ptr);
+	buf->host_buf_mem_type = ctl->alg_region.type;
+	buf->host_buf_ptr = be32_to_cpu(bufp);
 
 	ret = wm_adsp_buffer_populate(buf);
 	if (ret < 0)
@@ -1547,24 +3903,29 @@
 	 * v0 host_buffer coefficients didn't have versioning, so if the
 	 * control is one word, assume version 0.
 	 */
-	if (cs_ctl->len == 4) {
+	if (ctl->len == 4) {
 		compr_dbg(buf, "host_buf_ptr=%x\n", buf->host_buf_ptr);
 		return 0;
 	}
 
+	ret = regmap_raw_read(ctl->dsp->regmap, reg, &coeff_v1,
+			      sizeof(coeff_v1));
+	if (ret < 0)
+		return ret;
+
 	version = be32_to_cpu(coeff_v1.versions) & HOST_BUF_COEFF_COMPAT_VER_MASK;
 	version >>= HOST_BUF_COEFF_COMPAT_VER_SHIFT;
 
 	if (version > HOST_BUF_COEFF_SUPPORTED_COMPAT_VER) {
-		adsp_err(dsp,
+		adsp_err(ctl->dsp,
 			 "Host buffer coeff ver %u > supported version %u\n",
 			 version, HOST_BUF_COEFF_SUPPORTED_COMPAT_VER);
 		return -EINVAL;
 	}
 
-	cs_dsp_remove_padding((u32 *)&coeff_v1.name, ARRAY_SIZE(coeff_v1.name));
+	wm_adsp_remove_padding((u32 *)&coeff_v1.name, ARRAY_SIZE(coeff_v1.name));
 
-	buf->name = kasprintf(GFP_KERNEL, "%s-dsp-%s", dsp->part,
+	buf->name = kasprintf(GFP_KERNEL, "%s-dsp-%s", ctl->dsp->part,
 			      (char *)&coeff_v1.name);
 
 	compr_dbg(buf, "host_buf_ptr=%x coeff version %u\n",
@@ -1575,17 +3936,17 @@
 
 static int wm_adsp_buffer_init(struct wm_adsp *dsp)
 {
-	struct cs_dsp_coeff_ctl *cs_ctl;
+	struct wm_coeff_ctl *ctl;
 	int ret;
 
-	list_for_each_entry(cs_ctl, &dsp->cs_dsp.ctl_list, list) {
-		if (cs_ctl->type != WMFW_CTL_TYPE_HOST_BUFFER)
+	list_for_each_entry(ctl, &dsp->ctl_list, list) {
+		if (ctl->type != WMFW_CTL_TYPE_HOST_BUFFER)
 			continue;
 
-		if (!cs_ctl->enabled)
+		if (!ctl->enabled)
 			continue;
 
-		ret = wm_adsp_buffer_parse_coeff(cs_ctl);
+		ret = wm_adsp_buffer_parse_coeff(ctl);
 		if (ret < 0) {
 			adsp_err(dsp, "Failed to parse coeff: %d\n", ret);
 			goto error;
@@ -1653,7 +4014,7 @@
 
 	compr_dbg(compr, "Trigger: %d\n", cmd);
 
-	mutex_lock(&dsp->cs_dsp.pwr_lock);
+	mutex_lock(&dsp->pwr_lock);
 
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
@@ -1689,7 +4050,7 @@
 		break;
 	}
 
-	mutex_unlock(&dsp->cs_dsp.pwr_lock);
+	mutex_unlock(&dsp->pwr_lock);
 
 	return ret;
 }
@@ -1738,7 +4099,7 @@
 		avail += wm_adsp_buffer_size(buf);
 
 	compr_dbg(buf, "readindex=0x%x, writeindex=0x%x, avail=%d\n",
-		  buf->read_index, write_index, avail * CS_DSP_DATA_WORD_SIZE);
+		  buf->read_index, write_index, avail * WM_ADSP_DATA_WORD_SIZE);
 
 	buf->avail = avail;
 
@@ -1751,7 +4112,7 @@
 	struct wm_adsp_compr *compr;
 	int ret = 0;
 
-	mutex_lock(&dsp->cs_dsp.pwr_lock);
+	mutex_lock(&dsp->pwr_lock);
 
 	if (list_empty(&dsp->buffer_list)) {
 		ret = -ENODEV;
@@ -1789,7 +4150,7 @@
 	}
 
 out:
-	mutex_unlock(&dsp->cs_dsp.pwr_lock);
+	mutex_unlock(&dsp->pwr_lock);
 
 	return ret;
 }
@@ -1819,7 +4180,7 @@
 
 	compr_dbg(compr, "Pointer request\n");
 
-	mutex_lock(&dsp->cs_dsp.pwr_lock);
+	mutex_lock(&dsp->pwr_lock);
 
 	buf = compr->buf;
 
@@ -1859,11 +4220,11 @@
 	}
 
 	tstamp->copied_total = compr->copied_total;
-	tstamp->copied_total += buf->avail * CS_DSP_DATA_WORD_SIZE;
+	tstamp->copied_total += buf->avail * WM_ADSP_DATA_WORD_SIZE;
 	tstamp->sampling_rate = compr->sample_rate;
 
 out:
-	mutex_unlock(&dsp->cs_dsp.pwr_lock);
+	mutex_unlock(&dsp->pwr_lock);
 
 	return ret;
 }
@@ -1901,12 +4262,12 @@
 		return 0;
 
 	/* Read data from DSP */
-	ret = cs_dsp_read_raw_data_block(&buf->dsp->cs_dsp, mem_type, adsp_addr,
-					 nwords, (__be32 *)compr->raw_buf);
+	ret = wm_adsp_read_raw_data_block(buf->dsp, mem_type, adsp_addr,
+					  nwords, (__be32 *)compr->raw_buf);
 	if (ret < 0)
 		return ret;
 
-	cs_dsp_remove_padding(compr->raw_buf, nwords);
+	wm_adsp_remove_padding(compr->raw_buf, nwords);
 
 	/* update read index to account for words read */
 	buf->read_index += nwords;
@@ -1938,7 +4299,7 @@
 		return -EIO;
 	}
 
-	count /= CS_DSP_DATA_WORD_SIZE;
+	count /= WM_ADSP_DATA_WORD_SIZE;
 
 	do {
 		nwords = wm_adsp_buffer_capture_block(compr, count);
@@ -1948,7 +4309,7 @@
 			return nwords;
 		}
 
-		nbytes = nwords * CS_DSP_DATA_WORD_SIZE;
+		nbytes = nwords * WM_ADSP_DATA_WORD_SIZE;
 
 		compr_dbg(compr, "Read %d bytes\n", nbytes);
 
@@ -1975,22 +4336,21 @@
 	struct wm_adsp *dsp = compr->dsp;
 	int ret;
 
-	mutex_lock(&dsp->cs_dsp.pwr_lock);
+	mutex_lock(&dsp->pwr_lock);
 
 	if (stream->direction == SND_COMPRESS_CAPTURE)
 		ret = wm_adsp_compr_read(compr, buf, count);
 	else
 		ret = -ENOTSUPP;
 
-	mutex_unlock(&dsp->cs_dsp.pwr_lock);
+	mutex_unlock(&dsp->pwr_lock);
 
 	return ret;
 }
 EXPORT_SYMBOL_GPL(wm_adsp_compr_copy);
 
-static void wm_adsp_fatal_error(struct cs_dsp *cs_dsp)
+static void wm_adsp_fatal_error(struct wm_adsp *dsp)
 {
-	struct wm_adsp *dsp = container_of(cs_dsp, struct wm_adsp, cs_dsp);
 	struct wm_adsp_compr *compr;
 
 	dsp->fatal_error = true;
@@ -2004,8 +4364,64 @@
 irqreturn_t wm_adsp2_bus_error(int irq, void *data)
 {
 	struct wm_adsp *dsp = (struct wm_adsp *)data;
+	unsigned int val;
+	struct regmap *regmap = dsp->regmap;
+	int ret = 0;
+
+	mutex_lock(&dsp->pwr_lock);
+
+	ret = regmap_read(regmap, dsp->base + ADSP2_LOCK_REGION_CTRL, &val);
+	if (ret) {
+		adsp_err(dsp,
+			"Failed to read Region Lock Ctrl register: %d\n", ret);
+		goto error;
+	}
+
+	if (val & ADSP2_WDT_TIMEOUT_STS_MASK) {
+		adsp_err(dsp, "watchdog timeout error\n");
+		dsp->ops->stop_watchdog(dsp);
+		wm_adsp_fatal_error(dsp);
+	}
+
+	if (val & (ADSP2_ADDR_ERR_MASK | ADSP2_REGION_LOCK_ERR_MASK)) {
+		if (val & ADSP2_ADDR_ERR_MASK)
+			adsp_err(dsp, "bus error: address error\n");
+		else
+			adsp_err(dsp, "bus error: region lock error\n");
+
+		ret = regmap_read(regmap, dsp->base + ADSP2_BUS_ERR_ADDR, &val);
+		if (ret) {
+			adsp_err(dsp,
+				 "Failed to read Bus Err Addr register: %d\n",
+				 ret);
+			goto error;
+		}
+
+		adsp_err(dsp, "bus error address = 0x%x\n",
+			 val & ADSP2_BUS_ERR_ADDR_MASK);
+
+		ret = regmap_read(regmap,
+				  dsp->base + ADSP2_PMEM_ERR_ADDR_XMEM_ERR_ADDR,
+				  &val);
+		if (ret) {
+			adsp_err(dsp,
+				 "Failed to read Pmem Xmem Err Addr register: %d\n",
+				 ret);
+			goto error;
+		}
+
+		adsp_err(dsp, "xmem error address = 0x%x\n",
+			 val & ADSP2_XMEM_ERR_ADDR_MASK);
+		adsp_err(dsp, "pmem error address = 0x%x\n",
+			 (val & ADSP2_PMEM_ERR_ADDR_MASK) >>
+			 ADSP2_PMEM_ERR_ADDR_SHIFT);
+	}
 
-	cs_dsp_adsp2_bus_error(&dsp->cs_dsp);
+	regmap_update_bits(regmap, dsp->base + ADSP2_LOCK_REGION_CTRL,
+			   ADSP2_CTRL_ERR_EINT, ADSP2_CTRL_ERR_EINT);
+
+error:
+	mutex_unlock(&dsp->pwr_lock);
 
 	return IRQ_HANDLED;
 }
@@ -2014,8 +4430,55 @@
 irqreturn_t wm_halo_bus_error(int irq, void *data)
 {
 	struct wm_adsp *dsp = (struct wm_adsp *)data;
+	struct regmap *regmap = dsp->regmap;
+	unsigned int fault[6];
+	struct reg_sequence clear[] = {
+		{ dsp->base + HALO_MPU_XM_VIO_STATUS,     0x0 },
+		{ dsp->base + HALO_MPU_YM_VIO_STATUS,     0x0 },
+		{ dsp->base + HALO_MPU_PM_VIO_STATUS,     0x0 },
+	};
+	int ret;
 
-	cs_dsp_halo_bus_error(&dsp->cs_dsp);
+	mutex_lock(&dsp->pwr_lock);
+
+	ret = regmap_read(regmap, dsp->base_sysinfo + HALO_AHBM_WINDOW_DEBUG_1,
+			  fault);
+	if (ret) {
+		adsp_warn(dsp, "Failed to read AHB DEBUG_1: %d\n", ret);
+		goto exit_unlock;
+	}
+
+	adsp_warn(dsp, "AHB: STATUS: 0x%x ADDR: 0x%x\n",
+		  *fault & HALO_AHBM_FLAGS_ERR_MASK,
+		  (*fault & HALO_AHBM_CORE_ERR_ADDR_MASK) >>
+		  HALO_AHBM_CORE_ERR_ADDR_SHIFT);
+
+	ret = regmap_read(regmap, dsp->base_sysinfo + HALO_AHBM_WINDOW_DEBUG_0,
+			  fault);
+	if (ret) {
+		adsp_warn(dsp, "Failed to read AHB DEBUG_0: %d\n", ret);
+		goto exit_unlock;
+	}
+
+	adsp_warn(dsp, "AHB: SYS_ADDR: 0x%x\n", *fault);
+
+	ret = regmap_bulk_read(regmap, dsp->base + HALO_MPU_XM_VIO_ADDR,
+			       fault, ARRAY_SIZE(fault));
+	if (ret) {
+		adsp_warn(dsp, "Failed to read MPU fault info: %d\n", ret);
+		goto exit_unlock;
+	}
+
+	adsp_warn(dsp, "XM: STATUS:0x%x ADDR:0x%x\n", fault[1], fault[0]);
+	adsp_warn(dsp, "YM: STATUS:0x%x ADDR:0x%x\n", fault[3], fault[2]);
+	adsp_warn(dsp, "PM: STATUS:0x%x ADDR:0x%x\n", fault[5], fault[4]);
+
+	ret = regmap_multi_reg_write(dsp->regmap, clear, ARRAY_SIZE(clear));
+	if (ret)
+		adsp_warn(dsp, "Failed to clear MPU status: %d\n", ret);
+
+exit_unlock:
+	mutex_unlock(&dsp->pwr_lock);
 
 	return IRQ_HANDLED;
 }
@@ -2025,23 +4488,99 @@
 {
 	struct wm_adsp *dsp = data;
 
-	cs_dsp_halo_wdt_expire(&dsp->cs_dsp);
+	mutex_lock(&dsp->pwr_lock);
+
+	adsp_warn(dsp, "WDT Expiry Fault\n");
+	dsp->ops->stop_watchdog(dsp);
+	wm_adsp_fatal_error(dsp);
+
+	mutex_unlock(&dsp->pwr_lock);
 
 	return IRQ_HANDLED;
 }
 EXPORT_SYMBOL_GPL(wm_halo_wdt_expire);
 
-static const struct cs_dsp_client_ops wm_adsp1_client_ops = {
-	.control_add = wm_adsp_control_add,
-	.control_remove = wm_adsp_control_remove,
+static struct wm_adsp_ops wm_adsp1_ops = {
+	.validate_version = wm_adsp_validate_version,
+	.parse_sizes = wm_adsp1_parse_sizes,
+	.region_to_reg = wm_adsp_region_to_reg,
 };
 
-static const struct cs_dsp_client_ops wm_adsp2_client_ops = {
-	.control_add = wm_adsp_control_add,
-	.control_remove = wm_adsp_control_remove,
-	.post_run = wm_adsp_event_post_run,
-	.post_stop = wm_adsp_event_post_stop,
-	.watchdog_expired = wm_adsp_fatal_error,
+static struct wm_adsp_ops wm_adsp2_ops[] = {
+	{
+		.sys_config_size = sizeof(struct wm_adsp_system_config_xm_hdr),
+		.parse_sizes = wm_adsp2_parse_sizes,
+		.validate_version = wm_adsp_validate_version,
+		.setup_algs = wm_adsp2_setup_algs,
+		.region_to_reg = wm_adsp_region_to_reg,
+
+		.show_fw_status = wm_adsp2_show_fw_status,
+
+		.enable_memory = wm_adsp2_enable_memory,
+		.disable_memory = wm_adsp2_disable_memory,
+
+		.enable_core = wm_adsp2_enable_core,
+		.disable_core = wm_adsp2_disable_core,
+
+		.start_core = wm_adsp2_start_core,
+		.stop_core = wm_adsp2_stop_core,
+
+	},
+	{
+		.sys_config_size = sizeof(struct wm_adsp_system_config_xm_hdr),
+		.parse_sizes = wm_adsp2_parse_sizes,
+		.validate_version = wm_adsp_validate_version,
+		.setup_algs = wm_adsp2_setup_algs,
+		.region_to_reg = wm_adsp_region_to_reg,
+
+		.show_fw_status = wm_adsp2v2_show_fw_status,
+
+		.enable_memory = wm_adsp2_enable_memory,
+		.disable_memory = wm_adsp2_disable_memory,
+		.lock_memory = wm_adsp2_lock,
+
+		.enable_core = wm_adsp2v2_enable_core,
+		.disable_core = wm_adsp2v2_disable_core,
+
+		.start_core = wm_adsp2_start_core,
+		.stop_core = wm_adsp2_stop_core,
+	},
+	{
+		.sys_config_size = sizeof(struct wm_adsp_system_config_xm_hdr),
+		.parse_sizes = wm_adsp2_parse_sizes,
+		.validate_version = wm_adsp_validate_version,
+		.setup_algs = wm_adsp2_setup_algs,
+		.region_to_reg = wm_adsp_region_to_reg,
+
+		.show_fw_status = wm_adsp2v2_show_fw_status,
+		.stop_watchdog = wm_adsp_stop_watchdog,
+
+		.enable_memory = wm_adsp2_enable_memory,
+		.disable_memory = wm_adsp2_disable_memory,
+		.lock_memory = wm_adsp2_lock,
+
+		.enable_core = wm_adsp2v2_enable_core,
+		.disable_core = wm_adsp2v2_disable_core,
+
+		.start_core = wm_adsp2_start_core,
+		.stop_core = wm_adsp2_stop_core,
+	},
+};
+
+static struct wm_adsp_ops wm_halo_ops = {
+	.sys_config_size = sizeof(struct wm_halo_system_config_xm_hdr),
+	.parse_sizes = wm_adsp2_parse_sizes,
+	.validate_version = wm_halo_validate_version,
+	.setup_algs = wm_halo_setup_algs,
+	.region_to_reg = wm_halo_region_to_reg,
+
+	.show_fw_status = wm_halo_show_fw_status,
+	.stop_watchdog = wm_halo_stop_watchdog,
+
+	.lock_memory = wm_halo_configure_mpu,
+
+	.start_core = wm_halo_start_core,
+	.stop_core = wm_halo_stop_core,
 };
 
 MODULE_LICENSE("GPL v2");
diff -ruN a/sound/soc/codecs/wm_adsp.h b/sound/soc/codecs/wm_adsp.h
--- a/sound/soc/codecs/wm_adsp.h	2023-02-15 21:20:01.000000000 +0100
+++ b/sound/soc/codecs/wm_adsp.h	2022-07-08 01:12:12.000000000 +0200
@@ -10,46 +10,128 @@
 #ifndef __WM_ADSP_H
 #define __WM_ADSP_H
 
-#include <linux/firmware/cirrus/cs_dsp.h>
-#include <linux/firmware/cirrus/wmfw.h>
-
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
 #include <sound/compress_driver.h>
 
+#include "wmfw.h"
+
 /* Return values for wm_adsp_compr_handle_irq */
 #define WM_ADSP_COMPR_OK                 0
 #define WM_ADSP_COMPR_VOICE_TRIGGER      1
 
+#define WM_ADSP2_REGION_0 BIT(0)
+#define WM_ADSP2_REGION_1 BIT(1)
+#define WM_ADSP2_REGION_2 BIT(2)
+#define WM_ADSP2_REGION_3 BIT(3)
+#define WM_ADSP2_REGION_4 BIT(4)
+#define WM_ADSP2_REGION_5 BIT(5)
+#define WM_ADSP2_REGION_6 BIT(6)
+#define WM_ADSP2_REGION_7 BIT(7)
+#define WM_ADSP2_REGION_8 BIT(8)
+#define WM_ADSP2_REGION_9 BIT(9)
+#define WM_ADSP2_REGION_1_9 (WM_ADSP2_REGION_1 | \
+		WM_ADSP2_REGION_2 | WM_ADSP2_REGION_3 | \
+		WM_ADSP2_REGION_4 | WM_ADSP2_REGION_5 | \
+		WM_ADSP2_REGION_6 | WM_ADSP2_REGION_7 | \
+		WM_ADSP2_REGION_8 | WM_ADSP2_REGION_9)
+#define WM_ADSP2_REGION_ALL (WM_ADSP2_REGION_0 | WM_ADSP2_REGION_1_9)
+
+struct wm_adsp_region {
+	int type;
+	unsigned int base;
+};
+
+struct wm_adsp_alg_region {
+	struct list_head list;
+	unsigned int alg;
+	int type;
+	unsigned int base;
+};
+
 struct wm_adsp_compr;
 struct wm_adsp_compr_buf;
+struct wm_adsp_ops;
 
 struct wm_adsp {
-	struct cs_dsp cs_dsp;
 	const char *part;
+	const char *name;
 	const char *fwf_name;
-	const char *system_name;
+	int rev;
+	int num;
+	int type;
+	struct device *dev;
+	struct regmap *regmap;
 	struct snd_soc_component *component;
 
-	unsigned int sys_config_size;
+	struct wm_adsp_ops *ops;
 
-	int fw;
+	unsigned int base;
+	unsigned int base_sysinfo;
+	unsigned int sysclk_reg;
+	unsigned int sysclk_mask;
+	unsigned int sysclk_shift;
+
+	struct list_head alg_regions;
+
+	unsigned int fw_id;
+	unsigned int fw_id_version;
+	unsigned int fw_vendor_id;
 
-	struct work_struct boot_work;
+	const struct wm_adsp_region *mem;
+	int num_mems;
+
+	int fw;
+	int fw_ver;
 
 	bool preloaded;
+	bool booted;
+	bool running;
 	bool fatal_error;
 
+	struct list_head ctl_list;
+
+	struct work_struct boot_work;
+
 	struct list_head compr_list;
 	struct list_head buffer_list;
 
-	/*
-	 * Flag indicating the preloader widget only needs power toggled
-	 * on state change rather than held on for the duration of the
-	 * preload, useful for devices that can retain firmware memory
-	 * across power down.
-	 */
-	bool toggle_preload;
+	struct mutex pwr_lock;
+
+	unsigned int lock_regions;
+
+#ifdef CONFIG_DEBUG_FS
+	struct dentry *debugfs_root;
+	char *wmfw_file_name;
+	char *bin_file_name;
+#endif
+
+};
+
+struct wm_adsp_ops {
+	unsigned int sys_config_size;
+
+	bool (*validate_version)(struct wm_adsp *dsp, unsigned int version);
+	unsigned int (*parse_sizes)(struct wm_adsp *dsp,
+				    const char * const file,
+				    unsigned int pos,
+				    const struct firmware *firmware);
+	int (*setup_algs)(struct wm_adsp *dsp);
+	unsigned int (*region_to_reg)(struct wm_adsp_region const *mem,
+				      unsigned int offset);
+
+	void (*show_fw_status)(struct wm_adsp *dsp);
+	void (*stop_watchdog)(struct wm_adsp *dsp);
+
+	int (*enable_memory)(struct wm_adsp *dsp);
+	void (*disable_memory)(struct wm_adsp *dsp);
+	int (*lock_memory)(struct wm_adsp *dsp, unsigned int lock_regions);
+
+	int (*enable_core)(struct wm_adsp *dsp);
+	void (*disable_core)(struct wm_adsp *dsp);
+
+	int (*start_core)(struct wm_adsp *dsp);
+	void (*stop_core)(struct wm_adsp *dsp);
 };
 
 #define WM_ADSP1(wname, num) \
diff -ruN a/sound/soc/codecs/wmfw.h b/sound/soc/codecs/wmfw.h
--- a/sound/soc/codecs/wmfw.h	1970-01-01 01:00:00.000000000 +0100
+++ b/sound/soc/codecs/wmfw.h	2022-07-08 01:12:12.000000000 +0200
@@ -0,0 +1,200 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * wmfw.h - Wolfson firmware format information
+ *
+ * Copyright 2012 Wolfson Microelectronics plc
+ *
+ * Author: Mark Brown <broonie@opensource.wolfsonmicro.com>
+ */
+
+#ifndef __WMFW_H
+#define __WMFW_H
+
+#include <linux/types.h>
+
+#define WMFW_MAX_ALG_NAME         256
+#define WMFW_MAX_ALG_DESCR_NAME   256
+
+#define WMFW_MAX_COEFF_NAME       256
+#define WMFW_MAX_COEFF_DESCR_NAME 256
+
+#define WMFW_CTL_FLAG_SYS         0x8000
+#define WMFW_CTL_FLAG_VOLATILE    0x0004
+#define WMFW_CTL_FLAG_WRITEABLE   0x0002
+#define WMFW_CTL_FLAG_READABLE    0x0001
+
+/* Non-ALSA coefficient types start at 0x1000 */
+#define WMFW_CTL_TYPE_ACKED       ((__force snd_ctl_elem_type_t)0x1000) /* acked control */
+#define WMFW_CTL_TYPE_HOSTEVENT   ((__force snd_ctl_elem_type_t)0x1001) /* event control */
+#define WMFW_CTL_TYPE_HOST_BUFFER ((__force snd_ctl_elem_type_t)0x1002) /* host buffer pointer */
+
+struct wmfw_header {
+	char magic[4];
+	__le32 len;
+	__le16 rev;
+	u8 core;
+	u8 ver;
+} __packed;
+
+struct wmfw_footer {
+	__le64 timestamp;
+	__le32 checksum;
+} __packed;
+
+struct wmfw_adsp1_sizes {
+	__le32 dm;
+	__le32 pm;
+	__le32 zm;
+} __packed;
+
+struct wmfw_adsp2_sizes {
+	__le32 xm;
+	__le32 ym;
+	__le32 pm;
+	__le32 zm;
+} __packed;
+
+struct wmfw_region {
+	union {
+		__be32 type;
+		__le32 offset;
+	};
+	__le32 len;
+	u8 data[];
+} __packed;
+
+struct wmfw_id_hdr {
+	__be32 core_id;
+	__be32 core_rev;
+	__be32 id;
+	__be32 ver;
+} __packed;
+
+struct wmfw_v3_id_hdr {
+	__be32 core_id;
+	__be32 block_rev;
+	__be32 vendor_id;
+	__be32 id;
+	__be32 ver;
+} __packed;
+
+struct wmfw_adsp1_id_hdr {
+	struct wmfw_id_hdr fw;
+	__be32 zm;
+	__be32 dm;
+	__be32 n_algs;
+} __packed;
+
+struct wmfw_adsp2_id_hdr {
+	struct wmfw_id_hdr fw;
+	__be32 zm;
+	__be32 xm;
+	__be32 ym;
+	__be32 n_algs;
+} __packed;
+
+struct wmfw_halo_id_hdr {
+	struct wmfw_v3_id_hdr fw;
+	__be32 xm_base;
+	__be32 xm_size;
+	__be32 ym_base;
+	__be32 ym_size;
+	__be32 n_algs;
+} __packed;
+
+struct wmfw_alg_hdr {
+	__be32 id;
+	__be32 ver;
+} __packed;
+
+struct wmfw_adsp1_alg_hdr {
+	struct wmfw_alg_hdr alg;
+	__be32 zm;
+	__be32 dm;
+} __packed;
+
+struct wmfw_adsp2_alg_hdr {
+	struct wmfw_alg_hdr alg;
+	__be32 zm;
+	__be32 xm;
+	__be32 ym;
+} __packed;
+
+struct wmfw_halo_alg_hdr {
+	struct wmfw_alg_hdr alg;
+	__be32 xm_base;
+	__be32 xm_size;
+	__be32 ym_base;
+	__be32 ym_size;
+} __packed;
+
+struct wmfw_adsp_alg_data {
+	__le32 id;
+	u8 name[WMFW_MAX_ALG_NAME];
+	u8 descr[WMFW_MAX_ALG_DESCR_NAME];
+	__le32 ncoeff;
+	u8 data[];
+} __packed;
+
+struct wmfw_adsp_coeff_data {
+	struct {
+		__le16 offset;
+		__le16 type;
+		__le32 size;
+	} hdr;
+	u8 name[WMFW_MAX_COEFF_NAME];
+	u8 descr[WMFW_MAX_COEFF_DESCR_NAME];
+	__le16 ctl_type;
+	__le16 flags;
+	__le32 len;
+	u8 data[];
+} __packed;
+
+struct wmfw_coeff_hdr {
+	u8 magic[4];
+	__le32 len;
+	union {
+		__be32 rev;
+		__le32 ver;
+	};
+	union {
+		__be32 core;
+		__le32 core_ver;
+	};
+	u8 data[];
+} __packed;
+
+struct wmfw_coeff_item {
+	__le16 offset;
+	__le16 type;
+	__le32 id;
+	__le32 ver;
+	__le32 sr;
+	__le32 len;
+	u8 data[];
+} __packed;
+
+#define WMFW_ADSP1 1
+#define WMFW_ADSP2 2
+#define WMFW_HALO 4
+
+#define WMFW_ABSOLUTE         0xf0
+#define WMFW_ALGORITHM_DATA   0xf2
+#define WMFW_METADATA         0xfc
+#define WMFW_NAME_TEXT        0xfe
+#define WMFW_INFO_TEXT        0xff
+
+#define WMFW_ADSP1_PM 2
+#define WMFW_ADSP1_DM 3
+#define WMFW_ADSP1_ZM 4
+
+#define WMFW_ADSP2_PM 2
+#define WMFW_ADSP2_ZM 4
+#define WMFW_ADSP2_XM 5
+#define WMFW_ADSP2_YM 6
+
+#define WMFW_HALO_PM_PACKED 0x10
+#define WMFW_HALO_XM_PACKED 0x11
+#define WMFW_HALO_YM_PACKED 0x12
+
+#endif
diff -ruN a/sound/pci/hda/Kconfig b/sound/pci/hda/Kconfig
--- a/sound/pci/hda/Kconfig	2023-02-15 21:19:59.000000000 +0100
+++ b/sound/pci/hda/Kconfig	2022-07-08 01:12:12.000000000 +0200
@@ -91,45 +91,6 @@
 	  start up.  The "patch" file can be specified via patch module
 	  option, such as patch=hda-init.
 
-config SND_HDA_SCODEC_CS35L41
-	tristate
-	select SND_HDA_GENERIC
-	select REGMAP_IRQ
-
-config SND_HDA_CS_DSP_CONTROLS
-	tristate
-	select CS_DSP
-
-config SND_HDA_SCODEC_CS35L41_I2C
-	tristate "Build CS35L41 HD-audio side codec support for I2C Bus"
-	depends on I2C
-	depends on ACPI
-	depends on SND_SOC
-	select SND_SOC_CS35L41_LIB
-	select SND_HDA_SCODEC_CS35L41
-	select SND_HDA_CS_DSP_CONTROLS
-	help
-	  Say Y or M here to include CS35L41 I2C HD-audio side codec support
-	  in snd-hda-intel driver, such as ALC287.
-
-comment "Set to Y if you want auto-loading the side codec driver"
-	depends on SND_HDA=y && SND_HDA_SCODEC_CS35L41_I2C=m
-
-config SND_HDA_SCODEC_CS35L41_SPI
-	tristate "Build CS35L41 HD-audio codec support for SPI Bus"
-	depends on SPI_MASTER
-	depends on ACPI
-	depends on SND_SOC
-	select SND_SOC_CS35L41_LIB
-	select SND_HDA_SCODEC_CS35L41
-	select SND_HDA_CS_DSP_CONTROLS
-	help
-	  Say Y or M here to include CS35L41 SPI HD-audio side codec support
-	  in snd-hda-intel driver, such as ALC287.
-
-comment "Set to Y if you want auto-loading the side codec driver"
-	depends on SND_HDA=y && SND_HDA_SCODEC_CS35L41_SPI=m
-
 config SND_HDA_CODEC_REALTEK
 	tristate "Build Realtek HD-audio codec support"
 	select SND_HDA_GENERIC
diff -ruN a/sound/pci/hda/Makefile b/sound/pci/hda/Makefile
--- a/sound/pci/hda/Makefile	2023-02-15 21:19:59.000000000 +0100
+++ b/sound/pci/hda/Makefile	2022-07-08 01:12:12.000000000 +0200
@@ -20,12 +20,6 @@
 snd-hda-codec-via-objs :=	patch_via.o
 snd-hda-codec-hdmi-objs :=	patch_hdmi.o hda_eld.o
 
-# side codecs
-snd-hda-scodec-cs35l41-objs :=		cs35l41_hda.o
-snd-hda-scodec-cs35l41-i2c-objs :=	cs35l41_hda_i2c.o
-snd-hda-scodec-cs35l41-spi-objs :=	cs35l41_hda_spi.o
-snd-hda-cs-dsp-ctls-objs :=		hda_cs_dsp_ctl.o
-
 # common driver
 obj-$(CONFIG_SND_HDA) := snd-hda-codec.o
 
@@ -44,12 +37,6 @@
 obj-$(CONFIG_SND_HDA_CODEC_VIA) += snd-hda-codec-via.o
 obj-$(CONFIG_SND_HDA_CODEC_HDMI) += snd-hda-codec-hdmi.o
 
-# side codecs
-obj-$(CONFIG_SND_HDA_SCODEC_CS35L41) += snd-hda-scodec-cs35l41.o
-obj-$(CONFIG_SND_HDA_SCODEC_CS35L41_I2C) += snd-hda-scodec-cs35l41-i2c.o
-obj-$(CONFIG_SND_HDA_SCODEC_CS35L41_SPI) += snd-hda-scodec-cs35l41-spi.o
-obj-$(CONFIG_SND_HDA_CS_DSP_CONTROLS) += snd-hda-cs-dsp-ctls.o
-
 # this must be the last entry after codec drivers;
 # otherwise the codec patches won't be hooked before the PCI probe
 # when built in kernel
--- a/include/sound/cs35l41.h	2023-02-15 21:19:52.000000000 +0100
+++ b/include/sound/cs35l41.h	2022-07-08 01:12:12.000000000 +0200
@@ -1,896 +1,136 @@
-/* SPDX-License-Identifier: GPL-2.0
- *
+/* SPDX-License-Identifier: GPL-2.0 */
+
+/*
  * linux/sound/cs35l41.h -- Platform data for CS35L41
  *
- * Copyright (c) 2017-2021 Cirrus Logic Inc.
+ * Copyright (c) 2017-2020 Cirrus Logic Inc.
  *
- * Author: David Rhodes	<david.rhodes@cirrus.com>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
  */
 
 #ifndef __CS35L41_H
 #define __CS35L41_H
 
-#include <linux/regmap.h>
-#include <linux/firmware/cirrus/cs_dsp.h>
-
-#define CS35L41_FIRSTREG		0x00000000
-#define CS35L41_LASTREG			0x03804FE8
-#define CS35L41_DEVID			0x00000000
-#define CS35L41_REVID			0x00000004
-#define CS35L41_FABID			0x00000008
-#define CS35L41_RELID			0x0000000C
-#define CS35L41_OTPID			0x00000010
-#define CS35L41_SFT_RESET		0x00000020
-#define CS35L41_TEST_KEY_CTL		0x00000040
-#define CS35L41_USER_KEY_CTL		0x00000044
-#define CS35L41_OTP_MEM0		0x00000400
-#define CS35L41_OTP_MEM31		0x0000047C
-#define CS35L41_OTP_CTRL0		0x00000500
-#define CS35L41_OTP_CTRL1		0x00000504
-#define CS35L41_OTP_CTRL3		0x00000508
-#define CS35L41_OTP_CTRL4		0x0000050C
-#define CS35L41_OTP_CTRL5		0x00000510
-#define CS35L41_OTP_CTRL6		0x00000514
-#define CS35L41_OTP_CTRL7		0x00000518
-#define CS35L41_OTP_CTRL8		0x0000051C
-#define CS35L41_PWR_CTRL1		0x00002014
-#define CS35L41_PWR_CTRL2		0x00002018
-#define CS35L41_PWR_CTRL3		0x0000201C
-#define CS35L41_CTRL_OVRRIDE		0x00002020
-#define CS35L41_AMP_OUT_MUTE		0x00002024
-#define CS35L41_PROTECT_REL_ERR_IGN	0x00002034
-#define CS35L41_GPIO_PAD_CONTROL	0x0000242C
-#define CS35L41_JTAG_CONTROL		0x00002438
-#define CS35L41_PWRMGT_CTL		0x00002900
-#define CS35L41_WAKESRC_CTL		0x00002904
-#define CS35L41_PWRMGT_STS		0x00002908
-#define CS35L41_PLL_CLK_CTRL		0x00002C04
-#define CS35L41_DSP_CLK_CTRL		0x00002C08
-#define CS35L41_GLOBAL_CLK_CTRL		0x00002C0C
-#define CS35L41_DATA_FS_SEL		0x00002C10
-#define CS35L41_TST_FS_MON0		0x00002D10
-#define CS35L41_MDSYNC_EN		0x00003400
-#define CS35L41_MDSYNC_TX_ID		0x00003408
-#define CS35L41_MDSYNC_PWR_CTRL		0x0000340C
-#define CS35L41_MDSYNC_DATA_TX		0x00003410
-#define CS35L41_MDSYNC_TX_STATUS	0x00003414
-#define CS35L41_MDSYNC_DATA_RX		0x0000341C
-#define CS35L41_MDSYNC_RX_STATUS	0x00003420
-#define CS35L41_MDSYNC_ERR_STATUS	0x00003424
-#define CS35L41_MDSYNC_SYNC_PTE2	0x00003528
-#define CS35L41_MDSYNC_SYNC_PTE3	0x0000352C
-#define CS35L41_MDSYNC_SYNC_MSM_STATUS	0x0000353C
-#define CS35L41_BSTCVRT_VCTRL1		0x00003800
-#define CS35L41_BSTCVRT_VCTRL2		0x00003804
-#define CS35L41_BSTCVRT_PEAK_CUR	0x00003808
-#define CS35L41_BSTCVRT_SFT_RAMP	0x0000380C
-#define CS35L41_BSTCVRT_COEFF		0x00003810
-#define CS35L41_BSTCVRT_SLOPE_LBST	0x00003814
-#define CS35L41_BSTCVRT_SW_FREQ		0x00003818
-#define CS35L41_BSTCVRT_DCM_CTRL	0x0000381C
-#define CS35L41_BSTCVRT_DCM_MODE_FORCE	0x00003820
-#define CS35L41_BSTCVRT_OVERVOLT_CTRL	0x00003830
-#define CS35L41_VI_VOL_POL		0x00004000
-#define CS35L41_VIMON_SPKMON_RESYNC	0x00004100
-#define CS35L41_DTEMP_WARN_THLD		0x00004220
-#define CS35L41_DTEMP_CFG		0x00004224
-#define CS35L41_DTEMP_EN		0x00004308
-#define CS35L41_VPVBST_FS_SEL		0x00004400
-#define CS35L41_SP_ENABLES		0x00004800
-#define CS35L41_SP_RATE_CTRL		0x00004804
-#define CS35L41_SP_FORMAT		0x00004808
-#define CS35L41_SP_HIZ_CTRL		0x0000480C
-#define CS35L41_SP_FRAME_TX_SLOT	0x00004810
-#define CS35L41_SP_FRAME_RX_SLOT	0x00004820
-#define CS35L41_SP_TX_WL		0x00004830
-#define CS35L41_SP_RX_WL		0x00004840
-#define CS35L41_ASP_CONTROL4		0x00004854
-#define CS35L41_DAC_PCM1_SRC		0x00004C00
-#define CS35L41_ASP_TX1_SRC		0x00004C20
-#define CS35L41_ASP_TX2_SRC		0x00004C24
-#define CS35L41_ASP_TX3_SRC		0x00004C28
-#define CS35L41_ASP_TX4_SRC		0x00004C2C
-#define CS35L41_DSP1_RX1_SRC		0x00004C40
-#define CS35L41_DSP1_RX2_SRC		0x00004C44
-#define CS35L41_DSP1_RX3_SRC		0x00004C48
-#define CS35L41_DSP1_RX4_SRC		0x00004C4C
-#define CS35L41_DSP1_RX5_SRC		0x00004C50
-#define CS35L41_DSP1_RX6_SRC		0x00004C54
-#define CS35L41_DSP1_RX7_SRC		0x00004C58
-#define CS35L41_DSP1_RX8_SRC		0x00004C5C
-#define CS35L41_NGATE1_SRC		0x00004C60
-#define CS35L41_NGATE2_SRC		0x00004C64
-#define CS35L41_AMP_DIG_VOL_CTRL	0x00006000
-#define CS35L41_VPBR_CFG		0x00006404
-#define CS35L41_VBBR_CFG		0x00006408
-#define CS35L41_VPBR_STATUS		0x0000640C
-#define CS35L41_VBBR_STATUS		0x00006410
-#define CS35L41_OVERTEMP_CFG		0x00006414
-#define CS35L41_AMP_ERR_VOL		0x00006418
-#define CS35L41_VOL_STATUS_TO_DSP	0x00006450
-#define CS35L41_CLASSH_CFG		0x00006800
-#define CS35L41_WKFET_CFG		0x00006804
-#define CS35L41_NG_CFG			0x00006808
-#define CS35L41_AMP_GAIN_CTRL		0x00006C04
-#define CS35L41_DAC_MSM_CFG		0x00007400
-#define CS35L41_IRQ1_CFG		0x00010000
-#define CS35L41_IRQ1_STATUS		0x00010004
-#define CS35L41_IRQ1_STATUS1		0x00010010
-#define CS35L41_IRQ1_STATUS2		0x00010014
-#define CS35L41_IRQ1_STATUS3		0x00010018
-#define CS35L41_IRQ1_STATUS4		0x0001001C
-#define CS35L41_IRQ1_RAW_STATUS1	0x00010090
-#define CS35L41_IRQ1_RAW_STATUS2	0x00010094
-#define CS35L41_IRQ1_RAW_STATUS3	0x00010098
-#define CS35L41_IRQ1_RAW_STATUS4	0x0001009C
-#define CS35L41_IRQ1_MASK1		0x00010110
-#define CS35L41_IRQ1_MASK2		0x00010114
-#define CS35L41_IRQ1_MASK3		0x00010118
-#define CS35L41_IRQ1_MASK4		0x0001011C
-#define CS35L41_IRQ1_FRC1		0x00010190
-#define CS35L41_IRQ1_FRC2		0x00010194
-#define CS35L41_IRQ1_FRC3		0x00010198
-#define CS35L41_IRQ1_FRC4		0x0001019C
-#define CS35L41_IRQ1_EDGE1		0x00010210
-#define CS35L41_IRQ1_EDGE4		0x0001021C
-#define CS35L41_IRQ1_POL1		0x00010290
-#define CS35L41_IRQ1_POL2		0x00010294
-#define CS35L41_IRQ1_POL3		0x00010298
-#define CS35L41_IRQ1_POL4		0x0001029C
-#define CS35L41_IRQ1_DB3		0x00010318
-#define CS35L41_IRQ2_CFG		0x00010800
-#define CS35L41_IRQ2_STATUS		0x00010804
-#define CS35L41_IRQ2_STATUS1		0x00010810
-#define CS35L41_IRQ2_STATUS2		0x00010814
-#define CS35L41_IRQ2_STATUS3		0x00010818
-#define CS35L41_IRQ2_STATUS4		0x0001081C
-#define CS35L41_IRQ2_RAW_STATUS1	0x00010890
-#define CS35L41_IRQ2_RAW_STATUS2	0x00010894
-#define CS35L41_IRQ2_RAW_STATUS3	0x00010898
-#define CS35L41_IRQ2_RAW_STATUS4	0x0001089C
-#define CS35L41_IRQ2_MASK1		0x00010910
-#define CS35L41_IRQ2_MASK2		0x00010914
-#define CS35L41_IRQ2_MASK3		0x00010918
-#define CS35L41_IRQ2_MASK4		0x0001091C
-#define CS35L41_IRQ2_FRC1		0x00010990
-#define CS35L41_IRQ2_FRC2		0x00010994
-#define CS35L41_IRQ2_FRC3		0x00010998
-#define CS35L41_IRQ2_FRC4		0x0001099C
-#define CS35L41_IRQ2_EDGE1		0x00010A10
-#define CS35L41_IRQ2_EDGE4		0x00010A1C
-#define CS35L41_IRQ2_POL1		0x00010A90
-#define CS35L41_IRQ2_POL2		0x00010A94
-#define CS35L41_IRQ2_POL3		0x00010A98
-#define CS35L41_IRQ2_POL4		0x00010A9C
-#define CS35L41_IRQ2_DB3		0x00010B18
-#define CS35L41_GPIO_STATUS1		0x00011000
-#define CS35L41_GPIO1_CTRL1		0x00011008
-#define CS35L41_GPIO2_CTRL1		0x0001100C
-#define CS35L41_MIXER_NGATE_CFG		0x00012000
-#define CS35L41_MIXER_NGATE_CH1_CFG	0x00012004
-#define CS35L41_MIXER_NGATE_CH2_CFG	0x00012008
-#define CS35L41_DSP_MBOX_1		0x00013000
-#define CS35L41_DSP_MBOX_2		0x00013004
-#define CS35L41_DSP_MBOX_3		0x00013008
-#define CS35L41_DSP_MBOX_4		0x0001300C
-#define CS35L41_DSP_MBOX_5		0x00013010
-#define CS35L41_DSP_MBOX_6		0x00013014
-#define CS35L41_DSP_MBOX_7		0x00013018
-#define CS35L41_DSP_MBOX_8		0x0001301C
-#define CS35L41_DSP_VIRT1_MBOX_1	0x00013020
-#define CS35L41_DSP_VIRT1_MBOX_2	0x00013024
-#define CS35L41_DSP_VIRT1_MBOX_3	0x00013028
-#define CS35L41_DSP_VIRT1_MBOX_4	0x0001302C
-#define CS35L41_DSP_VIRT1_MBOX_5	0x00013030
-#define CS35L41_DSP_VIRT1_MBOX_6	0x00013034
-#define CS35L41_DSP_VIRT1_MBOX_7	0x00013038
-#define CS35L41_DSP_VIRT1_MBOX_8	0x0001303C
-#define CS35L41_DSP_VIRT2_MBOX_1	0x00013040
-#define CS35L41_DSP_VIRT2_MBOX_2	0x00013044
-#define CS35L41_DSP_VIRT2_MBOX_3	0x00013048
-#define CS35L41_DSP_VIRT2_MBOX_4	0x0001304C
-#define CS35L41_DSP_VIRT2_MBOX_5	0x00013050
-#define CS35L41_DSP_VIRT2_MBOX_6	0x00013054
-#define CS35L41_DSP_VIRT2_MBOX_7	0x00013058
-#define CS35L41_DSP_VIRT2_MBOX_8	0x0001305C
-#define CS35L41_CLOCK_DETECT_1		0x00014000
-#define CS35L41_TIMER1_CONTROL		0x00015000
-#define CS35L41_TIMER1_COUNT_PRESET	0x00015004
-#define CS35L41_TIMER1_START_STOP	0x0001500C
-#define CS35L41_TIMER1_STATUS		0x00015010
-#define CS35L41_TIMER1_COUNT_READBACK	0x00015014
-#define CS35L41_TIMER1_DSP_CLK_CFG	0x00015018
-#define CS35L41_TIMER1_DSP_CLK_STATUS	0x0001501C
-#define CS35L41_TIMER2_CONTROL		0x00015100
-#define CS35L41_TIMER2_COUNT_PRESET	0x00015104
-#define CS35L41_TIMER2_START_STOP	0x0001510C
-#define CS35L41_TIMER2_STATUS		0x00015110
-#define CS35L41_TIMER2_COUNT_READBACK	0x00015114
-#define CS35L41_TIMER2_DSP_CLK_CFG	0x00015118
-#define CS35L41_TIMER2_DSP_CLK_STATUS	0x0001511C
-#define CS35L41_DFT_JTAG_CONTROL	0x00016000
-#define CS35L41_DIE_STS1		0x00017040
-#define CS35L41_DIE_STS2		0x00017044
-#define CS35L41_TEMP_CAL1		0x00017048
-#define CS35L41_TEMP_CAL2		0x0001704C
-#define CS35L41_DSP1_XMEM_PACK_0	0x02000000
-#define CS35L41_DSP1_XMEM_PACK_3068	0x02002FF0
-#define CS35L41_DSP1_XMEM_UNPACK32_0	0x02400000
-#define CS35L41_DSP1_XMEM_UNPACK32_2046	0x02401FF8
-#define CS35L41_DSP1_TIMESTAMP_COUNT	0x025C0800
-#define CS35L41_DSP1_SYS_ID		0x025E0000
-#define CS35L41_DSP1_SYS_VERSION	0x025E0004
-#define CS35L41_DSP1_SYS_CORE_ID	0x025E0008
-#define CS35L41_DSP1_SYS_AHB_ADDR	0x025E000C
-#define CS35L41_DSP1_SYS_XSRAM_SIZE	0x025E0010
-#define CS35L41_DSP1_SYS_YSRAM_SIZE	0x025E0018
-#define CS35L41_DSP1_SYS_PSRAM_SIZE	0x025E0020
-#define CS35L41_DSP1_SYS_PM_BOOT_SIZE	0x025E0028
-#define CS35L41_DSP1_SYS_FEATURES	0x025E002C
-#define CS35L41_DSP1_SYS_FIR_FILTERS	0x025E0030
-#define CS35L41_DSP1_SYS_LMS_FILTERS	0x025E0034
-#define CS35L41_DSP1_SYS_XM_BANK_SIZE	0x025E0038
-#define CS35L41_DSP1_SYS_YM_BANK_SIZE	0x025E003C
-#define CS35L41_DSP1_SYS_PM_BANK_SIZE	0x025E0040
-#define CS35L41_DSP1_AHBM_WIN0_CTRL0	0x025E2000
-#define CS35L41_DSP1_AHBM_WIN0_CTRL1	0x025E2004
-#define CS35L41_DSP1_AHBM_WIN1_CTRL0	0x025E2008
-#define CS35L41_DSP1_AHBM_WIN1_CTRL1	0x025E200C
-#define CS35L41_DSP1_AHBM_WIN2_CTRL0	0x025E2010
-#define CS35L41_DSP1_AHBM_WIN2_CTRL1	0x025E2014
-#define CS35L41_DSP1_AHBM_WIN3_CTRL0	0x025E2018
-#define CS35L41_DSP1_AHBM_WIN3_CTRL1	0x025E201C
-#define CS35L41_DSP1_AHBM_WIN4_CTRL0	0x025E2020
-#define CS35L41_DSP1_AHBM_WIN4_CTRL1	0x025E2024
-#define CS35L41_DSP1_AHBM_WIN5_CTRL0	0x025E2028
-#define CS35L41_DSP1_AHBM_WIN5_CTRL1	0x025E202C
-#define CS35L41_DSP1_AHBM_WIN6_CTRL0	0x025E2030
-#define CS35L41_DSP1_AHBM_WIN6_CTRL1	0x025E2034
-#define CS35L41_DSP1_AHBM_WIN7_CTRL0	0x025E2038
-#define CS35L41_DSP1_AHBM_WIN7_CTRL1	0x025E203C
-#define CS35L41_DSP1_AHBM_WIN_DBG_CTRL0	0x025E2040
-#define CS35L41_DSP1_AHBM_WIN_DBG_CTRL1	0x025E2044
-#define CS35L41_DSP1_XMEM_UNPACK24_0	0x02800000
-#define CS35L41_DSP1_XMEM_UNPACK24_4093	0x02803FF4
-#define CS35L41_DSP1_CTRL_BASE		0x02B80000
-#define CS35L41_DSP1_CORE_SOFT_RESET	0x02B80010
-#define CS35L41_DSP1_DEBUG		0x02B80040
-#define CS35L41_DSP1_TIMER_CTRL		0x02B80048
-#define CS35L41_DSP1_STREAM_ARB_CTRL	0x02B80050
-#define CS35L41_DSP1_RX1_RATE		0x02B80080
-#define CS35L41_DSP1_RX2_RATE		0x02B80088
-#define CS35L41_DSP1_RX3_RATE		0x02B80090
-#define CS35L41_DSP1_RX4_RATE		0x02B80098
-#define CS35L41_DSP1_RX5_RATE		0x02B800A0
-#define CS35L41_DSP1_RX6_RATE		0x02B800A8
-#define CS35L41_DSP1_RX7_RATE		0x02B800B0
-#define CS35L41_DSP1_RX8_RATE		0x02B800B8
-#define CS35L41_DSP1_TX1_RATE		0x02B80280
-#define CS35L41_DSP1_TX2_RATE		0x02B80288
-#define CS35L41_DSP1_TX3_RATE		0x02B80290
-#define CS35L41_DSP1_TX4_RATE		0x02B80298
-#define CS35L41_DSP1_TX5_RATE		0x02B802A0
-#define CS35L41_DSP1_TX6_RATE		0x02B802A8
-#define CS35L41_DSP1_TX7_RATE		0x02B802B0
-#define CS35L41_DSP1_TX8_RATE		0x02B802B8
-#define CS35L41_DSP1_NMI_CTRL1		0x02B80480
-#define CS35L41_DSP1_NMI_CTRL2		0x02B80488
-#define CS35L41_DSP1_NMI_CTRL3		0x02B80490
-#define CS35L41_DSP1_NMI_CTRL4		0x02B80498
-#define CS35L41_DSP1_NMI_CTRL5		0x02B804A0
-#define CS35L41_DSP1_NMI_CTRL6		0x02B804A8
-#define CS35L41_DSP1_NMI_CTRL7		0x02B804B0
-#define CS35L41_DSP1_NMI_CTRL8		0x02B804B8
-#define CS35L41_DSP1_RESUME_CTRL	0x02B80500
-#define CS35L41_DSP1_IRQ1_CTRL		0x02B80508
-#define CS35L41_DSP1_IRQ2_CTRL		0x02B80510
-#define CS35L41_DSP1_IRQ3_CTRL		0x02B80518
-#define CS35L41_DSP1_IRQ4_CTRL		0x02B80520
-#define CS35L41_DSP1_IRQ5_CTRL		0x02B80528
-#define CS35L41_DSP1_IRQ6_CTRL		0x02B80530
-#define CS35L41_DSP1_IRQ7_CTRL		0x02B80538
-#define CS35L41_DSP1_IRQ8_CTRL		0x02B80540
-#define CS35L41_DSP1_IRQ9_CTRL		0x02B80548
-#define CS35L41_DSP1_IRQ10_CTRL		0x02B80550
-#define CS35L41_DSP1_IRQ11_CTRL		0x02B80558
-#define CS35L41_DSP1_IRQ12_CTRL		0x02B80560
-#define CS35L41_DSP1_IRQ13_CTRL		0x02B80568
-#define CS35L41_DSP1_IRQ14_CTRL		0x02B80570
-#define CS35L41_DSP1_IRQ15_CTRL		0x02B80578
-#define CS35L41_DSP1_IRQ16_CTRL		0x02B80580
-#define CS35L41_DSP1_IRQ17_CTRL		0x02B80588
-#define CS35L41_DSP1_IRQ18_CTRL		0x02B80590
-#define CS35L41_DSP1_IRQ19_CTRL		0x02B80598
-#define CS35L41_DSP1_IRQ20_CTRL		0x02B805A0
-#define CS35L41_DSP1_IRQ21_CTRL		0x02B805A8
-#define CS35L41_DSP1_IRQ22_CTRL		0x02B805B0
-#define CS35L41_DSP1_IRQ23_CTRL		0x02B805B8
-#define CS35L41_DSP1_SCRATCH1		0x02B805C0
-#define CS35L41_DSP1_SCRATCH2		0x02B805C8
-#define CS35L41_DSP1_SCRATCH3		0x02B805D0
-#define CS35L41_DSP1_SCRATCH4		0x02B805D8
-#define CS35L41_DSP1_CCM_CORE_CTRL	0x02BC1000
-#define CS35L41_DSP1_CCM_CLK_OVERRIDE	0x02BC1008
-#define CS35L41_DSP1_XM_MSTR_EN		0x02BC2000
-#define CS35L41_DSP1_XM_CORE_PRI	0x02BC2008
-#define CS35L41_DSP1_XM_AHB_PACK_PL_PRI	0x02BC2010
-#define CS35L41_DSP1_XM_AHB_UP_PL_PRI	0x02BC2018
-#define CS35L41_DSP1_XM_ACCEL_PL0_PRI	0x02BC2020
-#define CS35L41_DSP1_XM_NPL0_PRI	0x02BC2078
-#define CS35L41_DSP1_YM_MSTR_EN		0x02BC20C0
-#define CS35L41_DSP1_YM_CORE_PRI	0x02BC20C8
-#define CS35L41_DSP1_YM_AHB_PACK_PL_PRI	0x02BC20D0
-#define CS35L41_DSP1_YM_AHB_UP_PL_PRI	0x02BC20D8
-#define CS35L41_DSP1_YM_ACCEL_PL0_PRI	0x02BC20E0
-#define CS35L41_DSP1_YM_NPL0_PRI	0x02BC2138
-#define CS35L41_DSP1_PM_MSTR_EN		0x02BC2180
-#define CS35L41_DSP1_PM_PATCH0_ADDR	0x02BC2188
-#define CS35L41_DSP1_PM_PATCH0_EN	0x02BC218C
-#define CS35L41_DSP1_PM_PATCH0_DATA_LO	0x02BC2190
-#define CS35L41_DSP1_PM_PATCH0_DATA_HI	0x02BC2194
-#define CS35L41_DSP1_PM_PATCH1_ADDR	0x02BC2198
-#define CS35L41_DSP1_PM_PATCH1_EN	0x02BC219C
-#define CS35L41_DSP1_PM_PATCH1_DATA_LO	0x02BC21A0
-#define CS35L41_DSP1_PM_PATCH1_DATA_HI	0x02BC21A4
-#define CS35L41_DSP1_PM_PATCH2_ADDR	0x02BC21A8
-#define CS35L41_DSP1_PM_PATCH2_EN	0x02BC21AC
-#define CS35L41_DSP1_PM_PATCH2_DATA_LO	0x02BC21B0
-#define CS35L41_DSP1_PM_PATCH2_DATA_HI	0x02BC21B4
-#define CS35L41_DSP1_PM_PATCH3_ADDR	0x02BC21B8
-#define CS35L41_DSP1_PM_PATCH3_EN	0x02BC21BC
-#define CS35L41_DSP1_PM_PATCH3_DATA_LO	0x02BC21C0
-#define CS35L41_DSP1_PM_PATCH3_DATA_HI	0x02BC21C4
-#define CS35L41_DSP1_PM_PATCH4_ADDR	0x02BC21C8
-#define CS35L41_DSP1_PM_PATCH4_EN	0x02BC21CC
-#define CS35L41_DSP1_PM_PATCH4_DATA_LO	0x02BC21D0
-#define CS35L41_DSP1_PM_PATCH4_DATA_HI	0x02BC21D4
-#define CS35L41_DSP1_PM_PATCH5_ADDR	0x02BC21D8
-#define CS35L41_DSP1_PM_PATCH5_EN	0x02BC21DC
-#define CS35L41_DSP1_PM_PATCH5_DATA_LO	0x02BC21E0
-#define CS35L41_DSP1_PM_PATCH5_DATA_HI	0x02BC21E4
-#define CS35L41_DSP1_PM_PATCH6_ADDR	0x02BC21E8
-#define CS35L41_DSP1_PM_PATCH6_EN	0x02BC21EC
-#define CS35L41_DSP1_PM_PATCH6_DATA_LO	0x02BC21F0
-#define CS35L41_DSP1_PM_PATCH6_DATA_HI	0x02BC21F4
-#define CS35L41_DSP1_PM_PATCH7_ADDR	0x02BC21F8
-#define CS35L41_DSP1_PM_PATCH7_EN	0x02BC21FC
-#define CS35L41_DSP1_PM_PATCH7_DATA_LO	0x02BC2200
-#define CS35L41_DSP1_PM_PATCH7_DATA_HI	0x02BC2204
-#define CS35L41_DSP1_MPU_XM_ACCESS0	0x02BC3000
-#define CS35L41_DSP1_MPU_YM_ACCESS0	0x02BC3004
-#define CS35L41_DSP1_MPU_WNDW_ACCESS0	0x02BC3008
-#define CS35L41_DSP1_MPU_XREG_ACCESS0	0x02BC300C
-#define CS35L41_DSP1_MPU_YREG_ACCESS0	0x02BC3014
-#define CS35L41_DSP1_MPU_XM_ACCESS1	0x02BC3018
-#define CS35L41_DSP1_MPU_YM_ACCESS1	0x02BC301C
-#define CS35L41_DSP1_MPU_WNDW_ACCESS1	0x02BC3020
-#define CS35L41_DSP1_MPU_XREG_ACCESS1	0x02BC3024
-#define CS35L41_DSP1_MPU_YREG_ACCESS1	0x02BC302C
-#define CS35L41_DSP1_MPU_XM_ACCESS2	0x02BC3030
-#define CS35L41_DSP1_MPU_YM_ACCESS2	0x02BC3034
-#define CS35L41_DSP1_MPU_WNDW_ACCESS2	0x02BC3038
-#define CS35L41_DSP1_MPU_XREG_ACCESS2	0x02BC303C
-#define CS35L41_DSP1_MPU_YREG_ACCESS2	0x02BC3044
-#define CS35L41_DSP1_MPU_XM_ACCESS3	0x02BC3048
-#define CS35L41_DSP1_MPU_YM_ACCESS3	0x02BC304C
-#define CS35L41_DSP1_MPU_WNDW_ACCESS3	0x02BC3050
-#define CS35L41_DSP1_MPU_XREG_ACCESS3	0x02BC3054
-#define CS35L41_DSP1_MPU_YREG_ACCESS3	0x02BC305C
-#define CS35L41_DSP1_MPU_XM_VIO_ADDR	0x02BC3100
-#define CS35L41_DSP1_MPU_XM_VIO_STATUS	0x02BC3104
-#define CS35L41_DSP1_MPU_YM_VIO_ADDR	0x02BC3108
-#define CS35L41_DSP1_MPU_YM_VIO_STATUS	0x02BC310C
-#define CS35L41_DSP1_MPU_PM_VIO_ADDR	0x02BC3110
-#define CS35L41_DSP1_MPU_PM_VIO_STATUS	0x02BC3114
-#define CS35L41_DSP1_MPU_LOCK_CONFIG	0x02BC3140
-#define CS35L41_DSP1_MPU_WDT_RST_CTRL	0x02BC3180
-#define CS35L41_DSP1_STRMARB_MSTR0_CFG0	0x02BC5000
-#define CS35L41_DSP1_STRMARB_MSTR0_CFG1	0x02BC5004
-#define CS35L41_DSP1_STRMARB_MSTR0_CFG2	0x02BC5008
-#define CS35L41_DSP1_STRMARB_MSTR1_CFG0	0x02BC5010
-#define CS35L41_DSP1_STRMARB_MSTR1_CFG1	0x02BC5014
-#define CS35L41_DSP1_STRMARB_MSTR1_CFG2	0x02BC5018
-#define CS35L41_DSP1_STRMARB_MSTR2_CFG0	0x02BC5020
-#define CS35L41_DSP1_STRMARB_MSTR2_CFG1	0x02BC5024
-#define CS35L41_DSP1_STRMARB_MSTR2_CFG2	0x02BC5028
-#define CS35L41_DSP1_STRMARB_MSTR3_CFG0	0x02BC5030
-#define CS35L41_DSP1_STRMARB_MSTR3_CFG1	0x02BC5034
-#define CS35L41_DSP1_STRMARB_MSTR3_CFG2	0x02BC5038
-#define CS35L41_DSP1_STRMARB_MSTR4_CFG0	0x02BC5040
-#define CS35L41_DSP1_STRMARB_MSTR4_CFG1	0x02BC5044
-#define CS35L41_DSP1_STRMARB_MSTR4_CFG2	0x02BC5048
-#define CS35L41_DSP1_STRMARB_MSTR5_CFG0	0x02BC5050
-#define CS35L41_DSP1_STRMARB_MSTR5_CFG1	0x02BC5054
-#define CS35L41_DSP1_STRMARB_MSTR5_CFG2	0x02BC5058
-#define CS35L41_DSP1_STRMARB_MSTR6_CFG0	0x02BC5060
-#define CS35L41_DSP1_STRMARB_MSTR6_CFG1	0x02BC5064
-#define CS35L41_DSP1_STRMARB_MSTR6_CFG2	0x02BC5068
-#define CS35L41_DSP1_STRMARB_MSTR7_CFG0	0x02BC5070
-#define CS35L41_DSP1_STRMARB_MSTR7_CFG1	0x02BC5074
-#define CS35L41_DSP1_STRMARB_MSTR7_CFG2	0x02BC5078
-#define CS35L41_DSP1_STRMARB_TX0_CFG0	0x02BC5200
-#define CS35L41_DSP1_STRMARB_TX0_CFG1	0x02BC5204
-#define CS35L41_DSP1_STRMARB_TX1_CFG0	0x02BC5208
-#define CS35L41_DSP1_STRMARB_TX1_CFG1	0x02BC520C
-#define CS35L41_DSP1_STRMARB_TX2_CFG0	0x02BC5210
-#define CS35L41_DSP1_STRMARB_TX2_CFG1	0x02BC5214
-#define CS35L41_DSP1_STRMARB_TX3_CFG0	0x02BC5218
-#define CS35L41_DSP1_STRMARB_TX3_CFG1	0x02BC521C
-#define CS35L41_DSP1_STRMARB_TX4_CFG0	0x02BC5220
-#define CS35L41_DSP1_STRMARB_TX4_CFG1	0x02BC5224
-#define CS35L41_DSP1_STRMARB_TX5_CFG0	0x02BC5228
-#define CS35L41_DSP1_STRMARB_TX5_CFG1	0x02BC522C
-#define CS35L41_DSP1_STRMARB_TX6_CFG0	0x02BC5230
-#define CS35L41_DSP1_STRMARB_TX6_CFG1	0x02BC5234
-#define CS35L41_DSP1_STRMARB_TX7_CFG0	0x02BC5238
-#define CS35L41_DSP1_STRMARB_TX7_CFG1	0x02BC523C
-#define CS35L41_DSP1_STRMARB_RX0_CFG0	0x02BC5400
-#define CS35L41_DSP1_STRMARB_RX0_CFG1	0x02BC5404
-#define CS35L41_DSP1_STRMARB_RX1_CFG0	0x02BC5408
-#define CS35L41_DSP1_STRMARB_RX1_CFG1	0x02BC540C
-#define CS35L41_DSP1_STRMARB_RX2_CFG0	0x02BC5410
-#define CS35L41_DSP1_STRMARB_RX2_CFG1	0x02BC5414
-#define CS35L41_DSP1_STRMARB_RX3_CFG0	0x02BC5418
-#define CS35L41_DSP1_STRMARB_RX3_CFG1	0x02BC541C
-#define CS35L41_DSP1_STRMARB_RX4_CFG0	0x02BC5420
-#define CS35L41_DSP1_STRMARB_RX4_CFG1	0x02BC5424
-#define CS35L41_DSP1_STRMARB_RX5_CFG0	0x02BC5428
-#define CS35L41_DSP1_STRMARB_RX5_CFG1	0x02BC542C
-#define CS35L41_DSP1_STRMARB_RX6_CFG0	0x02BC5430
-#define CS35L41_DSP1_STRMARB_RX6_CFG1	0x02BC5434
-#define CS35L41_DSP1_STRMARB_RX7_CFG0	0x02BC5438
-#define CS35L41_DSP1_STRMARB_RX7_CFG1	0x02BC543C
-#define CS35L41_DSP1_STRMARB_IRQ0_CFG0	0x02BC5600
-#define CS35L41_DSP1_STRMARB_IRQ0_CFG1	0x02BC5604
-#define CS35L41_DSP1_STRMARB_IRQ0_CFG2	0x02BC5608
-#define CS35L41_DSP1_STRMARB_IRQ1_CFG0	0x02BC5610
-#define CS35L41_DSP1_STRMARB_IRQ1_CFG1	0x02BC5614
-#define CS35L41_DSP1_STRMARB_IRQ1_CFG2	0x02BC5618
-#define CS35L41_DSP1_STRMARB_IRQ2_CFG0	0x02BC5620
-#define CS35L41_DSP1_STRMARB_IRQ2_CFG1	0x02BC5624
-#define CS35L41_DSP1_STRMARB_IRQ2_CFG2	0x02BC5628
-#define CS35L41_DSP1_STRMARB_IRQ3_CFG0	0x02BC5630
-#define CS35L41_DSP1_STRMARB_IRQ3_CFG1	0x02BC5634
-#define CS35L41_DSP1_STRMARB_IRQ3_CFG2	0x02BC5638
-#define CS35L41_DSP1_STRMARB_IRQ4_CFG0	0x02BC5640
-#define CS35L41_DSP1_STRMARB_IRQ4_CFG1	0x02BC5644
-#define CS35L41_DSP1_STRMARB_IRQ4_CFG2	0x02BC5648
-#define CS35L41_DSP1_STRMARB_IRQ5_CFG0	0x02BC5650
-#define CS35L41_DSP1_STRMARB_IRQ5_CFG1	0x02BC5654
-#define CS35L41_DSP1_STRMARB_IRQ5_CFG2	0x02BC5658
-#define CS35L41_DSP1_STRMARB_IRQ6_CFG0	0x02BC5660
-#define CS35L41_DSP1_STRMARB_IRQ6_CFG1	0x02BC5664
-#define CS35L41_DSP1_STRMARB_IRQ6_CFG2	0x02BC5668
-#define CS35L41_DSP1_STRMARB_IRQ7_CFG0	0x02BC5670
-#define CS35L41_DSP1_STRMARB_IRQ7_CFG1	0x02BC5674
-#define CS35L41_DSP1_STRMARB_IRQ7_CFG2	0x02BC5678
-#define CS35L41_DSP1_STRMARB_RESYNC_MSK	0x02BC5A00
-#define CS35L41_DSP1_STRMARB_ERR_STATUS	0x02BC5A08
-#define CS35L41_DSP1_INTPCTL_RES_STATIC	0x02BC6000
-#define CS35L41_DSP1_INTPCTL_RES_DYN	0x02BC6004
-#define CS35L41_DSP1_INTPCTL_NMI_CTRL	0x02BC6008
-#define CS35L41_DSP1_INTPCTL_IRQ_INV	0x02BC6010
-#define CS35L41_DSP1_INTPCTL_IRQ_MODE	0x02BC6014
-#define CS35L41_DSP1_INTPCTL_IRQ_EN	0x02BC6018
-#define CS35L41_DSP1_INTPCTL_IRQ_MSK	0x02BC601C
-#define CS35L41_DSP1_INTPCTL_IRQ_FLUSH	0x02BC6020
-#define CS35L41_DSP1_INTPCTL_IRQ_MSKCLR	0x02BC6024
-#define CS35L41_DSP1_INTPCTL_IRQ_FRC	0x02BC6028
-#define CS35L41_DSP1_INTPCTL_IRQ_MSKSET	0x02BC602C
-#define CS35L41_DSP1_INTPCTL_IRQ_ERR	0x02BC6030
-#define CS35L41_DSP1_INTPCTL_IRQ_PEND	0x02BC6034
-#define CS35L41_DSP1_INTPCTL_IRQ_GEN	0x02BC6038
-#define CS35L41_DSP1_INTPCTL_TESTBITS	0x02BC6040
-#define CS35L41_DSP1_WDT_CONTROL	0x02BC7000
-#define CS35L41_DSP1_WDT_STATUS		0x02BC7008
-#define CS35L41_DSP1_YMEM_PACK_0	0x02C00000
-#define CS35L41_DSP1_YMEM_PACK_1532	0x02C017F0
-#define CS35L41_DSP1_YMEM_UNPACK32_0	0x03000000
-#define CS35L41_DSP1_YMEM_UNPACK32_1022	0x03000FF8
-#define CS35L41_DSP1_YMEM_UNPACK24_0	0x03400000
-#define CS35L41_DSP1_YMEM_UNPACK24_2045	0x03401FF4
-#define CS35L41_DSP1_PMEM_0		0x03800000
-#define CS35L41_DSP1_PMEM_5114		0x03804FE8
-
-/*test regs for emulation bringup*/
-#define CS35L41_PLL_OVR			0x00003018
-#define CS35L41_BST_TEST_DUTY		0x00003900
-#define CS35L41_DIGPWM_IOCTRL		0x0000706C
-
-/*registers populated by OTP*/
-#define CS35L41_OTP_TRIM_1		0x0000208c
-#define CS35L41_OTP_TRIM_2		0x00002090
-#define CS35L41_OTP_TRIM_3		0x00003010
-#define CS35L41_OTP_TRIM_4		0x0000300C
-#define CS35L41_OTP_TRIM_5		0x0000394C
-#define CS35L41_OTP_TRIM_6		0x00003950
-#define CS35L41_OTP_TRIM_7		0x00003954
-#define CS35L41_OTP_TRIM_8		0x00003958
-#define CS35L41_OTP_TRIM_9		0x0000395C
-#define CS35L41_OTP_TRIM_10		0x0000416C
-#define CS35L41_OTP_TRIM_11		0x00004160
-#define CS35L41_OTP_TRIM_12		0x00004170
-#define CS35L41_OTP_TRIM_13		0x00004360
-#define CS35L41_OTP_TRIM_14		0x00004448
-#define CS35L41_OTP_TRIM_15		0x0000444C
-#define CS35L41_OTP_TRIM_16		0x00006E30
-#define CS35L41_OTP_TRIM_17		0x00006E34
-#define CS35L41_OTP_TRIM_18		0x00006E38
-#define CS35L41_OTP_TRIM_19		0x00006E3C
-#define CS35L41_OTP_TRIM_20		0x00006E40
-#define CS35L41_OTP_TRIM_21		0x00006E44
-#define CS35L41_OTP_TRIM_22		0x00006E48
-#define CS35L41_OTP_TRIM_23		0x00006E4C
-#define CS35L41_OTP_TRIM_24		0x00006E50
-#define CS35L41_OTP_TRIM_25		0x00006E54
-#define CS35L41_OTP_TRIM_26		0x00006E58
-#define CS35L41_OTP_TRIM_27		0x00006E5C
-#define CS35L41_OTP_TRIM_28		0x00006E60
-#define CS35L41_OTP_TRIM_29		0x00006E64
-#define CS35L41_OTP_TRIM_30		0x00007418
-#define CS35L41_OTP_TRIM_31		0x0000741C
-#define CS35L41_OTP_TRIM_32		0x00007434
-#define CS35L41_OTP_TRIM_33		0x00007068
-#define CS35L41_OTP_TRIM_34		0x0000410C
-#define CS35L41_OTP_TRIM_35		0x0000400C
-#define CS35L41_OTP_TRIM_36		0x00002030
-
-#define CS35L41_MAX_CACHE_REG		36
-#define CS35L41_OTP_SIZE_WORDS		32
-
-#define CS35L41_NUM_SUPPLIES            2
-
-#define CS35L41_SCLK_MSTR_MASK		0x10
-#define CS35L41_SCLK_MSTR_SHIFT		4
-#define CS35L41_LRCLK_MSTR_MASK		0x01
-#define CS35L41_LRCLK_MSTR_SHIFT	0
-#define CS35L41_SCLK_INV_MASK		0x40
-#define CS35L41_SCLK_INV_SHIFT		6
-#define CS35L41_LRCLK_INV_MASK		0x04
-#define CS35L41_LRCLK_INV_SHIFT		2
-#define CS35L41_SCLK_FRC_MASK		0x20
-#define CS35L41_SCLK_FRC_SHIFT		5
-#define CS35L41_LRCLK_FRC_MASK		0x02
-#define CS35L41_LRCLK_FRC_SHIFT		1
-
-#define CS35L41_AMP_GAIN_PCM_MASK	0x3E0
-#define CS35L41_AMP_GAIN_ZC_MASK	0x0400
-#define CS35L41_AMP_GAIN_ZC_SHIFT	10
-
-#define CS35L41_BST_CTL_MASK		0xFF
-#define CS35L41_BST_CTL_SEL_MASK	0x03
-#define CS35L41_BST_CTL_SEL_REG		0x00
-#define CS35L41_BST_CTL_SEL_CLASSH	0x01
-#define CS35L41_BST_IPK_MASK		0x7F
-#define CS35L41_BST_IPK_SHIFT		0
-#define CS35L41_BST_LIM_MASK		0x4
-#define CS35L41_BST_LIM_SHIFT		2
-#define CS35L41_BST_K1_MASK		0x000000FF
-#define CS35L41_BST_K1_SHIFT		0
-#define CS35L41_BST_K2_MASK		0x0000FF00
-#define CS35L41_BST_K2_SHIFT		8
-#define CS35L41_BST_SLOPE_MASK		0x0000FF00
-#define CS35L41_BST_SLOPE_SHIFT		8
-#define CS35L41_BST_LBST_VAL_MASK	0x00000003
-#define CS35L41_BST_LBST_VAL_SHIFT	0
-
-#define CS35L41_TEMP_THLD_MASK		0x03
-#define CS35L41_VMON_IMON_VOL_MASK	0x07FF07FF
-#define CS35L41_PDM_MODE_MASK		0x01
-#define CS35L41_PDM_MODE_SHIFT		0
-
-#define CS35L41_CH_MEM_DEPTH_MASK	0x07
-#define CS35L41_CH_MEM_DEPTH_SHIFT	0
-#define CS35L41_CH_HDRM_CTL_MASK	0x007F0000
-#define CS35L41_CH_HDRM_CTL_SHIFT	16
-#define CS35L41_CH_REL_RATE_MASK	0xFF00
-#define CS35L41_CH_REL_RATE_SHIFT	8
-#define CS35L41_CH_WKFET_DLY_MASK	0x001C
-#define CS35L41_CH_WKFET_DLY_SHIFT	2
-#define CS35L41_CH_WKFET_THLD_MASK	0x0F00
-#define CS35L41_CH_WKFET_THLD_SHIFT	8
-
-#define CS35L41_HW_NG_SEL_MASK		0x3F00
-#define CS35L41_HW_NG_SEL_SHIFT		8
-#define CS35L41_HW_NG_DLY_MASK		0x0070
-#define CS35L41_HW_NG_DLY_SHIFT		4
-#define CS35L41_HW_NG_THLD_MASK		0x0007
-#define CS35L41_HW_NG_THLD_SHIFT	0
-
-#define CS35L41_DSP_NG_ENABLE_MASK	0x00010000
-#define CS35L41_DSP_NG_ENABLE_SHIFT	16
-#define CS35L41_DSP_NG_THLD_MASK	0x7
-#define CS35L41_DSP_NG_THLD_SHIFT	0
-#define CS35L41_DSP_NG_DELAY_MASK	0x0F00
-#define CS35L41_DSP_NG_DELAY_SHIFT	8
-
-#define CS35L41_ASP_FMT_MASK		0x0700
-#define CS35L41_ASP_FMT_SHIFT		8
-#define CS35L41_ASP_DOUT_HIZ_MASK	0x03
-#define CS35L41_ASP_DOUT_HIZ_SHIFT	0
-#define CS35L41_ASP_WIDTH_16		0x10
-#define CS35L41_ASP_WIDTH_24		0x18
-#define CS35L41_ASP_WIDTH_32		0x20
-#define CS35L41_ASP_WIDTH_TX_MASK	0xFF0000
-#define CS35L41_ASP_WIDTH_TX_SHIFT	16
-#define CS35L41_ASP_WIDTH_RX_MASK	0xFF000000
-#define CS35L41_ASP_WIDTH_RX_SHIFT	24
-#define CS35L41_ASP_RX1_SLOT_MASK	0x3F
-#define CS35L41_ASP_RX1_SLOT_SHIFT	0
-#define CS35L41_ASP_RX2_SLOT_MASK	0x3F00
-#define CS35L41_ASP_RX2_SLOT_SHIFT	8
-#define CS35L41_ASP_RX_WL_MASK		0x3F
-#define CS35L41_ASP_TX_WL_MASK		0x3F
-#define CS35L41_ASP_RX_WL_SHIFT		0
-#define CS35L41_ASP_TX_WL_SHIFT		0
-#define CS35L41_ASP_SOURCE_MASK		0x7F
-
-#define CS35L41_INPUT_SRC_ASPRX1	0x08
-#define CS35L41_INPUT_SRC_ASPRX2	0x09
-#define CS35L41_INPUT_SRC_VMON		0x18
-#define CS35L41_INPUT_SRC_IMON		0x19
-#define CS35L41_INPUT_SRC_CLASSH	0x21
-#define CS35L41_INPUT_SRC_VPMON		0x28
-#define CS35L41_INPUT_SRC_VBSTMON	0x29
-#define CS35L41_INPUT_SRC_TEMPMON	0x3A
-#define CS35L41_INPUT_SRC_RSVD		0x3B
-#define CS35L41_INPUT_DSP_TX1		0x32
-#define CS35L41_INPUT_DSP_TX2		0x33
-
-#define CS35L41_WR_PEND_STS_MASK	0x2
-
-#define CS35L41_PLL_CLK_SEL_MASK	0x07
-#define CS35L41_PLL_CLK_SEL_SHIFT	0
-#define CS35L41_PLL_CLK_EN_MASK		0x10
-#define CS35L41_PLL_CLK_EN_SHIFT	4
-#define CS35L41_PLL_OPENLOOP_MASK	0x0800
-#define CS35L41_PLL_OPENLOOP_SHIFT	11
-#define CS35L41_PLLSRC_SCLK		0
-#define CS35L41_PLLSRC_LRCLK		1
-#define CS35L41_PLLSRC_SELF		3
-#define CS35L41_PLLSRC_PDMCLK		4
-#define CS35L41_PLLSRC_MCLK		5
-#define CS35L41_PLLSRC_SWIRE		7
-#define CS35L41_REFCLK_FREQ_MASK	0x7E0
-#define CS35L41_REFCLK_FREQ_SHIFT	5
-
-#define CS35L41_GLOBAL_FS_MASK		0x1F
-#define CS35L41_GLOBAL_FS_SHIFT		0
-
-#define CS35L41_GLOBAL_EN_MASK		0x01
-#define CS35L41_GLOBAL_EN_SHIFT		0
-#define CS35L41_BST_EN_MASK		0x0030
-#define CS35L41_BST_EN_SHIFT		4
-#define CS35L41_BST_DIS_FET_OFF		0x00
-#define CS35L41_BST_EN_DEFAULT		0x2
-#define CS35L41_AMP_EN_SHIFT		0
-#define CS35L41_AMP_EN_MASK		1
-#define CS35L41_VMON_EN_MASK		0x1000
-#define CS35L41_VMON_EN_SHIFT		12
-#define CS35L41_IMON_EN_MASK		0x2000
-#define CS35L41_IMON_EN_SHIFT		13
-
-#define CS35L41_PDN_DONE_MASK		0x00800000
-#define CS35L41_PDN_DONE_SHIFT		23
-#define CS35L41_PUP_DONE_MASK		0x01000000
-#define CS35L41_PUP_DONE_SHIFT		24
-
-#define CS35L36_PUP_DONE_IRQ_UNMASK	0x5F
-#define CS35L36_PUP_DONE_IRQ_MASK	0xBF
-
-#define CS35L41_AMP_SHORT_ERR		0x80000000
-#define CS35L41_BST_SHORT_ERR		0x0100
-#define CS35L41_TEMP_WARN		0x8000
-#define CS35L41_TEMP_ERR		0x00020000
-#define CS35L41_BST_OVP_ERR		0x40
-#define CS35L41_BST_DCM_UVP_ERR		0x80
-#define CS35L41_OTP_BOOT_DONE		0x02
-#define CS35L41_PLL_UNLOCK		0x10
-#define CS35L41_OTP_BOOT_ERR		0x80000000
-
-#define CS35L41_AMP_SHORT_ERR_RLS	0x02
-#define CS35L41_BST_SHORT_ERR_RLS	0x04
-#define CS35L41_BST_OVP_ERR_RLS		0x08
-#define CS35L41_BST_UVP_ERR_RLS		0x10
-#define CS35L41_TEMP_WARN_ERR_RLS	0x20
-#define CS35L41_TEMP_ERR_RLS		0x40
-
-#define CS35L41_AMP_SHORT_ERR_RLS_SHIFT	1
-#define CS35L41_BST_SHORT_ERR_RLS_SHIFT	2
-#define CS35L41_BST_OVP_ERR_RLS_SHIFT	3
-#define CS35L41_BST_UVP_ERR_RLS_SHIFT	4
-#define CS35L41_TEMP_WARN_ERR_RLS_SHIFT	5
-#define CS35L41_TEMP_ERR_RLS_SHIFT	6
-
-#define CS35L41_INT1_MASK_DEFAULT	0x7FFCFE3F
-#define CS35L41_INT1_UNMASK_PUP		0xFEFFFFFF
-#define CS35L41_INT1_UNMASK_PDN		0xFF7FFFFF
-
-#define CS35L41_GPIO_DIR_MASK		0x80000000
-#define CS35L41_GPIO_DIR_SHIFT		31
-#define CS35L41_GPIO1_CTRL_MASK		0x00030000
-#define CS35L41_GPIO1_CTRL_SHIFT	16
-#define CS35L41_GPIO2_CTRL_MASK		0x07000000
-#define CS35L41_GPIO2_CTRL_SHIFT	24
-#define CS35L41_GPIO_LVL_SHIFT		15
-#define CS35L41_GPIO_LVL_MASK		BIT(CS35L41_GPIO_LVL_SHIFT)
-#define CS35L41_GPIO_POL_MASK		0x1000
-#define CS35L41_GPIO_POL_SHIFT		12
-
-#define CS35L41_AMP_INV_PCM_SHIFT	14
-#define CS35L41_AMP_INV_PCM_MASK	BIT(CS35L41_AMP_INV_PCM_SHIFT)
-#define CS35L41_AMP_PCM_VOL_SHIFT	3
-#define CS35L41_AMP_PCM_VOL_MASK	(0x7FF << 3)
-#define CS35L41_AMP_PCM_VOL_MUTE	0x4CF
-
-#define CS35L41_CHIP_ID			0x35a40
-#define CS35L41R_CHIP_ID		0x35b40
-#define CS35L41_MTLREVID_MASK		0x0F
-#define CS35L41_REVID_A0		0xA0
-#define CS35L41_REVID_B0		0xB0
-#define CS35L41_REVID_B2		0xB2
-
-#define CS35L41_HALO_CORE_RESET		0x00000200
-
-#define CS35L41_FS1_WINDOW_MASK		0x000007FF
-#define CS35L41_FS2_WINDOW_MASK		0x00FFF800
-#define CS35L41_FS2_WINDOW_SHIFT	12
-
-#define CS35L41_SPI_MAX_FREQ		4000000
-#define CS35L41_REGSTRIDE		4
-
-enum cs35l41_boost_type {
-	CS35L41_INT_BOOST,
-	CS35L41_EXT_BOOST,
-	CS35L41_EXT_BOOST_NO_VSPK_SWITCH,
-};
-
-enum cs35l41_clk_ids {
-	CS35L41_CLKID_SCLK = 0,
-	CS35L41_CLKID_LRCLK = 1,
-	CS35L41_CLKID_MCLK = 4,
-};
-
-enum cs35l41_gpio1_func {
-	CS35L41_GPIO1_HIZ,
-	CS35L41_GPIO1_GPIO,
-	CS35L41_GPIO1_MDSYNC,
-	CS35L41_GPIO1_MCLK,
-	CS35L41_GPIO1_PDM_CLK,
-	CS35L41_GPIO1_PDM_DATA,
-};
-
-enum cs35l41_gpio2_func {
-	CS35L41_GPIO2_HIZ,
-	CS35L41_GPIO2_GPIO,
-	CS35L41_GPIO2_INT_OPEN_DRAIN,
-	CS35L41_GPIO2_MCLK,
-	CS35L41_GPIO2_INT_PUSH_PULL_LOW,
-	CS35L41_GPIO2_INT_PUSH_PULL_HIGH,
-	CS35L41_GPIO2_PDM_CLK,
-	CS35L41_GPIO2_PDM_DATA,
-};
-
-struct cs35l41_gpio_cfg {
-	bool valid;
-	bool pol_inv;
-	bool out_en;
-	unsigned int func;
-};
-
-struct cs35l41_hw_cfg {
-	bool valid;
+struct cs35l41_classh_cfg {
+	bool classh_bst_override;
+	bool classh_algo_enable;
+	int classh_bst_max_limit;
+	int classh_mem_depth;
+	int classh_release_rate;
+	int classh_headroom;
+	int classh_wk_fet_delay;
+	int classh_wk_fet_thld;
+};
+
+struct cs35l41_irq_cfg {
+	bool irq_pol_inv;
+	bool irq_out_en;
+	int irq_src_sel;
+};
+
+struct cs35l41_platform_data {
+	bool sclk_frc;
+	bool lrclk_frc;
+	bool amp_gain_zc;
+	bool dsp_ng_enable;
+	bool invert_pcm;
+	bool hibernate_enable;
+	bool fwname_use_revid;
+	enum cs35l41_shared_boost shared_boost;
 	int bst_ind;
+	int bst_vctrl;
 	int bst_ipk;
 	int bst_cap;
+	int temp_warn_thld;
+	int dsp_ng_pcm_thld;
+	int dsp_ng_delay;
+	unsigned int hw_ng_sel;
+	unsigned int hw_ng_delay;
+	unsigned int hw_ng_thld;
 	int dout_hiz;
-	struct cs35l41_gpio_cfg gpio1;
-	struct cs35l41_gpio_cfg gpio2;
-	unsigned int spk_pos;
-
-	enum cs35l41_boost_type bst_type;
-};
-
-struct cs35l41_otp_packed_element_t {
-	u32 reg;
-	u8 shift;
-	u8 size;
-};
-
-struct cs35l41_otp_map_element_t {
-	u32 id;
-	u32 num_elements;
-	const struct cs35l41_otp_packed_element_t *map;
-	u32 bit_offset;
-	u32 word_offset;
-};
-
-enum cs35l41_cspl_mbox_status {
-	CSPL_MBOX_STS_RUNNING = 0,
-	CSPL_MBOX_STS_PAUSED = 1,
-	CSPL_MBOX_STS_RDY_FOR_REINIT = 2,
-};
-
-enum cs35l41_cspl_mbox_cmd {
-	CSPL_MBOX_CMD_NONE = 0,
-	CSPL_MBOX_CMD_PAUSE = 1,
-	CSPL_MBOX_CMD_RESUME = 2,
-	CSPL_MBOX_CMD_REINIT = 3,
-	CSPL_MBOX_CMD_STOP_PRE_REINIT = 4,
-	CSPL_MBOX_CMD_HIBERNATE = 5,
-	CSPL_MBOX_CMD_OUT_OF_HIBERNATE = 6,
-	CSPL_MBOX_CMD_UNKNOWN_CMD = -1,
-	CSPL_MBOX_CMD_INVALID_SEQUENCE = -2,
-};
-
-/*
- * IRQs
- */
-#define CS35L41_IRQ(_irq, _name, _hand)		\
-	{					\
-		.irq = CS35L41_ ## _irq ## _IRQ,\
-		.name = _name,			\
-		.handler = _hand,		\
-	}
-
-struct cs35l41_irq {
+	struct cs35l41_irq_cfg irq_config1;
+	struct cs35l41_irq_cfg irq_config2;
+	struct cs35l41_classh_cfg classh_config;
+};
+
+struct cs35l41_rst_cache {
+	bool extclk_cfg;
+	int asp_width;
+	int asp_wl;
+	int asp_fmt;
+	int lrclk_fmt;
+	int sclk_fmt;
+	int clock_mode;
+	int fs_cfg;
+};
+
+struct cs35l41_vol_ctl {
+	struct workqueue_struct *ramp_wq;
+	struct work_struct ramp_work;
+	struct mutex vol_mutex; /* Protect set volume */
+	atomic_t manual_ramp; /* boolean */
+	atomic_t ramp_abort; /* boolean */
+	atomic_t vol_ramp; /* boolean */
+	atomic_t playback; /* boolean */
+	int ramp_init_att;
+	int ramp_knee_att;
+	unsigned int ramp_knee_time;
+	unsigned int ramp_end_time;
+	int dig_vol;
+	unsigned int auto_ramp_timeout;
+	unsigned int output_dev;
+	unsigned int prev_active_dev;
+	ktime_t dev_timestamp;
+};
+
+struct cs35l41_private {
+	struct wm_adsp dsp; /* needs to be first member */
+	struct snd_soc_codec *codec;
+	struct cs35l41_platform_data pdata;
+	struct device *dev;
+	struct regmap *regmap;
+	struct regulator_bulk_data supplies[2];
+	int num_supplies;
 	int irq;
-	const char *name;
-	irqreturn_t (*handler)(int irq, void *data);
-};
-
-#define CS35L41_REG_IRQ(_reg, _irq)					\
-	[CS35L41_ ## _irq ## _IRQ] = {					\
-		.reg_offset = (CS35L41_ ## _reg) - CS35L41_IRQ1_STATUS1,\
-		.mask = CS35L41_ ## _irq ## _MASK			\
-	}
-
-/* (0x0000E010) CS35L41_IRQ1_STATUS1 */
-#define CS35L41_BST_OVP_ERR_SHIFT		6
-#define CS35L41_BST_OVP_ERR_MASK		BIT(CS35L41_BST_OVP_ERR_SHIFT)
-#define CS35L41_BST_DCM_UVP_ERR_SHIFT		7
-#define CS35L41_BST_DCM_UVP_ERR_MASK		BIT(CS35L41_BST_DCM_UVP_ERR_SHIFT)
-#define CS35L41_BST_SHORT_ERR_SHIFT		8
-#define CS35L41_BST_SHORT_ERR_MASK		BIT(CS35L41_BST_SHORT_ERR_SHIFT)
-#define CS35L41_TEMP_WARN_SHIFT			15
-#define CS35L41_TEMP_WARN_MASK			BIT(CS35L41_TEMP_WARN_SHIFT)
-#define CS35L41_TEMP_ERR_SHIFT			17
-#define CS35L41_TEMP_ERR_MASK			BIT(CS35L41_TEMP_ERR_SHIFT)
-#define CS35L41_AMP_SHORT_ERR_SHIFT		31
-#define CS35L41_AMP_SHORT_ERR_MASK		BIT(CS35L41_AMP_SHORT_ERR_SHIFT)
-
-enum cs35l41_irq_list {
-	CS35L41_BST_OVP_ERR_IRQ,
-	CS35L41_BST_DCM_UVP_ERR_IRQ,
-	CS35L41_BST_SHORT_ERR_IRQ,
-	CS35L41_TEMP_WARN_IRQ,
-	CS35L41_TEMP_ERR_IRQ,
-	CS35L41_AMP_SHORT_ERR_IRQ,
-
-	CS35L41_NUM_IRQ
-};
-
-extern struct regmap_config cs35l41_regmap_i2c;
-extern struct regmap_config cs35l41_regmap_spi;
-
-int cs35l41_test_key_unlock(struct device *dev, struct regmap *regmap);
-int cs35l41_test_key_lock(struct device *dev, struct regmap *regmap);
-int cs35l41_otp_unpack(struct device *dev, struct regmap *regmap);
-int cs35l41_register_errata_patch(struct device *dev, struct regmap *reg, unsigned int reg_revid);
-int cs35l41_set_channels(struct device *dev, struct regmap *reg,
-			 unsigned int tx_num, unsigned int *tx_slot,
-			 unsigned int rx_num, unsigned int *rx_slot);
-int cs35l41_gpio_config(struct regmap *regmap, struct cs35l41_hw_cfg *hw_cfg);
-void cs35l41_configure_cs_dsp(struct device *dev, struct regmap *reg, struct cs_dsp *dsp);
-int cs35l41_set_cspl_mbox_cmd(struct device *dev, struct regmap *regmap,
-			      enum cs35l41_cspl_mbox_cmd cmd);
-int cs35l41_write_fs_errata(struct device *dev, struct regmap *regmap);
-int cs35l41_enter_hibernate(struct device *dev, struct regmap *regmap,
-			    enum cs35l41_boost_type b_type);
-int cs35l41_exit_hibernate(struct device *dev, struct regmap *regmap);
-int cs35l41_init_boost(struct device *dev, struct regmap *regmap,
-		       struct cs35l41_hw_cfg *hw_cfg);
-bool cs35l41_safe_reset(struct regmap *regmap, enum cs35l41_boost_type b_type);
-int cs35l41_global_enable(struct regmap *regmap, enum cs35l41_boost_type b_type, int enable);
+	int clksrc;
+	int extclk_freq;
+	int extclk_cfg;
+	int sclk;
+	int lrclk_fmt;
+	int sclk_fmt;
+	int amp_hibernate;
+	bool reload_tuning;
+	bool i2s_mode;
+	bool swire_mode;
+	bool halo_booted;
+	bool bus_spi;
+	bool fast_switch_en;
+	bool force_int;
+	bool hibernate_force_wake;
+	bool speaker_port_blocked;
+	u32 speaker_open_short_status;
+	/* GPIO for /RST */
+	struct gpio_desc *reset_gpio;
+	/* Run-time mixer */
+	unsigned int fast_switch_file_idx;
+	struct soc_enum fast_switch_enum;
+	const char **fast_switch_names;
+	struct delayed_work hb_work;
+	struct workqueue_struct *wq;
+	struct mutex hb_lock;
+	struct cs35l41_rst_cache reset_cache;
+	struct mutex force_int_lock;
+	struct cs35l41_vol_ctl vol_ctl;
+	unsigned int ctl_cache[CS35L41_CTRL_CACHE_SIZE];
+	u32 trim_cache[CS35L41_TRIM_CACHE_SIZE];
+	const char *dt_name;
+	unsigned int gpi_global_en;
+	bool enabled;
+};
+
+int cs35l41_probe(struct cs35l41_private *cs35l41, struct cs35l41_platform_data *pdata);
+void cs35l41_remove(struct cs35l41_private *cs35l41);
 
 #endif /* __CS35L41_H */
--- a/sound/soc/codecs/Kconfig	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/codecs/Kconfig	2022-07-08 01:12:12.000000000 +0200
@@ -627,23 +600,19 @@
 	tristate "Cirrus Logic CS35L36 CODEC"
 	depends on I2C
 
-config SND_SOC_CS35L41_LIB
-	tristate
-
 config SND_SOC_CS35L41
-	tristate
+        tristate "Cirrus Logic CS35L41 CODEC"
+        select SND_SOC_WM_ADSP
 
 config SND_SOC_CS35L41_SPI
 	tristate "Cirrus Logic CS35L41 CODEC (SPI)"
 	depends on SPI_MASTER
-	select SND_SOC_CS35L41_LIB
 	select SND_SOC_CS35L41
 	select REGMAP_SPI
 
 config SND_SOC_CS35L41_I2C
 	tristate "Cirrus Logic CS35L41 CODEC (I2C)"
 	depends on I2C
-	select SND_SOC_CS35L41_LIB
 	select SND_SOC_CS35L41
 	select REGMAP_I2C
 
--- a/sound/soc/codecs/Makefile	2023-02-15 21:20:00.000000000 +0100
+++ b/sound/soc/codecs/Makefile	2022-07-08 01:12:12.000000000 +0200
@@ -55,10 +54,8 @@
 snd-soc-cs35l34-objs := cs35l34.o
 snd-soc-cs35l35-objs := cs35l35.o
 snd-soc-cs35l36-objs := cs35l36.o
-snd-soc-cs35l41-lib-objs := cs35l41-lib.o
-snd-soc-cs35l41-objs := cs35l41.o
-snd-soc-cs35l41-spi-objs := cs35l41-spi.o
-snd-soc-cs35l41-i2c-objs := cs35l41-i2c.o
+snd-soc-cs35l41-spi-objs := cs35l41-spi.o cs35l41.o cs35l41-tables.o
+snd-soc-cs35l41-i2c-objs := cs35l41-i2c.o cs35l41.o cs35l41-tables.o
 snd-soc-cs35l45-tables-objs := cs35l45-tables.o
 snd-soc-cs35l45-objs := cs35l45.o
 snd-soc-cs35l45-spi-objs := cs35l45-spi.o
@@ -405,8 +382,6 @@
 obj-$(CONFIG_SND_SOC_CS35L34)	+= snd-soc-cs35l34.o
 obj-$(CONFIG_SND_SOC_CS35L35)	+= snd-soc-cs35l35.o
 obj-$(CONFIG_SND_SOC_CS35L36)	+= snd-soc-cs35l36.o
-obj-$(CONFIG_SND_SOC_CS35L41)	+= snd-soc-cs35l41.o
-obj-$(CONFIG_SND_SOC_CS35L41_LIB)	+= snd-soc-cs35l41-lib.o
 obj-$(CONFIG_SND_SOC_CS35L41_SPI)	+= snd-soc-cs35l41-spi.o
 obj-$(CONFIG_SND_SOC_CS35L41_I2C)	+= snd-soc-cs35l41-i2c.o
 obj-$(CONFIG_SND_SOC_CS35L45_TABLES)	+= snd-soc-cs35l45-tables.o
